# 6.Protokoll  
  
  **Name**:  *Bernhard Reinbacher*  
  **Datum:** *20.03.2018*  
  **Uhrzeit:** *9:40-12:25*  
  **Gruppe:** *3*  
  
   
    
 **Abwesend:** Ruffenacht Florian, Sammer Daniel  
 **Anwesend:** Bernhard Reinbacher, Sackl Martin, Sackl Roland, Schmuck Martin, Schuster Patrick
*********************************************************************************************************************************** 
 # Temperatursensor
Wie schon in der letzten Einheit begonnen, musste ein Temperatursensor am Sureboard ausgewertet werden. Eine Java Swing Applikation soll sich mit dem Sureboard verbinden und trennen können und auch die aktuelle Temperatur ausgeben können. Für die Datenverbindung zwischen Sureboard und Java Swing Applikation verwenden wir das Feldbussystem *Modbus*. Weitere Infos zu Modbus und zur letzen Einheit [hier](/reibem14/README_13_03_2018.md)    
***********************************************************************************************************************************   
# JAVA Swing Applikation  
Im allgemeinen zeichnet sich eine gute GUI darin aus, dass der Endbenutzer im Grunde nichts mehr falsch machen kann d.h. alles muss so programmiert und designed werden, sodass es keinen Platz für Interpretationen der einzelnen Punkte(Buttons, Textfelder, usw. )geben kann.  
  
## Design  
![GUI](/reibem14/Temperatur_GUI.PNG)  
Diese obige GUI bekamen wir schon fertig gezeichnet von Prof. Steiner. Unsere Aufgabe ist es, die einzelnen Menüpunkte( Verbinden, Trennen, ...) zu realisieren. Weiters sollen sich die Menüpunkte jedes mal deaktivieren, wenn sie nicht gebraucht bzw. wenn sie nicht erreichbar sind.  
## Source Code    
Hier sind die Methoden zu finden, die für das richtige Ablaufen des Programmes notwendig sind.  
### updateSwingControls()    
Diese Methode wird immer dann aufgerufen, wenn andere Methoden im Hintergrund Verbindung ändern oder wenn das Sureboard ein- oder augesteckt wird. Sie aktiviert bzw. deaktiviert Menüpunkte. 

```java 
private void updateSwingControls ()
  {

    jbutConnect.setEnabled(false);
    jbutContinousMeasurement.setEnabled(false);
    jbutDisconnect.setEnabled(false);
    jbutRefresh.setEnabled(false);
    jbutSingleMeasurement.setEnabled(false);
    jbutStopMeasurement.setEnabled(false);
    jcbSerialDevice.setEnabled(false);

    if(activeWorker != null){
      setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
      return;
    }
    else{
      setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
    }
    
    
    
    jbutRefresh.setEnabled(true);
    if (jcbSerialDevice.getModel().getSize() > 0)
    {
      jcbSerialDevice.setEnabled(true);
      jbutConnect.setEnabled(true);
    }

    if(serialPort != null && serialPort.isOpened()){
      jcbSerialDevice.setEnabled(false);
      jbutConnect.setEnabled(false);
      jbutRefresh.setEnabled(false);
      jbutDisconnect.setEnabled(true);
      jbutSingleMeasurement.setEnabled(true);
    }
  }
```
### showThrowable()     
Die Exception wird gefangen und überprüft ob *null* oder *empty* ist. Danach wird die Exception Message in einem Dialogfenster ausgegeben.
```java
private void showThrowable (Throwable th)
  {
    th.printStackTrace(System.err);
    String msg = th.getMessage(); 
    if(msg == null || msg.isEmpty()){
      msg = th.getClass().getSimpleName();  
    }
    JOptionPane.showMessageDialog(
            this, 
            msg, 
            "Fehler aufgetreten", 
            JOptionPane.ERROR_MESSAGE);
  }  
  ```  
  ### refreshSerialPorts()    
  Diese Funktion wird aufgerufen, wenn sich die Verbindungen zwischen µC und PC ändert. d.H. wenn man den USB stecker hinein odeer heraus zieht, kann man dann in der Combo Box die Verbindung sehen oder eben nicht mehr.
  ```java  
  private void refreshSerialPorts ()
  {

    final String[] ports = jssc.SerialPortList.getPortNames();
    ComboBoxModel<String> model = new DefaultComboBoxModel<>(ports);
    jcbSerialDevice.setModel(model);
  }  
  ```  
  ### connect()     
  Wie schon der Name sagt, verbindet diese Funktion unser Sure Board mit dem PC. Dabei werden auch wichtige Einstellungen wie Baudrate, Datenbits, Parity und Stopbits getroffen. Zum Schluss wird noch *updateSwingControls* aufgerufen um die GUI Elemente zu aktualisieren.
  ```java  
    private void connect ()
  {
    try
    {
      final String port = (String) jcbSerialDevice.getSelectedItem();
      serialPort = new jssc.SerialPort(port);
      if(serialPort.openPort()==false){
        throw new Exception("openPort() returns false");
      }
      if(serialPort.setParams(
              SerialPort.BAUDRATE_57600,
              SerialPort.DATABITS_8,
              SerialPort.PARITY_NONE,
              SerialPort.STOPBITS_2
              ) == false)
      {
        throw new Exception("setParams returns false");
      }
    }
    catch (Throwable th)  // ausnahme durch JNI
    {
      showThrowable(new Exception("Kann nicht verbinden", th));
      if(serialPort != null){
      try{
        serialPort.closePort();
      }
      catch(Throwable th2){
        //th2.printStackTrace(System.err);
        th.addSuppressed(th2);  // bessere Variante
      }
      serialPort = null;
      }
    }
    finally{
      updateSwingControls();
    }
  }
  ```  
  ### disconnect()    
  Mit dieser Funktion kann man die Verbindung zwischen Sure Board und PC trennen. Wie schon bei vorhergegangenen Funktionen wird wieder *updateSwingControls* aufgerufen.
  ```java  
    private void disconnect(){
    try{
      if(serialPort.closePort() == false){
        throw new Exception("closePort() return false");
      }
    }
    catch(Throwable th){
      showThrowable(th);
    }
    finally{
      serialPort = null;
      updateSwingControls();
    }
  }

 ```   
 ###  GUISingleMeasurementWorker  
 Mithilfe dieses Swingworkers, wird im Hintergrund die Temperaturmessung durchgeführt und das Ergebnis auf der GUI angezeigt. Der GUISingleMeasurementWorker wird vom SingleMeasurementWorker abgeleitet, in welchem jede Sekunde ein Ereignis stattfindet. Da in unseren Fall noch keine Temperaturmessung programmiert wurde, wird jedes Mal ein Fixwert von 24.5°C übergeben.  
 
 ```java  
   private class GuiSingleMeasurementWorker extends SingleMeasurementWorker{

    @Override
    protected void done ()
    {
      try{
        double temp = get();
        jlaTemperatur.setText(String.format("%.1f °C", temp));
      }
      catch(Exception ex){
        showThrowable(new Exception("Einzelmessung gescheitert", ex));
      }
      finally{
        activeWorker = null;
        updateSwingControls();
      }
    }
```
**********************************************************************************************************************************   
## Wichtige Information    
    
Name | Beschreibung  
---- | ------------    
**finally** | Ein *finally* nach einem *try() catch()* wird immer ausgeführt. Somit ist dem *finally* egal was in der *try() catch()* passiert.  
**JSSC** | Diese Bibliothek muss ich selbst einbinden um damit zu arbeiten. Sie wird verwendet wenn man mit Seriellen Schnittstellen arbeitet.  
**Testumgebung** | Bei guten Programmen ist es unerlässlich mit Beginn des Programmierens, auch eine Testumgebung zu programmieren. Diese soll Fehler, Errors und dergleichen, während und nach dem Programmieren erkennen.  
**Dokumentationskommentare** | Man kann dann mittels *html* eine HTML-Dokumentation erzeugen. Dafür gibt es den Befehl *generate Java Dok*.  
**Errors** | schwerwiegende Fehler in der JVM  
**Exceptions** | normale Fehler, die man mit *try() catch()* fangen muss  

