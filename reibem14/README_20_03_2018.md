# 6.Protokoll  
  
  **Name**:  *Bernhard Reinbacher*  
  **Datum:** *13.03.2018*  
  **Uhrzeit:** *9:40-12:25*  
  **Gruppe:** *3*  
  
   
    
 **Abwesend:** Ruffenacht Florian, Sammer Daniel  
 **Anwesend:** Bernhard Reinbacher, Sackl Martin, Sackl Roland, Schmuck Martin, Schuster Patrick
*********************************************************************************************************************************** 
 # Temperatursensor
Wie schon in der letzten Einheit begonnen, musste ein Temperatursensor am Sureboard ausgewertet werden. Eine Java Swing Applikation soll sich mit dem Sureboard verbinden und trennen können und auch die aktuelle Temperatur ausgeben können. Für die Datenverbindung zwischen Sureboard und Java Swing Applikation verwenden wir das Feldbussystem *Modbus*. Weitere Infos zu Modbus und zur letzen Einheit [hier](/reibem14/README_13_03_2018.md)    
***********************************************************************************************************************************   
# JAVA Swing Applikation  
Im allgemeinen zeichnet sich eine gute GUI darin aus, dass der Endbenutzer im Grunde nichts mehr falsch machen kann d.h. alles muss so programmiert und designed werden, sodass es keinen Platz für Interpretationen der einzelnen Punkte(Buttons, Textfelder, usw. )geben kann.  
  
## Design  
![GUI](/reibem14/Temperatur_GUI.PNG)  
Diese obige GUI bekamen wir schon fertig gezeichnet von Prof. Steiner. Unsere Aufgabe ist es, die einzelnen Menüpunkte( Verbinden, Trennen, ...) zu realisieren. Weiters sollen sich die Menüpunkte jedes mal deaktivieren, wenn sie nicht gebraucht bzw. wenn sie nicht erreichbar sind.  
## Source Code    
Hier sind die Methoden zu finden, die für das richtige Ablaufen des Programmes notwendig sind.  
### updateSwingControls()    
Diese Methode wird immer dann aufgerufen, wenn andere Methoden im Hintergrund Verbindung ändern oder wenn das Sureboard ein- oder augesteckt wird. Sie aktiviert bzw. deaktiviert Menüpunkte. 

```java 
private void updateSwingControls ()
  {

    jbutConnect.setEnabled(false);
    jbutContinousMeasurement.setEnabled(false);
    jbutDisconnect.setEnabled(false);
    jbutRefresh.setEnabled(false);
    jbutSingleMeasurement.setEnabled(false);
    jbutStopMeasurement.setEnabled(false);
    jcbSerialDevice.setEnabled(false);

    if(activeWorker != null){
      setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
      return;
    }
    else{
      setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
    }
    
    
    
    jbutRefresh.setEnabled(true);
    if (jcbSerialDevice.getModel().getSize() > 0)
    {
      jcbSerialDevice.setEnabled(true);
      jbutConnect.setEnabled(true);
    }

    if(serialPort != null && serialPort.isOpened()){
      jcbSerialDevice.setEnabled(false);
      jbutConnect.setEnabled(false);
      jbutRefresh.setEnabled(false);
      jbutDisconnect.setEnabled(true);
      jbutSingleMeasurement.setEnabled(true);
    }
  }
```
### showThrowable    
```java
private void showThrowable (Throwable th)
  {
    th.printStackTrace(System.err);
    String msg = th.getMessage(); //grundsätzlich gut, aber th kann auch null sein
    if(msg == null || msg.isEmpty()){
      msg = th.getClass().getSimpleName();  //hier bekommt msg den Klassenname im Falle das msg null oder Empty ist
    }
    JOptionPane.showMessageDialog(
            this, 
            msg, 
            "Fehler aufgetreten", 
            JOptionPane.ERROR_MESSAGE);
  }  
  ```  
  
