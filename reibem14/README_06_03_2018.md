# 4.Protokoll  
  
  **Name**:  *Bernhard Reinbacher*  
  **Datum:** *06.03.2018*  
  **Uhrzeit:** *9:40-12:25*  
  **Gruppe:** *3*  
  
   
    
 **Abwesend:** niemand  
 **Anwesend:** Bernhard Reinbacher, Ruffenacht Florian, Sackl Martin, Sackl Roland, Sammer Daniel, Schmuck Martin, Schuster Patrick
***********************************************************************************************************************************

## Wiederholung
Zu begin dieser Laboreinheit wiederholten wir den Stoff der letzen Eineheit vom 5.12.2017. [Protokoll 3. Einheit](/reibem14/README_17_12_05.md)

## Information über Elektrofahrzeuge
Da Prof. Steiner und Lukas Strauß bereits Elektroautos haben, wurden interessante Informationen ausgetauscht.    
* wie verhält sich das Auto im Winter und wie kommt es mit den Temperaturen zurecht?  
* wie weit lässt sich der Akku mittels Schnellladung aufladen?  
* Hyundai Ioniq und VW E-Golf vergleich; Akkugröße, Reichweite, Verbrauch...  

********************************************************************************************************************************

## Übersetzungsvorgang eines Programmes  
Im groben Sprachgebrauch versteht man unter _Compelieren_ das gesamte Übersetzen eines Programmes, jedoch ist das Compelieren nur ein Teil davon. Für die Gesamte Übersetzung eines Programmes benötigt man folgende Schritte:    

Name | Funktion      
------- | --------  
*1. Präprozessieren* | Hier wird das Programm(*main.c*) vorbereitet. d.h Eingabedaten werden bereitgestellt, Headerdateien hinzugefügt.   
*2. Compelieren* | In diesem Schritt wird aus dem preprozessierten Code ein Assemblercode erzeugt. Die Datei heißt nun *main.a*  
*3. Assemblieren* | Nun wird die *main.a*, welche in Assemblersprache geschrieben ist, in Maschinenbefehle übersetzt. Die Datei heißt nun *main.o*.  
*4. Linken* | Der Linker verbindet alle Programmteile und vereint sie zu einem ausführbaren Programm (*a.exe* für Windows oder *a.out* für Ubunto)  
*5. Umwandelen* | Hier wird die *a.out* oder *a.exe* in ein Format umgewandelt, das der Programmer versteht. z.B. Hex  
********************************************************************************************************************************  
  
## make  
Mithilfe des make-Tools kann man den Übersetztungsvorgang steuern. Hierfür benötigt man ein *Makefile*.  
### Makefile  
Ein Makefile wird mithilfe eines Texteditors geschrieben, worin die Information für das make Tool stehen. Es werden Ziele(targets), Abhängigkeiten(dependencis) und Kommandos(Commands) benötigt. In der Folgenden Grafik soll dies veranschaulicht werden.  
```
Ziel A: Abhängigkeiten  
*tab* Kommando 1  
*tab* Kommando 2   
*tab* Kommando 3 ...  
  
Ziel B: Abhängigkeiten  
*tab* Kommando 1  
*tab* Kommando 2  
*tab* Kommando 3 ...   
```  
Bei *tab* ist sehr sehr wichtig, dass man einen echten Tabulator verwendet und dass man zwischen die Zielen eine Leerzeile setzt. Ansonsten funktioniert das gesamte make Tool nicht.  
********************************************************************************************************************************
### make im Terminal  
Tippt man das **make** im Terminal ein, sucht es sich selbstständig ob die angegebenen Zieler erreicht werden können. Weiters schaut es auch ob alle Dateien auf den neuesten Stand sind. Angenommen falls die *main.c* einen jüngeren Zeistempel hat als die *main.o* dann wird alles neu compeliert und gelinkt. Falls man die Zeitstempel nahträglich ändern will, kann man dies mit *touch* tun.  
#### Touch  
Mit touch kann man den Zeitstempel von Dateien ändern, d.h. auf die aktuelle Zeit bringen. Falls noch keine Datei vorhanden ist, erzeugt touch eine neue leere Datei.  

