# 4.Protokoll  
  
  **Name**:  *Bernhard Reinbacher*  
  **Datum:** *06.03.2018*  
  **Uhrzeit:** *9:40-12:25*  
  **Gruppe:** *3*  
  
   
    
 **Abwesend:** niemand  
 **Anwesend:** Bernhard Reinbacher, Ruffenacht Florian, Sackl Martin, Sackl Roland, Sammer Daniel, Schmuck Martin, Schuster Patrick
***********************************************************************************************************************************

## Wiederholung
Zu begin dieser Laboreinheit wiederholten wir den Stoff der letzen Eineheit vom 5.12.2017. [Protokoll 3. Einheit](/reibem14/README_17_12_05.md)

## Information über Elektrofahrzeuge
Da Prof. Steiner und Lukas Strauß bereits Elektroautos haben, wurden interessante Informationen ausgetauscht.    
* wie verhält sich das Auto im Winter und wie kommt es mit den Temperaturen zurecht?  
* wie weit lässt sich der Akku mittels Schnellladung aufladen?  
* Hyundai Ioniq und VW E-Golf vergleich; Akkugröße, Reichweite, Verbrauch...  

********************************************************************************************************************************

## Übersetzungsvorgang eines Programmes  
Im groben Sprachgebrauch versteht man unter _Compelieren_ das gesamte Übersetzen eines Programmes, jedoch ist das Compelieren nur ein Teil davon. Für die Gesamte Übersetzung eines Programmes benötigt man folgende Schritte:    

Name | Funktion      
------- | --------  
*1. Präprozessieren* | Hier wird das Programm(*main.c*) vorbereitet. d.h Eingabedaten werden bereitgestellt, Headerdateien hinzugefügt.   
*2. Compelieren* | In diesem Schritt wird aus dem preprozessierten Code ein Assemblercode erzeugt. Die Datei heißt nun *main.a*  
*3. Assemblieren* | Nun wird die *main.a*, welche in Assemblersprache geschrieben ist, in Maschinenbefehle übersetzt. Die Datei heißt nun *main.o*.  
*4. Linken* | Der Linker verbindet alle Programmteile und vereint sie zu einem ausführbaren Programm (*a.exe* für Windows oder *a.out* für Ubunto)  
*5. Umwandelen* | Hier wird die *a.out* oder *a.exe* in ein Format umgewandelt, das der Programmer versteht. z.B. Hex  
********************************************************************************************************************************  
  
## make  
Mithilfe des make-Tools kann man den Übersetztungsvorgang steuern. Hierfür benötigt man ein *Makefile*.  
Weitere Informationen zum make Tool:  
[Wikipedia/make](https://de.wikipedia.org/wiki/Make)  
[Mikiwiki/make](http://mikiwiki.org/wiki/make)   
Der großer Vorteil ist, dass wenn man an einen Programmierprojekt arbeitet, nicht alle Dateien mit Partnern ausgetauscht werden müssen. Es reicht nämlich, wenn man die *main.c* und das dazupassende *Makefile* übermittelt. Die restlichen Dateien (main.o und Ausgabedatei) werden dann vor Ort am Rechner produziert werden. Dies vermindert die Datenübertragung und funktioniert auch immer, solange das *Makefile* gleich bleibt.  


### Makefile  
Ein Makefile wird mithilfe eines Texteditors geschrieben, worin die Information für das make Tool stehen. Es werden Ziele(targets), Abhängigkeiten(dependencis) und Kommandos(Commands) benötigt. In der Folgenden Grafik soll dies veranschaulicht werden.  
```
Ziel A: Abhängigkeiten  
*tab* Kommando 1  
*tab* Kommando 2   
*tab* Kommando 3 ...  
  
Ziel B: Abhängigkeiten  
*tab* Kommando 1  
*tab* Kommando 2  
*tab* Kommando 3 ...   
```  
Bei *tab* ist sehr sehr wichtig, dass man einen echten Tabulator verwendet und dass man zwischen die Zielen eine Leerzeile setzt. Ansonsten funktioniert das gesamte make Tool nicht.  

### make im Terminal  
Tippt man das **make** im Terminal ein, sucht es sich selbstständig ob die angegebenen Zieler erreicht werden können. Weiters schaut es auch ob alle Dateien auf den neuesten Stand sind. Angenommen falls die *main.c* einen jüngeren Zeistempel hat als die *main.o* dann wird alles neu compeliert und gelinkt. Falls man die Zeitstempel nahträglich ändern will, kann man dies mit *touch* tun.  
#### Touch  
Mit touch kann man den Zeitstempel von Dateien ändern, d.h. auf die aktuelle Zeit bringen. Falls noch keine Datei vorhanden ist, erzeugt touch eine neue leere Datei.    
    
Im Grunde läuft die Abbarbeitung eines Makefile's solange, solange kein Fehler auftritt. Falls doch ein Fehler auftritt wird die Abbarbeitung gestoppt. Dies kann speziell zu kritisch werden, wenn gerade ein Befehl ausgeführt wird. Um dieses Problem vorzubeugen, schreiben wir vor *rm* ein *-*. Dies führt dazu, dass auch bei einem Fehler, der Löschbefehl ausgeführt wird.  
********************************************************************************************************************************
## Übung mit dem make Tool  
### 1. Übung  
Mithilfe des nano Editor und des make Tools, sollt "Guten Morgen" am Terminal ausgegeben werden.  
**main.c:**  
```  
#include <stdio.h>

int main(){
        printf("Guten Morgen\n");
        return 0;
}  
```   
**Makefile**  
```  
# Hallo, das ist ein Kommentar

test1: main.o
        gcc -otest1 main.o

main.o: main.c
        gcc -c main.c

cleanAndBuild: clean test1

clean:
        -rm main.o
        -rm test1
```  

Nun könnte man mittles dem *make* Befehl im Terminal, die Abarbeitung starten.    

Befehl | Beschreibung  
------ | ------------    
make clean | Alle, von *make* erstellten Dateien, werden gelöscht.   
make cleanAndBuild |  Alle, von *make* erstellten Dateien, werden gelöscht und danach wieder erstellt.
make main.o | Der Programmiercode wird in Maschinenbefehlt übersetzt.  
  
### 2.Übung  
Ein C-Programm für den Arduino Nano schreiben, das die LED blinken lässt. Hierfür werden mehrere Dateien benötigt, die man dann alle richtig im Makeflie abhängig machen muss.  
**main.c**  
```  
#include <avr/io.h>
#include <util/delay.h>
#include "util.h"

int main(){

        DDRB = (1<<PB5);

        while(1){
           toggleLed();
           _delay_ms(200);
        }
        return 0;

}  
```  
**util.c**  
```  
#include <avr/io.h>

void toggleLed()
{
   PORTB ^=(1 << PB5);
}  
```  
**util.h**  
```  
#ifndef UTIL_H
#define UTIL_H

extern void toggleLed();

#endif  // UTIL_H
```  
**Makefile**  
```  
main.hex: main.elf
        avr-objcopy -O ihex main.elf main.hex

main.elf: main.o util.o
        avr-gcc -o main.elf main.o util.o

main.o: main.c util.h
        avr-gcc -mmcu=atmega328p -Os -DF_CPU=16000000 -c main.c  

util.o: util.c
        avr-gcc -mmcu=atmega328p -Os -DF_CPU=16000000 -c util.c 

clean: 
        -rm *.o
        -rm main.elf
        -rm main.hex    
 ```  
 
Datei | Funktion  
----- | --------  
main.c | Hier wird das eigentliche Programm zum Blinken inklusive _delay_ Zeit geschrieben. Es müssen auch alle gebrauchten Dateien inkludiert werden.  
util.c | Darin wird das *toggeln* der LED programmiert.  
util.h | Hier wird die Funktion *toggleLed()* deklariert.  
Makefile | Es ist verantwortlich für die korrekte Abarbeitung des gesamten Übersetzungsprozesses. Hierbei ist sehr wichtig, dass man den richtigen Compiler für den jeweiluge Mikrocontroller auswählt.  
