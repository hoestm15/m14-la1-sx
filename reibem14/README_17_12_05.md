# 3.Protokoll  
  
  **Name**:  *Bernhard Reinbacher*  
  **Datum:** *06.12.2017*  
  **Uhrzeit:** *9:40-12:25*  
  **Gruppe:** *3*  
  
   
    
 **Abwesend:** niemand  
 **Anwesend:** Bernhard Reinbacher, Ruffenacht Florian, Sackl Martin, Sackl Roland, Sammer Daniel, Schmuck Martin, Schuster Patrick  
  
*********************************************************************************************************************************

## Wiederholung   
Zu beginn der Laboreinheit, begannen wir mit einer Wiederholung der Letzten. Dabei wurden alle Funktionen, Maschinenbefehle und Informationen zum Atmega 328P wiederholt. Mehr Infos zur zweiten Einheit [hier](/reibem14/README_17_11_28.md)  
*********************************************************************************************************************************  

## Definieren - Deklarieren - Initialisieren Unterschiede  
* **definieren** Es wird eine Variable am Stack abgespeichert.  
* **deklarieren** Es wird bekanntgegeben, dass es eine Variable gibt. Jedoch wird sie nicht abgespeichert.  
* **initialisieren** Es wird der Variable ein Wert zugewiesen.  
weitere Informationen [hier](https://de.wikibooks.org/wiki/C-Programmierung:_Variablen_und_Konstanten)    
*********************************************************************************************************************************  
## Datentypen  
Datentyp | Funktion    
-------- | --------
*volatile* | Es wird beim Kompelieren nichts mehr wegoptimiert, diese Variable kann jederzeit verändert werden  
*unsigned* | Verändert den eigentlichen Datentyp. Aus *int* 2³² = 4294967296 Werte von -2147483648 bis +2147483647, wird der Wertebereich ins positve Verschoben. Also 2³² von 0 bis +4294967296.  
*double* | Dieser Datentyp existiert am µC eigentlich nicht. Es gibt ihn zwar in der Entwicklungsumgebung, jedoch wird er am µC mittels *float* umgesetzt.      
*********************************************************************************************************************************
## Übungsbeispiele + Analyse    
### 1.Beispiel  
```c
int main(void)  
{  
  volatile unsigned char x;  
  x=10+23;  
  return x;  
}  
```    
![ue1](/reibem14/ue1.png)  

Befehel | Funktion  
------- | --------    
*PUSH R28, R29* | Y-Register wird am Stack gespeichert 
*PUSH R1* | Stackpointer erhält den Wert 0 (R1 ist 0)
*IN R28, 0x3D* | wird zum Stackpointer  
*IN R29, 0x3E* | wird zum Stackpointer  
*LDI R24, 0x14* | in R24 wird unser Wert 33 gespeichert  
*STD Y+2, R24* | R24 wird am Stack gespeicher und gleichzeitig der Stackpointer um 1 erhöht  
*LDD R24, Y+1* | der Wert vom Stackpointer+1 wird geladen, entspricht return 0
*LDI R25, 0x00* | in R25 wird 0 gespeichert  
*POP R0, R28, R29* | Daten werden vom Stackgeholt und somit wird der Stack freigegeben


Um den Stackpointer zu initialiesieren werden Folgende Schritte benötigt:   
![SP](/reibem14/SP.png)  

### 2.Beispiel  
 ```c
int main(void)  
{  
  volatile unsigned char a = 10;  
  volatile unsigned char b= 20;  
  volatile unsigned char f=a+b;  
  return 0;  
}  
```   
### 3.Beispiel  
```c
int main(void)  
{  
  volatile int i;  
  volatile int x;  
  for(i=0;i<10;i++)  
  {  
    x +=10;  
  }  
  return x;
}  



