# 2.Protokoll  
  
  **Name**:  *Bernhard Reinbacher*  
  **Datum:** *28.11.2017*  
  **Uhrzeit:** *9:40-12:25*  
  **Gruppe:** *3*  
  
   
    
 **Abwesend:** niemand  
 **Anwesend:** Bernhard Reinbacher, Ruffenacht Florian, Sackl Martin, Sackl Roland, Sammer Daniel, Schmuck Martin, Schuster Patrick  
  
*********************************************************************************************************************************
## GitHub  
### Issues  
Mithilfe von **Issues** kann man über GitHub auch kommunizieren. GitHub ist nämlich auch eine Kommunikationsplattform, mit der man bei jedem gewünschten Repository eine Nachricht hinterlassen kann. Dies ist sehr nützlich wenn man z.B. einen Bug entdeckt und dann den Entwickler meldet.  
* ein neues Issue erstellen mit*new Issue*     
![gitIssueErstellen](/reibem14/Issue.png)  
* nur der Benutzer kann Issues schließen mittels close   

![gitIssueÜbersicht](/reibem14/Issue_gesamt.png)     

Im Bild ist die Übersicht einer Issue konversation zu sehen 

### Fork  
Als **Fork** wird eine exakte Kopie des gesamten Repositorys verstanden. Dies wird vor allem gemacht falls der Innhaber nichts mehr ändern kann(z.B. wenn er plötzlich stirbt). Wenn es Forks gibt, wird dies auf der Startseite des Repository Inhaber angezeigt. 
Wenn das neu überarbeitete wieder ins original Repository übernommen werden soll, geschieht dies mit **pull request**.    
*********************************************************************************************************************************
## Tiobe Index & Red Monk 
Im *Tiobe Index* werden die wichtigsten Programmiersprachen aufgelistet. Die Daten beziehen sich nach der Popularität der Sprache. Ein weiteres Ranking dafür ist *Red Monk*.   
Weitere Informationen  
* [Tiobe Index](https://www.tiobe.com/tiobe-index/)   
* [Red Monk](http://redmonk.com/sogrady/2017/06/08/language-rankings-6-17/)    
*********************************************************************************************************************************
## Atmega 328p  
* 8 Bit für Werte von 0-255  
* 2 kB SRAM  
* 32 kB Flash   
### CPU  
![CPU](/reibem14/CPU_atmega328p.svg)  
* **Program Counter** gibt die Speicheradresse des nächsten Maschinenbefehls  
* **Stack Pointer**  für den nächsten freien Platz im Stack-Speicher
* **Befehlsregister** hier werden die vom Speicher kommenden Maschinenbefehle zwischengespeichert solange sie ausgeführt werden  
### X-, Y-, und Z-Register  
Mithilfe dieser 3 Register kann man werte größer als 255 speichern. Im Normalfall besteht ein Register aus 8 Bit, damit kann man Werte bis 255 darstellen. Um diesen Bereich zu vergrößern werden, die Register 26-31 zu je 2 zusammengefasst und man kann somit 16 Bit also 65535 Werte darstellen.      
### Stack  
Der **Stack** auf Deutsch Stapelspeicher, wird zum Speicheern von z.B. Rücksprungadressen verwendet. Er arbeitet nach dem Prinzip *last in first-out*. Mit dem Stachpointer wird auf die Adresse des nächsten freien Speicherplatzes gezeigt. Bei unserem Beispiel *0x08FF*. Ein **Stackoverflow** ensteht, wenn der *Stackpointer* auf einen bereits reservierten Speicherplatz zeigt.
*********************************************************************************************************************************  
## Atmel Studio  
* kostenlose Entwicklungsumgebung für AVR- und ARM-Programmierung  
* auch zur Simulation nutzbar
* basiert auf Visual Studion von Windows  
* mit verschiedenen Progammiersprachen kompatibel  
[Atmel Studio](http://www.atmel.com/microsite/atmel-studio/)    
### SRAM in Atmega16  
![SRAM](/reibem14/SRAM_fivu.png)  
*Quelle: Fivu-Skript*
### Übung  
```c
int main ()
{
  return 0;
}
```  
Der gezeigte Quelltext wurde simuliert und analysiert.    
Die Simulation lieferte uns die kompilierten Maschinenbefehle. Weitere genauere Beschreibungen der einzelnen Befehle gibt es unter [Atmel Instruction Set Manual](http://www.atmel.com/images/Atmel-0856-AVR-Instruction-Set-Manual.pdf). Diese Datei wird direkt von der Firma Atmel zur Verfügung gestellt.
### Wichtige Maschinenbefehle   
  
  Maschinenbefehl | Ergebnis
--------------- | --------
RJMP | Sprung zu einer Adresse 
OUT | schreibt Daten von ein und ein anderes Register über
SER | Register wird mit Einsen überschrieben bzw. auf den höchstmöglichen Wert gesetzt
LDI | lädt eine 8-Bit Konstante in die Register 16-31  
RCALL | Sprung zu einer Adresse + ablegen der Rücksprungadresse im Stack  
RET | Rücksprung von einer Funktion, Rücksprungadresse wird vom Stack geladen






