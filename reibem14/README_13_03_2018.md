# 5.Protokoll  
  
  **Name**:  *Bernhard Reinbacher*  
  **Datum:** *13.03.2018*  
  **Uhrzeit:** *9:40-12:25*  
  **Gruppe:** *3*  
  
   
    
 **Abwesend:** niemand  
 **Anwesend:** Bernhard Reinbacher, Ruffenacht Florian, Sackl Martin, Sackl Roland, Schmuck Martin, Sammer Daniel, Schuster Patrick
***********************************************************************************************************************************  
  
 ## Stundenwiederholung  
 Zu beginn wiederholten wir die letzte Labor Einheit, wessen Hauptbestandteil das make-Tool und die Übersetzung eines C-Programmes war. Weitere Infos im letzten [Protokoll](/reibem14/README_06_03_2018.md)  
   
 ## UART Wiederholung  
 Wie bereits in FIVU gelernt, zählten wir die wichtigsten Schritte zur UART-Übertragung auf. UART dient zum Übertragen von Daten. Es benötigt immer ein *Start Bit* und einem oder zwei *Stop Bits*. Dazwischen werden die Daten Byteweise übertragen. Nach den Daten und vor dem Stop Bit, kann es eventuell noch ein *Parity Bit* geben.    
[Wikipedia/UART](https://de.wikipedia.org/wiki/Universal_Asynchronous_Receiver_Transmitter)  
[E-Book SX](https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/55D00BDA8A0D0.symlink?resource_id=0-237409750&m=view#205311307) (nur für Schüler lesbar)  
 ***********************************************************************************************************************************  
     
# Temperatursensor  
Mittels, dem am Sureboard verbauten Temperatursensors LM75A, soll die aktuelle Temperatur über eine Java Swing Applikation angezeigt werden. Die dafür benötigte Verbindung zwischen Temperatursensor und µP, ist mittels I²C realisiert. Die eigentliche Datenübertragung zwischen Sureboard und PC erfolgt mittels eines Feldbussystems, in unserem Fall MODBUS.  
![Schematischer Aufbau](/reibem14/Temperatursensor.png)    
## Intelligenter Sensor  
Ein Sensor ist nur dann intelligent, wenn er ein Rechenwerk besitzt. Das heißt nun, dass wir bei einem unintelligenten Sensor nur einen Spannungswert zurückbekommen und diesen dann selbst in den richtigen Temperaturwert umrechnen müssen. Bei einem Intelligenten Sensor passiert diese Umrechnung bereits im eigenen Rechenwerk.   
In unserem Fall ist der *LM75A* ein unintelligenter Sensor, jedoch in Verbindung am Sureboard ist er intelligent.   
## Feldbussysteme  
  
Feldbussystem | Andwendungsgebiet | Details  
------------- | ----------------- | -----  
**Powerlink** | Industrie | setzt auf Ethernet auf, ist echtzeitfähig, häufig für SPS  
**Profibus** | Industrie | setzt auf RS485 auf  
**Modbus** | Industrie | setzt auf RS485 und TCP/IP auf   
**CAN, LIN, Flexray** | Automobilindustrie | 
**KNX** | Haustechnik |    
***********************************************************************************************************************************   
# Modbus  
Das Feldbusprotokoll Modbus wurde 1979 für die Kommunikation zwischen zwei SPS Geräten entwickelt. Heutzutage wird es gerne in der Haustechnik und in der Industrie verwendet, da es ein offenes Protokoll ist und sich Lösungen mit RS232-, RS482- und TCP/IP- Verbindungen realisieren lassen.  
  
Modbus arbeitet nach dem einfachen Prinzip **Server/Client(Request/Response)**. In unserem Fall arbeitet der PC als Client und fragt nach der Temperatur und das Sureboard arbeitet als Server, welcher die Anfragen bearbeitet und zurückübermittelt.  
![Server/Client](/reibem14/modbus.png)    
## Modbus Gateway  
![Modusse](/reibem14/modi.PNG)  
Wie im Bild ersichtlich, gibt es zwei unterschiedliche Varianten der Pakete. Die PDU besteht immer aus *Function Code* und *Data*. Bei der ADU kommen noch zusätzlich *Adresse* und ein *Fehler-Check* hinzu. Bei Modbus TCP fällt dies weg, da Adresse und Prüfsumme schon im TCP/IP Paket enthalten sind. Die Maximalgröße der ADU-Pakte bei *RS232 / RS485 = 256 Bytes* und bei *TCP = 260 Bytes*.

Es gibt drei unterschiedliche Übertragungsvarianten:  
* **Modbus ASCII** Die Übertragung findet textuell byteweise Datenpakete statt.   
* **Modbus RTU** Hier findet die Datenübertragung binär byteweise statt.  
* **Modbus TCP** Hier werden die Daten über ein TCP Pakete übertragen.  
  
## Modbus-Daten-Modell  
Das Modbus-Daten-Modell unterscheidet sich in vier Bereiche:    

Name | Funktion  
---- | --------   
Discrete Inputs |  ist ein einzelnes Bit, das nur gelesen werden kann  
Coils |  ist ein Bit, das gelesen und beschrieben werden kann; Coil bedeutet soviel wie Relais  
Input Registers |  ist ein 16 Bit Wert, der nur gelesen werden kann  
Hold Registers |  ist ein 16 Bit Wert, der gelesen und beschrieben werden kann    

## Exceptions  
Tritt beim Request ein Fehler auf, so wird in der darauffolgenden Response das Bit-7 gesetzt. Dies hat die Funktion, dass sich der Function Code ändert und im Daten-Bereich wird ein Exception-Code generiert. Mithilfe dieses Exception-Codes, kann man den vorliegenden Fehler kategorisieren.  
 ***********************************************************************************************************************************   
 # Java Programm  
 Zuerst luden wir uns das Java-Swing Programm mit der fertigen GUI vom SNV Server herunter. Danach haben wir den Bootloader auf den Shureboards installiert. Nach diesen Arbeiten hatten wir nur noch ein Problem zu lösen, die Kommunikation zwischen Sureboard und der Java-Swing Applikation. Um dies zu lösen benötogen wir die *Java Native Interface JNI*.  
 ## Java Native Interface  
 
Als Java Native Interface, bezeichnet man die Schnittstelle zwischen der *Java Virtual Machine* und dem *Betriebssytem* des jeweiligen Rechners. Dies hat besondere Bedeutung bei der Datenübermittlung über eine serielle Schnittstelle. Für das korrekte Arbeiten der Java Native Interface, benötigt sie einige Bibliotheken. Das Problem hierbei ist, dass mit einbinden von Bibliotheken die Multiplattformfähigkeit verloren geht.  
Weitere Infos zu JNI:  
[Wikipedia/JavaNativeInterface](https://de.wikipedia.org/wiki/Java_Native_Interface)  
[Openbook_Rheinland_Computing/JavaNativeInterface](http://openbook.rheinwerk-verlag.de/java7/1507_21_001.html)  

![Aufbau](/reibem14/Java_Aufbau.PNG)  


   
