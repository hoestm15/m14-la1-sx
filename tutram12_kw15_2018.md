# Protokoll KW 15
Name: Tuttner Raphael  
Klasse: 4AHME  
Datum: 10.04.2018  
Anwesend: Strauß Lukas, Tuttner Raphael, Uhl Christian, Waltl Kilian, Wieser Markus, Zitz Karlheinz  
Abwesend: Strutz Sebastian  

## Java Theorie
  
### Klassen in Java
Vereinfacht gesagt ist eine Klasse der "Bauplan" für ein Programm. Ein Klasse besteht aus Attributen und Methoden.
  
  * Interne Klassen:   In einer internen Klasse können alle Attribute von einer äußeren Klasse übernommen werden.
  * Interfaces:        Sind Sammlung von Methoden.
  * Abstrakte Klassen: Sind unfertige Klasse, die verwendet werdne um weitere Klassen dieser Art zu erstellen.
                       Hier müssen dann nur einige Funktionen implementiert werden.
  * Anonyme Klassen:   Haben keine eigenen Klassennamen und sind die einfachsten Klassen in Java.
  
### Vererbungen
Bei Java gibt es immer nur eine Einfachvererbung. Eine Elternklasse kann mehrere Kindklassen haben, aber eine Kindklasse kann nur eine Elternklasse haben. Interfaces haben allerdings die Fähigkeit mehrfach vererbt zu bekommen.  
   
### Serielle Schnittstelle in Java
Um unter Java zwischen Programm und Hardware zu kommunizieren, muss die **JVM (Java Virtuelle Maschine)** dazwischengeschalten werden. Hierbei greift Java auf die virtuelle Maschine zu, welche dann wiederum auf das Betriebssystem (OS) zugreift. Das OS greift anschließend auf die Hardware zu. Die JVM unterstützt jedoch nativ keine seriellen Schnittstellen. Deshalb benötigt man das **Java Native Interface (JNI)**, welches eine für Java lesbare **.jar-Datei** erzeugt und auch eine lesbare Bibliothek erzeugt. In der Schule haben wir auch den **Java Simple Serial Connector (JSSC)** verwendet. Ein großer Vorteil vom JJSC ist der, dass die Bibliotheken automatisch richtig entpackt und verwendet werden. Früher gab es auch noch die **Java.comm**. Diese könnte man zwar heute noch nutzen. Sie hat jedoch den großen Nachteil, dass man es nur auf einem System nutzen kann.
  
## Temperaturmessung mit I²C
  
### jbutSingleMeasurementActionPerformed
Hier wird von der Klasse MySingleMeasurementWorker ein Objekt erstellt. Dies wird mithilfe von **execute()** gemacht.
  
```java
private void jbutSingleMeasurementActionPerformed(java.awt.event.ActionEvent evt)                       
{                                                          
  new MySingleMeasurementWorker(serialPort).execute();
}                                                     
```

### MySingleMeasurementWorker
Hier sieht man wie die interne Klasse **MySingleMeasurementWorker** erstellt wird. Sie dient zur Übergabe der Attribut-Variable an die eigentliche Worker-Klasse.
  
```java
  {
    public MySingleMeasurementWorker (SerialPort serialPort)
    {
      super(serialPort);
    }
    @Override
    protected void done ()
    {
      try
      {
        double temp = get();
        jlaTemperatur.setText(String.format("%.1f °C", temp));
      }
      catch (Exception ex)
      {
         showException("Schnittstelle kann nicht geöffnet werden", ex);
      }
    }
  }
  ```
  
### Worker Klasse SingleMeasurementWorker
Die hier zu sehende Worker Klasse lässt die Abfrage der GUI in einem anderen **Threat** ablaufen.
Die Methode **doInBackground** schickt eine Anfrage an das SureBoard, wobei wir das nächste Mal jedoch ein Feld verwenden wollen.
  
```java
package workers;

import javax.swing.SwingWorker;
import jssc.SerialPort;


public class SingleMeasurementWorker extends SwingWorker<Double, Object>
{
  private final jssc.SerialPort serialPort;

  public SingleMeasurementWorker (SerialPort serialPort)
  {
    this.serialPort = serialPort;
  }

  @Override
  protected Double doInBackground () throws Exception
  {
    serialPort.writeInt(2); // Geraeteadresse
    serialPort.writeInt(4); // Funktioncode 0x04 = Read Input Register
    serialPort.writeInt(0); // LM75A Register
    serialPort.writeInt(0x30); // LM75A Register
    serialPort.writeInt(1); // Anzahl der Register
    serialPort.writeInt(0x31); // CRC Pruefsumme High-Byte
    serialPort.writeInt(0xf6); // CRC Pruefsumme Low-Byte
    // to do use Array to send data: serialPort.writeIntArray(buffer)
    
    return 23.5;
  }

}
```
