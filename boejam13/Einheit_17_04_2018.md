# Protokoll
  Böcksteiner Jakob  
  4AHME, Gruppe 1  
  17.04.18  
  Anwesend: Berger, Böcksteiner, Bullner, Ehman, Enzi, Kobor, Knappitsch
  Abwesend: niemand
  
  ## Projekt Temperaturmessung
  Es ist ein Programm zu vervollständigen um die Temperaturmessung möglich zu machen, die Vorlage war soweit vervollständigt das wir keine GUI mehr programmieren mussten und uns deshalb ein großer Zeitaufwand erspart wurde.
  
  ## Fortschritt
  In der letzten Einheit haben wir bereits mit dem Projekt angfangen, es wurden schon einige Funktionen Programmiert. Diese sind im letzten Protokoll erklärt. [Protokoll](https://github.com/HTLMechatronics/m14-la1-sx/blob/boejam13/boejam13/Einheit_30_01_2018.md)
  
  ## Vervollständigung der begonnenen Klassen
### updateSwingControlls
```java
private void updateSwingControls() {
        jbutRefresh.setEnabled(true);
        jbutConnect.setEnabled(false);
        jbutDisconnect.setEnabled(false);
        jcbSerialDevice.setEnabled(false);
        jbutSingleMeasurement.setEnabled(false);
        jbutContinousMeasurement.setEnabled(false);
        jbutStopMeasurement.setEnabled(false);

        if (serialPort != null && serialPort.isOpened()) {
            jbutRefresh.setEnabled(false);
            jbutDisconnect.setEnabled(true);
            jbutConnect.setEnabled(false);
            jbutSingleMeasurement.setEnabled(true);
            return;
        }

        if (jcbSerialDevice.getModel().getSize() > 0) {
            jcbSerialDevice.setEnabled(true);
            jbutConnect.setEnabled(true);
        }

        if (activeWorker != null) {
            jbutRefresh.setEnabled(false);
            jbutConnect.setEnabled(false);
            jbutDisconnect.setEnabled(false);
            jcbSerialDevice.setEnabled(false);
            jbutSingleMeasurement.setEnabled(false);
            jbutContinousMeasurement.setEnabled(false);
            jbutStopMeasurement.setEnabled(false);
            jlaTemperatur.setEnabled(false);
            setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
        } else {
            setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
            jlaTemperatur.setEnabled(true);
        }
    }
```
Wurde um eine if-Klausel erweitert, diese wird benötigt um die GUI zu deaktivieren wenn gerade eine Messung läuft. Außerdem erscheint ein sogennanter WAIT-Cursor.

### connectPort
 ```java
private void connectPort(String port) {
        serialPort = new jssc.SerialPort(port);
        try {
            if (serialPort.openPort() == false) {
                throw new jssc.SerialPortException(port, "openPort", "return value false");
            }
            if (serialPort.setParams(SerialPort.BAUDRATE_57600, SerialPort.DATABITS_8,
                    SerialPort.STOPBITS_2, SerialPort.PARITY_NONE) == false) {
                throw new jssc.SerialPortException(port, "setParams", "return value false");
            }
        } catch (Throwable ex)
        {
            showThrowable(new Exception("Serielle Schnittstelle kann nicht geöffnet werden", ex));
            serialPort = null;
        } finally {
            updateSwingControls();
        }
    }
```
Es wurde um alle Methoden eine if-Klausel gelegt um eine Exception zu werfen, falls ein Fehler auftritt.

#### Verwendete Parameter

| Parameter | Beschreibung |
| --------- | ------------ |
| BAUDRATE_57600 | Baudrate wird auf 57600 festgelegt (Bauds pro sekunde) |
| DATABITS_8 | Databit anzahl wird auf 8 bit festgelegt |
| STOPBITS_2 | Stopbit anzahl wird auf 2 bit gesetzt |
| PARITY_NONE | Es wird festgelegt ob ein EVEN, ODD oder kein Parity benötigt wird |

## Klassen
### SingleMeasurementWorker
```java
package workers;

import java.util.concurrent.TimeUnit;
import javax.swing.SwingWorker;
import jssc.SerialPort;

public class SingleMeasurementWorker extends SwingWorker<Double, String> {
    
    private final SerialPort serialPort;

    public SingleMeasurementWorker(SerialPort serialPort) {
        this.serialPort = serialPort;
    }
       
    @Override
    protected Double doInBackground() throws Exception {
        
        publish("Einzelmessung gestartet");
        
        byte [] frame = {0x02, 0x04, 0x00, 0x30, 0x00, 0x01, 0x31, (0xf6-256)};
        
        if (serialPort.writeBytes(frame) == false) {
            throw new Exception("cant send frame");
        }
                
        TimeUnit.SECONDS.sleep(2);
        byte [] response = serialPort.readBytes();
        System.out.println(response.length);
        byte hb = response[3];
        byte lb = response[4];
        int t = (hb < 0 ? hb+256 : hb) * 256 + (lb < 0 ? lb+256 : lb);
        
        return t/256.0;
    } 
}
```
Hier wird der Wert der 256 überschreiten kann in zwei verschiedene unterteilt, dem *lowbyte* und dem *highbyte*.

### MySingleMeasurementWorker
```java
private class MySingleMeasurementWorker extends SingleMeasurementWorker {

        public MySingleMeasurementWorker(SerialPort serialPort) {
            super(serialPort);
        }

        @Override
        protected void done() {
            try {
                double temp = get();
                jlaTemperatur.setText(String.format("%.1f °C", temp));
                jtfStatus.setText(null);
            } catch (Exception e) {
                showThrowable(new Exception("Einzemessung gescheitert", e));
            } finally {
                activeWorker = null;
                updateSwingControls();
            }
        }

        @Override
        protected void process(List<String> chunks) {
            jtfStatus.setText(chunks.get(chunks.size()-1)); //String aus Publish
        }
        
    }
```
Werte werden über *get* gelesen und ausgegeben. Mit *activeWorker* wird die Methode *updateSwingcontrolls* upgedated.

### singleMeasurement

```java
private void singleMeasurement() 
{
        activeWorker = new MySingleMeasurementWorker(serialPort);
        activeWorker.execute();
        updateSwingControls();
}
```
Diese Methode ist dazu da um de SwingWorker zu starten.

Swingworker ist in der Lage eine Arbeitsintensive aufgabe in einen anderen Thread zu verlagern, dadurch wird es möglich andere funktionen des Programms weiterzuverwenden.Das nennt man reales Multitasking.
Neu verwendete Methoden:

* doInBackground(): Versucht ein ergebnis zu berechnen, ansonsten wird eine Exception geworfen.

* done(): Wird ausgeführt wenn doInBackground beendet ist.

* execute(): Startet den Thread

* get(): liest den Rückgabewert von *doInBackground*

* publish(): Sendet Zwischenergebnisse an den Haupt-Thread.
