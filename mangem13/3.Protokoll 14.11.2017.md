# 3. Protokoll - 14.11.2017

Schriftführer: Gerhard Mandl  
Betreuer: Sx  
Klasse: 4AHME  
Gruppe: 2  

Anwesend: Nebel Florian, Mandl Gerhard, Michael Mörth, Moritz Martinak, Mario Nabernik, Muri Lorenz, Platzer Andreas, Marcel Köhler    
Abwesend: -

## Besprechung der letzten Protokolle
Am Anfang gingen wir unsere Protokolle von der letzten Einheit durch. Nachdem Herr Steiner diese beurteilt hatte, gingen wir noch einmal den Stoff von der letzten Einheit durch.  
[Protokoll der 2 Einheit](https://github.com/HTLMechatronics/m14-la1-sx/blob/mangem13/mangem13/2.Protokoll%20%207.11.2017.md)

## Abarbeitung von Programmen 
Zuerst erstellten wir ein Programm, welches wir dan genauer unter die Lupe nahmen, in unserem Beispiel sieht der Quelltext vollgender Maßen aus:  

```c
int main (void)
{
	volatile unsigned char x;
	x = 12;
	
	return x;
}
```
Nachdem wir das Programm geschrieben haben, mussten wir den Debugging- Modus starten um jeden einzelnen Schritt des Programmes beobachten zu können. Dies ist nötog um die Maschinenbefehle, welche ausgeführt werden analyisieren zu können und diese im Datenblatt des Atmegas 328p nachzuschlagen.  

__unsigned char__  = Das unsigned (vorzeichenlos) ermöglicht uns Werte von 0 - 255 zu speichern.  
   
#### Das Schlüsserlwort volatile 
*In C und C++ wird durch diesen Typqualifikator spezifiziert, dass sich der Wert der Variable jederzeit ändern kann, beispielsweise durch andere Prozesse, Threads oder sogar externe Hardware.[1] Bei der Generierung des Maschinen-Codes aus einem in C oder C++ geschriebenen Programm verhindert die Kennzeichnung einer Variablen als volatile eine in diesem Fall die Funktionalität beeinträchtigende Optimierung, so dass das Programm immer auf den tatsächlich in der Hardware vorhandenen Wert zugreift.*  

Quelle:[Wikipedia](https://de.wikipedia.org/wiki/Volatile_(Informatik))    


Maschinenbefehl | Beschreibung
--------------- | ------------
cf.93 | PUSH R28 - Legt den Wert des Register R28 auf den Stack.  
df.93 | PUSH R29 - Legt den Wert des Register R29 auf den Stack.  
1f.92 | PUSH R1 - Legt den Wert des Register R1 auf den Stack.  
cd.b7 | IN R28,0x3D - Läd den Wert 0x3D von den I/O Registern in das Register R28  
de.b7 | IN R29,0x3E - Läd den Wert 0x3E von den I/O Registern in das Register R29  
8c.e0 | LDI R24,0x0C - Legt den Wert 0x0C in das Register R24 
89.83 | STD Y+1,R24 - Konstante aus dem REgister R24 wird am Speicherplatz des Stacks der lokalen Variable abgelegt. Y+1 gibt den nächsten freien Speicherplatz des Y-Registers an.  
89.81 | LDD R24,Y+1 - Die Variable wird in Register R24 geladen.
90.e0 | LDI R25,0x00 - Ins Register R25 wird der Rückgabewert geladen.
0f.90 | POP R0 - Variable wird freigegeben.
df.91 | POP R29 - Das Register R29 wird vom Stack entfernt.
cf.91 | POP R28 - Das Register R28 wird vom Stack entfernt.


### Addieren von zwei Variablen
In diesem Beispiel sollen wir die Maschinenbefehle analysieren, welche verwendet werden um zwei Zahlen miteinander zu addieren.  
Der Quellcode sieht folgendermaßen aus:  
```c
int main (void)
{
	volatile unsigned char a = 12;
	volatile unsigned char b = 8;
	
	return a+b;
}
```
In diesem Beispiel müssen wir das selbe machen wie beim Vorigen. Wir starten den Debugg - Modus und suchen die genaue Definition der Maschinenbefehle mit dem Datasheet des Atmegas 328p 

Auf Folgende Erkenntnise sind wir gestoßen:  

Maschinenbefehl | Beschreibung
--------------- | ----------- 
cf.93 | PUSH R28 - Legt den Wert des Registers R28 auf den Stack
df.93 | PUSH R29 - Legt den Wert des Registers R29 auf den Stack
00.d0 | RCALL PC+0x0001 - Sprung zum nächsten Befehl und speichern von 2 Bytes auf den Stack
cd.b7 | IN R28,0x3D - Läd den Wert 0x3D in das Register R28
de.b7 | IN R29,0x3E - Läd den Wert 0x3E in das Register R29
8c.c0 | LDI R24,0x0C - legt den Wert 0x0C in das Register R24
89.83 | STD Y+1,R24 - Wert aus dem Register R24 wird am Stack abgelegt
88.e0 | LDI R24,0x08 - Legt den Wert 8 in das Register R24
89.83 | STD Y+2,R24 - Wert aus dem Register R24 wird am Stack abgelegt  
89.81 | LDD R24,Y+1 - Ladet den Wert a in das Register R24
2a.81 | LDD R18,Y+2 - Ladet den Wert b in das Register R18
30.e0 | LDI R19, 0x00 - Ladet den Wert 0x00 in das R19
28.0f | ADD R18,R24 - Addition der beiden Register. R18 ist der Speicherort.
31.1d | ADC R19,R1 - Addition mit Berücksichtigung des Carry-Flags. 
0f.90 | POP R0 - A wird freigegeben
0f.90 | POP R0 - B wird freigegeben
df.91 | POP R29 - Das Regiser R29 wird vom Stack entfernt
cf.91 | POP R28 - Das Register R28 wird vom Stack entfernt

### Taktzeit von verschiedenen Operationen  

In dieser Übung müssen wir herausfinden wie lange eine bestimmte Operation braucht.  
Dies machen wir mit folgendem Quellcode:  
```c
int main (void)
{
	volatile unsigned double a = 192.23;
	volatile unsigned double b = 172.231;
	
	return a*b;
}
```
##### Operation  
__Addition:__  
8 Bit - 2,89 us- 46 Takte  
32 Bit - 12,09 us - 192 Takte  
float - 57,01 us - 905 Takte  

__Multiplikation:__  
8 Bit - 2,96 us - 47 Takte  
32 Bit - 10,39 - 165 Takte  
float - 111,06 - 1763 Takte  

__Division:__  
8 Bit -7,77 us - 123 Takte  
32 Bit - 44,16 us - 701 Takte  
float - 86,94 us - 1380 Takte  
double - 86,94 us - 1380 Takte


### Bemerkungen
Nach dieser Übung sind wir draufgekommen das wir immer mit den kleinsten Datentypen arbeiten solle wen wir die Echtzeit nicht verlieren wollen. Da es sonst zu Verzögerungen kommen kann und die Echzeit nicht mehr eingehalten wird.
