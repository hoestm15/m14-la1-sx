# 3. Protokoll - 14.11.2017

Schriftführer: Gerhard Mandl  
Betreuer: Sx  
Klasse: 4AHME  
Gruppe: 2  

Anwesend: Nebel Florian, Mandl Gerhard, Michael Mörth, Moritz Martinak, Mario Nabernik, Muri Lorenz, Platzer Andreas, Marcel Köhler    
Abwesend: -

## Besprechung der letzten Protokolle
Am Anfang gingen wir unsere Protokolle von der letzten Einheit durch. Nachdem Herr Steiner diese beurteilt hatte, gingen wir noch einmal den Stoff von der letzten Einheit durch.  
[Protokoll der 2 Einheit](https://github.com/HTLMechatronics/m14-la1-sx/blob/mangem13/mangem13/2.Protokoll%20%207.11.2017.md)

## Abarbeitung von Programmen 
Zuerst erstellten wir ein Programm, welches wir dan genauer unter die Lupe nahmen, in unserem Beispiel sieht der Quelltext vollgender Maßen aus:  

```c
int main (void)
{
	volatile unsigned char x;
	x = 12;
	
	return x;
}
```
Nachdem wir das Programm geschrieben haben, mussten wir den Debugging- Modus starten um jeden einzelnen Schritt des Programmes beobachten zu können. Dies ist nötog um die Maschinenbefehle, welche ausgeführt werden analyisieren zu können und diese im Datenblatt des Atmegas 328p nachzuschlagen.  

__unsigned char__  = Das unsigned (vorzeichenlos) ermöglicht uns Werte von 0 - 255 zu speichern.  
   
#### Das Schlüsserlwort volatile 
*In C und C++ wird durch diesen Typqualifikator spezifiziert, dass sich der Wert der Variable jederzeit ändern kann, beispielsweise durch andere Prozesse, Threads oder sogar externe Hardware.[1] Bei der Generierung des Maschinen-Codes aus einem in C oder C++ geschriebenen Programm verhindert die Kennzeichnung einer Variablen als volatile eine in diesem Fall die Funktionalität beeinträchtigende Optimierung, so dass das Programm immer auf den tatsächlich in der Hardware vorhandenen Wert zugreift.*  

Quelle:[Wikipedia](https://de.wikipedia.org/wiki/Volatile_(Informatik))  


