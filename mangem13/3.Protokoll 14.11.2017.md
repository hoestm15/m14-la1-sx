# 3. Protokoll - 14.11.2017

Schriftführer: Gerhard Mandl  
Betreuer: Sx  
Klasse: 4AHME  
Gruppe: 2  

Anwesend: Nebel Florian, Mandl Gerhard, Michael Mörth, Moritz Martinak, Mario Nabernik, Muri Lorenz, Platzer Andreas, Marcel Köhler    
Abwesend: -

## Besprechung der letzten Protokolle
Am Anfang gingen wir unsere Protokolle von der letzten Einheit durch. Nachdem Herr Steiner diese beurteilt hatte, gingen wir noch einmal den Stoff von der letzten Einheit durch.  
[Protokoll der 2 Einheit](https://github.com/HTLMechatronics/m14-la1-sx/blob/mangem13/mangem13/2.Protokoll%20%207.11.2017.md)

## Abarbeitung von Programmen 
Zuerst erstellten wir ein Programm, welches wir dan genauer unter die Lupe nahmen, in unserem Beispiel sieht der Quelltext vollgender Maßen aus:  

```c
int main (void)
{
	volatile unsigned char x;
	x = 12;
	
	return x;
}
```
Nachdem wir das Programm geschrieben haben, mussten wir den Debugging- Modus starten um jeden einzelnen Schritt des Programmes beobachten zu können. Dies ist nötog um die Maschinenbefehle, welche ausgeführt werden analyisieren zu können und diese im Datenblatt des Atmegas 328p nachzuschlagen.  

__unsigned char__  = Das unsigned (vorzeichenlos) ermöglicht uns Werte von 0 - 255 zu speichern.  
   
#### Das Schlüsserlwort volatile 
*In C und C++ wird durch diesen Typqualifikator spezifiziert, dass sich der Wert der Variable jederzeit ändern kann, beispielsweise durch andere Prozesse, Threads oder sogar externe Hardware.[1] Bei der Generierung des Maschinen-Codes aus einem in C oder C++ geschriebenen Programm verhindert die Kennzeichnung einer Variablen als volatile eine in diesem Fall die Funktionalität beeinträchtigende Optimierung, so dass das Programm immer auf den tatsächlich in der Hardware vorhandenen Wert zugreift.*  

Quelle:[Wikipedia](https://de.wikipedia.org/wiki/Volatile_(Informatik))    


Maschinenbefehl | Beschreibung
--------------- | ------------
cf.93 | PUSH R28 - Legt den Wert des Register R28 auf den Stack.  
df.93 | PUSH R29 - Legt den Wert des Register R29 auf den Stack.  
1f.92 | PUSH R1 - Legt den Wert des Register R1 auf den Stack.  
cd.b7 | IN R28,0x3D - Läd den Wert 0x3D von den I/O Registern in das Register R28  
de.b7 | IN R29,0x3E - Läd den Wert 0x3E von den I/O Registern in das Register R29  
8c.e0 | LDI R24,0x0C - Legt den Wert 0x0C in das Register R24 
89.83 | STD Y+1,R24 - Konstante aus dem REgister R24 wird am Speicherplatz des Stacks der lokalen Variable abgelegt. Y+1 gibt den nächsten freien Speicherplatz des Y-Registers an.  
89.81 | LDD R24,Y+1 - Die Variable wird in Register R24 geladen.
90.e0 | LDI R25,0x00 - Ins Register R25 wird der Rückgabewert geladen.
0f.90 | POP R0 - Variable wird freigegeben.
df.91 | POP R29 - Das Register R29 wird vom Stack entfernt.
cf.91 | POP R28 - Das Register R28 wird vom Stack entfernt.


### Addieren von zwei Variablen
In diesem Beispiel sollen wir die Maschinenbefehle analysieren, welche verwendet werden um zwei Zahlen miteinander zu addieren.  
Der Quellcode sieht folgendermaßen aus:  
```c
int main (void)
{
	volatile unsigned char a = 12;
	volatile unsigned char b = 8;
	
	return a+b;
}
```
In diesem Beispiel müssen wir das selbe machen wie beim Vorigen. Wir starten den Debugg - Modus und suchen die genaue Definition der Maschinenbefehle mit dem Datasheet des Atmegas 328p 

Auf Folgende Erkenntnise sind wir gestoßen  
Maschinenbefehl | in Textform | Beschreibung
--------------- | --------- | ---------
cf.93 | PUSH R28 | Der Wert des Registers R28 wird auf den Stack gelegt.
df.93 | PUSH R29 | Der Wert des Registers R29 wird auf den Stack gelegt.
1f.92 | PUSH R1 | Der Wert des Registers R1 (*immer 0*) wird auf den Stack gelegt. 
cd.b7 | IN R28,0x3D | Der Wert 0x3D wird aus dem I/O-Register in das Register R28 geladen.
de.b7 | IN R29,0x3E | Der Wert 0x3E wird aus dem I/O-Register in das Register R29 geladen.
8c.e0 | LDI R24,0x0C | Die Konstante 0C (0C =^ dezimal 12) wird im Register R24 abgelegt.
89.83 | STD Y+1,R24 | Konstante aus dem REgister R24 wird am Speicherplatz des Stacks der lokalen Variable abgelegt. Die Angabe Y+1 entspricht dem nächsten freien Speicherplatz im Y-Register ([siehe Y-Register](https://github.com/HTLMechatronics/m14-la1-sx/blob/moemim14/moemim14/Protokoll_7.11.2017.md#xyz-register))
89.81 | LDD R24,Y+1 | Die Variable wird in Register R24 geladen.
90.e0 | LDI R25,0x00 | Ins Register R25 wird der Rückgabewert geladen.
0f.90 | POP R0 | Variable wird freigegeben.
df.91 | POP R29 | Das Register R29 wird vom Stack entfernt.
cf.91 | POP R28 | Das Register R28 wird vom Stack entfernt.

