# 4.Protokoll - 06.02.2018
Schriftführer: Gerhard Mandl  
Betreuer: Sx  
Klasse: 4AHME  
Gruppe: 2  
Anwesend: Nebel Florian, Mandl Gerhard, Michael Mörth, Moritz Martinak, Mario Nabernik, Muri Lorenz, Platzer Andreas, Marcel Köhler  
Abwesend: -  

## Besprechung der letzten Protokolle
Am Anfang der Einheit sind wir die Protokolle vom der letztn Einheit des ersten Turnus durchgegangen. Es ist zur Erkenntnis gekommen das niemand mehr wirklich wusste was bei der letzten Einheit gemacht wurde. Da die Protokolle erst einen Tag vor der Kontrolle gemacht wurden, dies führte dann zu relativ schlechten Noten.  

## Kompilier Prozess
Am Anfang der Einheit wiederholten wir noch einmal wie ein Kompilier Prozess abläuft und wozu dieser dient.  
Der Kompilier Prozess übersetzt Quelltext in Maschinenbefehle die von einer CPU ausgeführt werden können.  

### Kompilier Prozess Theorie
Quelltext, egal welcher Sprache, kann nicht direk von der CPU verstanden und ausgeführt werden. Daher muss dieser in Maschinenbefehle übersetzt werden. Die Übersetzun des Programmes erfolgt in mehreren Schritten, im Falle der Programmiersprache C sind die Schritte wie folgt:  
  1. __C-Quelltext__: Der ertse Schritt eines jeden Programmes ist das Schreiben des Quelltextes. Bei C MUSS es in jedem Projekt EINE     main.c geben. Die main.c ist quasi das Herz eines C Projekts, alle anderen Funktionen und Dateien werden dort aufgerufen.  
  2. __Preprozessor__: C Programme verfügen über Preprozessoranweisungen, die mit dem Zeichen # eingeleitet werden. Die Eigenschaften     von Preprozessoranweisungen ist, dass diese als erstes ausgeführt werden. Sie werden für Vorabdefinitionen verwendet. Ein Beispiel ist   das Bekanntgeben von Bibliotheken die später eingebunden werden.  
  Beispiele: incldue, define, ifndef  
  3. __Compiler__: Den ganzen Übersetzungsvorgang als Kompilieren zu bezeichnen ist genau genommen falsch, den das eigentliche             Kompilieren findet hier im Compiler statt. Es ist das Übersetzen von C-Quelltext in Assemblerbefehle. Diese Befehle werden in eine       Textdatei, der sogenannten Assemblerdatei, geschrieben und werden 1:1 von der CPU verstanden. Die Assemblerdatei erhält die             Dateiendung .s, die main.c wird in diesem Schritt also zur main.s.  
  4. __Assembler__: Der Assembler macht aus der Assemblerdatei eine Objektdatei mit der Endung .o. Die Objektdatei enthält die             Assemblerbefehle in binärer Form (= binäre Befehle). Aus unserer main.c entsteht in diesem Schritt eine weitere Datei mit dem Namen     main.o.  
  5. __Linker__: In der Objektdatei fehlen noch einige wichtige Adresswerte, darum kommt der Linker ins Spiel. Er führt die main.o mit     den durch Preprozessoranweisungen bekanntgegebenen Bibliotheken zusammen. Im letzten Schritt des Kompilierprozesses wir nun aus der     main.o und beliebig vielen .lib Dateien die main.elf.  

Die main.elf kann von der CPU nun ausgeführt werden, es ist also ein ausführbares Programm entstanden. Die Sammlung aus den 4 "Tools" (Preprozessor, Compiler, Assemblerm Linker) ist die sogenannte Compiler-Suite.  
Es gibt mehrere solcher Compiler-Suiten, beispielsweise die GCC(GNU Compiler Collection), die wir im Unterricht verwenden. (eine andere wäre z.B. die MinGW Compiler-Suite). Das im Namen steckende GNU ist ein Zeichen für die GPL(GNU-Public License), es stehen also keine komerziellen Ziele hinter der Suite.  

## AVR GCC
Soll nun ein Programm für einen µC der Atmega Reihe geschrieben werden, muss das Programm mithilfe einer anderen Compiler Suite übersetzt werden. Dafür verwenden wir den AVR-GCC Kompiler.  
Die Befehle für die einzelnen Schritte sind im Prinzip die Selben. Statt _gcc_ starten die Befehle nun mit avr-gcc. Außerdem muss der Kompiler wissen, um welchen Atmega Prozessor es sich handelt und welche Taktfrequenc dieser hat.  
Der __Prozessortyp__ wird mit dem Attribut _-mmcu=type_ festgelegt, die __Taktfrequenz__ mit dem Attribut _-DF_CPU=frequencyL_ (L für Datentyp long). Außerdem kann man mit dem Attribut _-Os_ dafpr sorgen dass der __Speicherplatz__ optimal genutzt wird.  

Daten für die Atmega Prozessoren, die für unseren Laborunterricht relevant sind:  

Board | Sure Electronics DEM1 | Arduino NANO
----- | --------------------- | ------------

Der schrittweise Kompiliervorgang bis zur main.elf, mithilfe der Shell, sieht dann wie folgt aus (verwendet wird der Arduino Nano):  
  1. __Preprozessor__: avr-gcc -Os -mmcu=atmega328p -DF_CPU=16000000L -E main.c  
  2. __Compiler__: avr-gcc -Os -mmcu=atmega328p -DF_CPU=16000000 -S main.c  
  3. __Assembler__: avr-gcc -Os -mmcu=atmega328p -DF_CPU=16000000 -c main.s  
  4. __Linker__: avr-gcc -Os -mmcu=atmega328p -DF_CPU=16000000 -o main.elf main.o
  
Die ersten 3 Schritte können natürlich auch gesammelt in einem Schritt erledigt werden. Die Objektdatei main.o wird dann direkt aus der main.c erzeugt. Die Assemblerdatei main.s ist dann ein Zwischenschritt und muss nicht extra erstellt werden: 
  1. __Preprozessor, Compiler & Assembler__: avr-gcc -Os -mmcu=atmega328p -DF_CPU=16000000 -c main.c  
  2. __Linker:__ avr-gcc -Os -mmcu=atmega328p -DF_CPU=16000000L -o main.elf main.o  

Der Atemga µC kann allerdings nichts mit der main.elf anfange, daher müssen wir zuerst eine main.hex, die vom µC verstanden wird, daraus erzeugen. Das bewerkstelligen wir mithilfe des __avr-objcopy__ Befehls.  
Der Befehl lautet dann wie folgt: __avr-objcopy -O ihex main.elf main.hex__.  
Aus der main.elf wird der Hexcode erzeugt und in die Datei main.hex, mit dem Format bfdname(durch das Attribut -O), gespeichert.  
Die main.hex führen wir nun durch den Easy Programmer auf dem Arduino aus. 

## Makefiles
Ebenso haben wir besprochen wie wir Makefiles erstellen und über die Konsole verwenden können.

### Was sind Makefiles
Der Mensch ist faul und das händische Kompilieren von Programmen ist zeitaufwendig und daher Arbeit. Darum gibt es Makesfiles, um diese Arbeit zu erleichtern. Statt langen Befehlen, die außerdem fehleranfällig sind, müssen nur noch kurze einfache Befehle eingegeben werden, um das Gewollte umzusetzen. Natürlich können Makefiles auch für andere Sachen als das Kompilieren eingesetzt werden, wir verwenden sie jedoch zu diesem Zweck.  
Im Klaltext: Ein Makefile ist ganz einfach eine Textdatei mit dem Name "Makefile". In ihr ist geschrieben, was beim Aufruf des Befehls _make_, oder vom im Makefile definierten Befehlen (z.B. _clean_ in unserem Beispiel), getan werden soll.

### Erstellung und Verwendung
Mit der Shell navigieren wir in den Ordnerm in dem das Makefile erstellt werden soll und erstellen dann eine Texdatei mit dem Befehl _nano_. Nun schreiben wir die gewünschten Befehle mit folgender Form in die Textdatei:  
```
Ziel 1: Voraussetzung 1, Voraussetzung 2,... 
--> Kommando 1  
--> ...  
--> Kommando n  

Ziel 2: Voraussetzung 1, Voraussetzung 2,... 
--> Kommando 1  
--> ...  
--> Kommando n  
```
Makefiles versuchen so effizient wie möglich zu arbeiten, deshalb verwenden sie Zeitstempel und aktuallisieren die Datei nur wenn Veränderungen auftreten, dadurch entsteht ein neuer __Zeitstempel__. Das heißt: Ist der Zeitstempel gleich wie der Zeitstempel der Datei die in unserem Fall kompiliert werden soll, wird diese nicht mehr kompiliert. Sonst schon.

### Aufgabenstellung
Unsere Aufgabe war es folgenden Quelltext für unseren Atmega328p lauffähig zu machen:
```c
#include <avr/io.h>
#include <util/delay.h>

int main()
{
        DDRB = (1<<PB5);
        while(1)
        {
                PORTB=(1<<PB5);
                _delay_ms(500);
                PORTB = 0;
                _delay_ms(500);
        }
        return 0;
}
```
Um diesen Quelltext für unseren Atmega328p lauffähig zu machen müssen wir diese Kompilieren, dazu verwenden wir eine MakeFile, der Quelltext für die MakeFile sieht folgender maßen aus:  
```
main.hex: main.elf
        avr-objcopy -O ihex main.elf main.hex

main.elf: main.o
        avr-gcc -o main.elf main.o

main.o: main.c
        avr-gcc -mmcu="atmega328p" -Os -c -DF_CPU=16000000L main.c

clean:
        -rm main.o
        -rm main.elf
        -rm main.hex
```
Für genauere Infos der Kommandos siehe __AVR GCC__
Der Aufruf __clean:__ entfernt alle Dateien die aufgelistet sind. Dies wird mit dem Kommando rm gemacht. 
Wenn eine Datei die Entfernt werden soll nicht exestiert, wird eine Fehlermeldung geworfen und die anderen Dateien werden dadurch ebenso nicht entfernt. Das wollen wir natürlich nicht, der Zusatz __-__ sorgt dafür das die anderen Dateien trotzdem entfernt werden sollen auch wenn eine Datei nicht vorhanden ist.

### Erweiterung der Aufgabenstellung
Nachdem wir die Kompilierung erfolgreich durchgeführt haben, sollen wir nun ebenso unseren Bootloader mit dem Flash initialisieren.  

#### Initialisieren des Flash 
Um den Befehl für das Initialisieren des Flash unseren Atmega328p zu finden verwenden wir den Befehl __which__. Which liefert den Dateipfad der Datei (*/usr/bin/flashbootloader*).  
Mit dem Befehl less haben wir uns den Quellcode der Datei ausgegeben und unseren gesuchten Befehl rausgesucht.  

MakeFile:
```
main.hex: main.elf
        avr-objcopy -O ihex main.elf main.hex

main.elf: main.o
        avr-gcc -o main.elf main.o

main.o: main.c
        avr-gcc -mmcu="atmega328p" -Os -c -DF_CPU=16000000L main.c

flash: main.hex
        avrdude -c usbasp -p atmega328p -e -U flash:w:bootloader.hex:i
        touch flash
```
__touch__ aktualisiert den Zeitstempel. Dies wird dafür benötigt damit der Flash nur initalisiert wird, wenn eine Änderung aufgetreten ist.  

#### Programm und bootloader zusammen intialisieren
Dafür müssen wir mit dem Befehl __cat__ die Programme main.hex und bootloader in eine Datei zusammenfassen.  Dafür mussten wir aber zuerst mit dem Befehl which unseren bootloader ausfinding machen und diesen dann mit dem Befehl __cp /usr/share/htl-aiit-tools/boards/arduinoNanoV3/bootloader.hex ./__ in unser Arbeitsverzeichnis kopieren.
In der zusammengeführeten Datei mussten wir anschließend die letzte Zeile des ersten Programmes löschen. Die Zeile musste gelöscht werden, da das Programm sonst an dieser Stelle beendet worden wäre.
