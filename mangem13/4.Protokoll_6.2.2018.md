# 4.Protokoll - 06.02.2018
Schriftführer: Gerhard Mandl
Betreuer: Sx
Klasse: 4AHME
Gruppe: 2
Anwesend: Nebel Florian, Mandl Gerhard, Michael Mörth, Moritz Martinak, Mario Nabernik, Muri Lorenz, Platzer Andreas, Marcel Köhler
Abwesend: -

### Besprechung der letzten Protokolle
Am Anfang der Einheit sind wir die Protokolle vom der letztn Einheit des ersten Turnus durchgegangen. Es ist zur Erkenntnis gekommen das niemand mehr wirklich wusste was bei der letzten Einheit gemacht wurde. Da die Protokolle erst einen Tag vor der Kontrolle gemacht wurden, dies führte dann zu relativ schlechten Noten.  

### Kompilier Prozess
Am Anfang der Einheit wiederholten wir noch einmal wie ein Kompilier Prozess abläuft und wozu dieser dient.  
Der Kompilier Prozess übersetzt Quelltext in Maschinenbefehle die von einer CPU ausgeführt werden können.  

#### Kompilier Prozess Theorie
Quelltext, egal welcher Sprache, kann nicht direk von der CPU verstanden und ausgeführt werden. Daher muss dieser in Maschinenbefehle übersetzt werden. Die Übersetzun des Programmes erfolgt in mehreren Schritten, im Falle der Programmiersprache C sind die Schritte wie folgt:  
  1. __C-Quelltext__: Der ertse Schritt eines jeden Programmes ist das Schreiben des Quelltextes. Bei C MUSS es in jedem Projekt EINE     main.c geben. Die main.c ist quasi das Herz eines C Projekts, alle anderen Funktionen und Dateien werden dort aufgerufen.  
  2. __Preprozessor__: C Programme verfügen über Preprozessoranweisungen, die mit dem Zeichen # eingeleitet werden. Die Eigenschaften     von Preprozessoranweisungen ist, dass diese als erstes ausgeführt werden. Sie werden für Vorabdefinitionen verwendet. Ein Beispiel ist   das Bekanntgeben von Bibliotheken die später eingebunden werden.  
  Beispiele: incldue, define, ifndef  
  3. __Compiler__: Den ganzen Übersetzungsvorgang als Kompilieren zu bezeichnen ist genau genommen falsch, den das eigentliche             Kompilieren findet hier im Compiler statt. Es ist das Übersetzen von C-Quelltext in Assemblerbefehle. Diese Befehle werden in eine       Textdatei, der sogenannten Assemblerdatei, geschrieben und werden 1:1 von der CPU verstanden. Die Assemblerdatei erhält die             Dateiendung .s, die main.c wird in diesem Schritt also zur main.s.  
  4. __Assembler__: Der Assembler macht aus der Assemblerdatei eine Objektdatei mit der Endung .o. Die Objektdatei enthält die             Assemblerbefehle in binärer Form (= binäre Befehle). Aus unserer main.c entsteht in diesem Schritt eine weitere Datei mit dem Namen     main.o.  
  5. __Linker__: In der Objektdatei fehlen noch einige wichtige Adresswerte, darum kommt der Linker ins Spiel. Er führt die main.o mit     den durch Preprozessoranweisungen bekanntgegebenen Bibliotheken zusammen. Im letzten Schritt des Kompilierprozesses wir nun aus der     main.o und beliebig vielen .lib Dateien die main.elf.  


