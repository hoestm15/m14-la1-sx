# 4.Protokoll - 06.02.2018
Schriftführer: Gerhard Mandl  
Betreuer: Sx  
Klasse: 4AHME  
Gruppe: 2  
Anwesend: Nebel Florian, Mandl Gerhard, Michael Mörth, Moritz Martinak, Mario Nabernik, Muri Lorenz, Platzer Andreas, Marcel Köhler  
Abwesend: -  

## Besprechung der letzten Protokolle
Am Anfang der Einheit sind wir die Protokolle vom der letztn Einheit des ersten Turnus durchgegangen. Es ist zur Erkenntnis gekommen das niemand mehr wirklich wusste was bei der letzten Einheit gemacht wurde. Da die Protokolle erst einen Tag vor der Kontrolle gemacht wurden, dies führte dann zu relativ schlechten Noten.  

## Kompilier Prozess
Am Anfang der Einheit wiederholten wir noch einmal wie ein Kompilier Prozess abläuft und wozu dieser dient.  
Der Kompilier Prozess übersetzt Quelltext in Maschinenbefehle die von einer CPU ausgeführt werden können.  

### Kompilier Prozess Theorie
Quelltext, egal welcher Sprache, kann nicht direk von der CPU verstanden und ausgeführt werden. Daher muss dieser in Maschinenbefehle übersetzt werden. Die Übersetzun des Programmes erfolgt in mehreren Schritten, im Falle der Programmiersprache C sind die Schritte wie folgt:  
  1. __C-Quelltext__: Der ertse Schritt eines jeden Programmes ist das Schreiben des Quelltextes. Bei C MUSS es in jedem Projekt EINE     main.c geben. Die main.c ist quasi das Herz eines C Projekts, alle anderen Funktionen und Dateien werden dort aufgerufen.  
  2. __Preprozessor__: C Programme verfügen über Preprozessoranweisungen, die mit dem Zeichen # eingeleitet werden. Die Eigenschaften     von Preprozessoranweisungen ist, dass diese als erstes ausgeführt werden. Sie werden für Vorabdefinitionen verwendet. Ein Beispiel ist   das Bekanntgeben von Bibliotheken die später eingebunden werden.  
  Beispiele: incldue, define, ifndef  
  3. __Compiler__: Den ganzen Übersetzungsvorgang als Kompilieren zu bezeichnen ist genau genommen falsch, den das eigentliche             Kompilieren findet hier im Compiler statt. Es ist das Übersetzen von C-Quelltext in Assemblerbefehle. Diese Befehle werden in eine       Textdatei, der sogenannten Assemblerdatei, geschrieben und werden 1:1 von der CPU verstanden. Die Assemblerdatei erhält die             Dateiendung .s, die main.c wird in diesem Schritt also zur main.s.  
  4. __Assembler__: Der Assembler macht aus der Assemblerdatei eine Objektdatei mit der Endung .o. Die Objektdatei enthält die             Assemblerbefehle in binärer Form (= binäre Befehle). Aus unserer main.c entsteht in diesem Schritt eine weitere Datei mit dem Namen     main.o.  
  5. __Linker__: In der Objektdatei fehlen noch einige wichtige Adresswerte, darum kommt der Linker ins Spiel. Er führt die main.o mit     den durch Preprozessoranweisungen bekanntgegebenen Bibliotheken zusammen. Im letzten Schritt des Kompilierprozesses wir nun aus der     main.o und beliebig vielen .lib Dateien die main.elf.  

Die main.elf kann von der CPU nun ausgeführt werden, es ist also ein ausführbares Programm entstanden. Die Sammlung aus den 4 "Tools" (Preprozessor, Compiler, Assemblerm Linker) ist die sogenannte Compiler-Suite.  
Es gibt mehrere solcher Compiler-Suiten, beispielsweise die GCC(GNU Compiler Collection), die wir im Unterricht verwenden. (eine andere wäre z.B. die MinGW Compiler-Suite). Das im Namen steckende GNU ist ein Zeichen für die GPL(GNU-Public License), es stehen also keine komerziellen Ziele hinter der Suite.  

### AVR GCC
Soll nun ein Programm für einen µC der Atmega Reihe geschrieben werden, muss das Programm mithilfe einer anderen Compiler Suite übersetzt werden. Dafür verwenden wir den AVR-GCC Kompiler.  
Die Befehle für die einzelnen Schritte sind im Prinzip die Selben. Statt _gcc_ starten die Befehle nun mit avr-gcc. Außerdem muss der Kompiler wissen, um welchen Atmega Prozessor es sich handelt und welche Taktfrequenc dieser hat.  
Der __Prozessortyp__ wird mit dem Attribut _-mmcu=type_ festgelegt, die __Taktfrequenz__ mit dem Attribut _-DF_CPU=frequencyL_ (L für Datentyp long). Außerdem kann man mit dem Attribut _-Os_ dafpr sorgen dass der __Speicherplatz__ optimal genutzt wird.  

Daten für die Atmega Prozessoren, die für unseren Laborunterricht relevant sind:   
--------------------------------------------------

Der schrittweise Kompiliervorgang bis zur main.elf, mithilfe der Shell, sieht dann wie folgt aus (verwendet wird der Arduino Nano):  
  1. __Preprozessor__: avr-gcc -Os -mmcu=atmega328p -DF_CPU=16000000L -E main.c  
  2. __Compiler__: avr-gcc -Os -mmcu=atmega328p -DF_CPU=16000000 -S main.c  
  3. __Assembler__: avr-gcc -Os -mmcu=atmega328p -DF_CPU=16000000 -c main.s  
  4. __Linker__: avr-gcc -Os -mmcu=atmega328p -DF_CPU=16000000 -o main.elf main.o
  
Die ersten 3 Schritte können natürlich auch gesammelt in einem Schritt erledigt werden. Die Objektdatei main.o wird dann direkt aus der main.c erzeugt. Die Assemblerdatei main.s ist dann ein Zwischenschritt und muss nicht extra erstellt werden: 
  1. __Preprozessor, Compiler & Assembler__: avr-gcc -Os -mmcu=atmega328p -DF_CPU=16000000 -c main.c  
  2. __Linker:__ avr-gcc -Os -mmcu=atmega328p -DF_CPU=16000000L -o main.elf main.o  

Der Atemga µC kann allerdings nichts mit der main.elf anfange, daher müssen wir zuerst eine main.hex, die vom µC verstanden wird, daraus erzeugen. Das bewerkstelligen wir mithilfe des __avr-objcopy__ Befehls.  
Der Befehl lautet dann wie folgt: __avr-objcopy -O ihex main.elf main.hex__.  
Aus der main.elf wird der Hexcode erzeugt und in die Datei main.hex, mit dem Format bfdname(durch das Attribut -O), gespeichert.  
Die main.hex führen wir nun durch den Easy Programmer auf dem Arduino aus. 

### Makefiles
Ebenso haben wir besprochen wie wir Makefiles erstellen und über die Konsole verwenden können.
