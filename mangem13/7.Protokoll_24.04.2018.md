# 6.Protokoll - 20.02.2018
Schriftführer: Gerhard Mandl  
Betreuer: Sx  
Klasse: 4AHME  
Gruppe: 2  
Anwesend: Nebel Florian, Mandl Gerhard, Moritz Martinak, Muri Lorenz, Platzer Andreas, Michael Mörth, Marcel Köhler, Mario Nabernik    
Abwesend: -

## Beginn des Unterrichts
Am Anfang des Unterrichts sind wir nochmal unser Programm durchgegangen, und sind zum Entschluss gekommen, dass das Programm auf diese Art und Weiße nicht ausreichend ist. Deshalb nehmen wir Änderungen an unserem Programm vor.

## Swingworker 

In Dieser Einheit verwenden wir einen Swingworker, in Der __Tabelle__ sieht man welche Methoden man bei einem Swingworker benutzt (in unserem Beispiel).
Ein Swingworker wird meist bei Multithreading benutzt.
__Multithreading__ bedeutet das mehrere Threads in einem Prozess oder Task abgearbeitet werden. 
Das heißt es werden mehrere Aufgaben parallel ausgeführt, um eine echte parallele Ausführung zu haben muss man aber mehrere Prozesskerne haben.

| Methode | Beschreibung |
| ------- | ------------ |
| `get()` |  Gibt den Rückgabewert von `doInBackground()` zurück |
| `doInBackground()` | Alle Befehle in dieser Methode werden in einem zweiten Thread ausgeführt. | 
| `publish()` | Gibt Zwischenwerte an den EDT-Thread zurück |
| `done()` | Wird aufgerufen nachdem `doInBackground()` beendet wird. (beendet, abgebrochen, Fehler...) |
| `process()` |  Diese Methode übernimmt die Aufgaben im EDT-Thread, während der zweite Thread arbeitet. |
| `cancel()` |  Versucht den WorkerThread zu beenden |
| `execute()` | Startet den WorkerThread |



## Das Programm

### Programmabschnitte welche neu hinzugefügt wurden. 

#### activeWorker
```java
  private SwingWorker activeWorker;
```
Wir haben unser Programm mit der Klassenvariable __active Worker__ erweitert.
Diese Variable wird azu benötigt um den Worker zu starten.

#### `startSingleMeasurement()`
```java
  private void startSingleMeasurement()
  {
    activeWorker = new MySingleMeasurementWorker(serialPort);
    activeWorker.execute();
    updateSwingControlles();
  }
```
In dieser Methode können wir sehen wie, die Variable _activeWorker_ verwendet wird um den Worker zu starten.
Gestartet wird der Worker erst durch den Befehl __activeWorker.execute()_.

#### Klasse SingleMeasurementWorker
```java
package workers;
import java.util.concurrent.TimeUnit;
import javax.swing.SwingWorker;
import jssc.SerialPort;


/**
 *
 * @author mangem13
 */
public class SingleMeasurementWorker extends SwingWorker<Double,String>
{
  private final jssc.SerialPort serialPort;

  public SingleMeasurementWorker (SerialPort serialPort)
  {
    this.serialPort = serialPort;
  }
  
  @Override
  protected Double doInBackground () throws Exception
  {
    int [] frame = {0x02,0x04,0x00,0x30,0x00,0x01,0x31,0xf6};
    serialPort.writeIntArray(frame);
    TimeUnit.SECONDS.sleep(1);
    int [] response = serialPort.readIntArray();
    System.out.println(response.length);
    double temp = response[3]+response[4] / 256.0;
    return temp;
  } 
}
```
Integer kan nur bei Werten bis 256 verwendet werden. Da dieser Wert aber übersteigt werden kann, teilen wir diesen Wert auf.
Dazu verwenden wir ein Feld mit dem Namen __response__ .


#### innere Klasse MySingleMeasurementWorker
```java
  private class MySingleMeasurementWorker extends SingleMeasurementWorker
  {
    public MySingleMeasurementWorker (SerialPort serialPort)
    {
      super(serialPort);
    }

    @Override
    protected void done ()
    {
      try
      {
        double temp = get();
        jlaTemperatur.setText(String.format("%.01f °C", temp));
      }
      catch (Exception ex)
      {
        showThrowable("Einzelmessung gescheitert", ex);
      }
      finally
      {
        activeWorker = null;
        updateSwingControlles();
      }
    }

    @Override
    protected void process (List<String> chunks)
    {

    }  
  }
```
Die Methode `done` speichert den Rückgabewert des Worker in die __temp__ Variable. Die Variable __temp__ bekommt den Wert über die Methode `get`.


### Programmabschiede die Umändert oder Erweitert wurden

#### `connect()`
```java
  private void connect()
  {
    try 
    {
      String port = (String) jcbSerialDevice.getSelectedItem();
      serialPort = new jssc.SerialPort(port);
      serialPort.openPort();
      serialPort.setParams(
              SerialPort.BAUDRATE_57600, // Festlegen der Baudrate
              SerialPort.DATABITS_8, // Festlegen des Data Bits
              SerialPort.STOPBITS_2, // Festlegen des Stop Bits
              SerialPort.PARITY_NONE); //Festlegen des Parity Bits
      updateSwingControlles();
    }
    catch (Throwable th)
    {
      try 
      {
        if(serialPort != null && serialPort.isOpened())
          serialPort.closePort();
      }
      catch(Throwable th2)
      {
        th.addSuppressed(th2);
      }
      finally
      {
        updateSwingControlles();
      }
      showThrowable("Serielle Schnittstelle kann nicht geöffnet werden", th);
      serialPort = null;
    }    
  }
```
`connect` ist eine der Methoden welche wir erweiter haben. Da wir mit der Schnittstelle  Uart arbeiten müssen wir diese Konfigurieren. (Keine Hot und Play capability). Im Fivu Unterricht haben wir bereits gelernt, welche Einstellungen wir vornehmen müssen. 
Data Bits, Stop Bits, Parity Bits... und so weiter zu setzen. _In den Kommentaren des Programmes werden die Funktionen genauer beschrieben_

#### `updateSwingControlles()`
```java
  public void updateSwingControlles()
  {
    jcbSerialDevice.setEnabled(false);
    jbutConnect.setEnabled(false);
    jbutContinousMeasurement.setEnabled(false);
    jbutDisconnect.setEnabled(false);
    jbutRefresh.setEnabled(false);
    jbutSingleMeasurement.setEnabled(false);
    jbutStopMeasurement.setEnabled(false);
    jlaTemperatur.setEnabled(false);
    
    if(activeWorker != null)
    {
      setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
      return;
    }
    
    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
    jlaTemperatur.setEnabled(true);
    
    if(serialPort != null && serialPort.isOpened()) //Es wurde eine Verbindung mit einem Port erstellt -> Trennen möglich
    {
      jbutDisconnect.setEnabled(true);
      jbutSingleMeasurement.setEnabled(true);
      return;
    } 

    if(ports != null && ports.length > 0) //Verbinden mit einem Port möglich
    {
      jcbSerialDevice.setEnabled(true);
      jbutConnect.setEnabled(true);
      jbutRefresh.setEnabled(true);
    }
    else if(ports != null && ports.length == 0)
      jbutRefresh.setEnabled(true); 
  }
```
Diese Methode wird um die __if-Verzweigung__ `if(activeWorker !=null) ` erweitert. Diese Verzweigung überpüft ob ein Worker activ ist, sollte ein Worker active sein soll sich der Cursor auf den "Wait Cursor" ändern. 








