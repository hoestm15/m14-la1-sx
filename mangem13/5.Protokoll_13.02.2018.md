# 5.Protokoll - 13.02.2018
Schriftführer: Gerhard Mandl  
Betreuer: Sx  
Klasse: 4AHME  
Gruppe: 2  
Anwesend: Nebel Florian, Mandl Gerhard, Moritz Martinak, Mario Nabernik, Muri Lorenz, Platzer Andreas, Marcel Köhler  
Abwesend: Michael Mörth
   
## Modbus
Um von einem Sure-Board Daten an einen PC zu übertragen wird ein entsprechendes [Feldbusprotokoll](https://de.wikipedia.org/wiki/Feldbus) benötigt . In _Fivu_ haben wir bereits einige besprochen, aber Varianten wie Powerlink(, Profinet oder Flexray (div. Automobil- und Elektronikunternehmen) fallen aufgrund von fehlenden Lizenzen für unsere Zwecke flach.  
Jedoch können wir den Modbus verwenden, den dieser ist ein offener und freier [Modbus](https://de.wikipedia.org/wiki/Modbus).  

Anfänglich wurde der Modbus für die Kommunikation zwischen SPS-Geräten entwickelt, etablierte sich aber in der Industrie als De-Facto-Stamdard. da es sich wie bereits erwähnt um ein offenes Protokoll handelt. Seti 2007 ist die Version Modbus TCP Teil der IEC 61158. Es lassen sich sowohl RS-232 Netzwerke, sowie TCP/IP - Netzwerke aufbauen.

### Grundkonzept
Das Kommunikationsprotokoll ist ein einfaches zustandsloses Protokoll basierend auf einem Request/Response Prinzip.  
Modbus ist eigentlich ein Application-Protocol, das im OSI-Layer 7 (Application Layer) angesiedelt ist. Dadurch lassen sich Geräte mit unterschiedlichsten Verbindungstechnolgien miteinander verbinden.  




Man unterscheidet zwischen 3 Datenübertragungsarten:
* Modbus ASCII (byteweise Übertragung, textuell)
* Modbus RTU (byteweise Übertragung, binär)
* Modbus TCP (Übertragung in TCP-Paketen)


#### Unterschiede zwischen Uart, RS-232, RS-485
* Unterschied zwischen Uart und RS-232 sind die Pegel (Spannung) 
* Unterschied zwischen RS-485 und Rs-232, der RS-485 ist ein echter Modbus (mehrere Teilnehmer)

### Kommunikationsablauf






## Protokollaufbau
#### RTU
> Im RTU-Modus wird der Sendebeginn durch eine Sendepause von mindestens der 3,5-fachen Zeichenlänge markiert. Die Länge der Sendepause hängt somit von der Übertragungsgeschwindigkeit ab. Das Adressfeld besteht aus acht Bit, die die Empfängeradresse darstellen. Der Slave sendet bei seiner Antwort an den Master ebendiese Adresse zurück, damit der Master die Antwort zuordnen kann. Das Funktionsfeld besteht aus 8 Bit. Hat der Slave die Anfrage des Masters korrekt empfangen, so antwortet er mit demselben Funktionscode. Ist ein Fehler aufgetreten, so verändert er den Funktionscode, indem er das höchstwertige Bit des Funktionsfeldes auf 1 setzt. Das Datenfeld enthält Hinweise, welche Register der Slave auslesen soll, und ab welcher Adresse diese beginnen. Der Slave setzt dort die ausgelesenen Daten (z. B. Messwerte) ein, um sie an den Master zu senden. Im Fehlerfall wird dort ein Fehlercode übertragen. Das Feld für die Prüfsumme, die mittels CRC ermittelt wird, beträgt 16 Bit. Das gesamte Telegramm muss in einem kontinuierlichen Datenstrom übertragen werden. Tritt zwischen zwei Zeichen eine Sendeunterbrechung auf, die länger als 1,5 Zeichen ist, so ist das Telegramm als unvollständig zu bewerten und sollte vom Empfänger verworfen werden.

#### ASCII
> Im ASCII-Modus beginnen Nachrichten mit einem vorangestellten Doppelpunkt, das Ende der Nachricht wird durch die Zeichenfolge Carriage return – Line feed (CRLF) markiert.

> Die ersten zwei Bytes enthalten zwei ASCII-Zeichen, die die Adresse des Empfängers darstellen. Der auszuführende Befehl ist auf den nächsten zwei Bytes codiert. Über ein Zeichen folgen die Daten. Über das gesamte Telegramm (ohne Start- und Ende-Markierung) wird zur Fehlerprüfung ein LRC ausgeführt, dessen Paritätsdatenwort in den abschließenden zwei Zeichen untergebracht wird. Tritt während der Übertragung eines Frames eine Pause von > 1s auf, wird der Frame als Fehlerfall bewertet. Der Benutzer kann ein längeres Timeout konfigurieren.

#### TCP/IP
| Transaktionsnummer | Protokollkennzeichen | Zahl der nachfolgenden Bytes | Adresse | Funktion | Daten |
|:------------------:|:--------------------:|:----------------------------:|:-------:|:--------:|:-----:|
| 2 Byte | 2 Byte (immer 0x0000) | 2 Byte | 1 Byte | 1 Byte | n Byte |

*Quelle: [Wikipedia, Modbus](https://de.wikipedia.org/wiki/Modbus)*  

### Objekttypen
Lese- und Schreibzugriffe auf folgende Objekttypen ist möglich:

| Schnittstellentyp | Objekttyp | Zugriff | Größe |
|:-----------------:|:---------:|:-------:|:-----:|
| Digitaler Eingang | "Discrete Input" | Lesen | 1 bit |
| Analoger Eingang | "Input Register" | Lesen | 16 bit |
| Digitaler Ein-/Ausgang | "Coil" | Lesen & Schreiben | 1 bit |
| Analoger Ein-/Ausgang | "Holding Register" | Lesen & Schreiben | 16 bit |
