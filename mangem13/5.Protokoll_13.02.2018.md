# 5.Protokoll - 13.02.2018
Schriftführer: Gerhard Mandl  
Betreuer: Sx  
Klasse: 4AHME  
Gruppe: 2  
Anwesend: Nebel Florian, Mandl Gerhard, Moritz Martinak, Mario Nabernik, Muri Lorenz, Platzer Andreas, Marcel Köhler  
Abwesend: Michael Mörth
   
## Modbus
Um von einem Sure-Board Daten an einen PC zu übertragen wird ein entsprechendes [Feldbusprotokoll](https://de.wikipedia.org/wiki/Feldbus) benötigt . In _Fivu_ haben wir bereits einige besprochen, aber Varianten wie Powerlink(, Profinet oder Flexray (div. Automobil- und Elektronikunternehmen) fallen aufgrund von fehlenden Lizenzen für unsere Zwecke flach.  
Jedoch können wir den Modbus verwenden, den dieser ist ein offener und freier [Modbus](https://de.wikipedia.org/wiki/Modbus).  

Anfänglich wurde der Modbus für die Kommunikation zwischen SPS-Geräten entwickelt, etablierte sich aber in der Industrie als De-Facto-Stamdard. da es sich wie bereits erwähnt um ein offenes Protokoll handelt. Seti 2007 ist die Version Modbus TCP Teil der IEC 61158. Es lassen sich sowohl RS-232 Netzwerke, sowie TCP/IP - Netzwerke aufbauen.

### Grundkonzept
Das Kommunikationsprotokoll ist ein einfaches zustandsloses Protokoll basierend auf einem Request/Response Prinzip.  
Modbus ist eigentlich ein Application-Protocol, das im OSI-Layer 7 (Application Layer) angesiedelt ist. Dadurch lassen sich Geräte mit unterschiedlichsten Verbindungstechnolgien miteinander verbinden.  
![Grundkonzept](https://github.com/HTLMechatronics/m14-la1-sx/blob/mangem13/mangem13/Fivu%20-%20Grunkonzept.PNG)


Man unterscheidet zwischen 3 __Datenübertragungsarten:__  
* Modbus ASCII (byteweise Übertragung, textuell)  
* Modbus RTU (byteweise Übertragung, binär)  
* Modbus TCP (Übertragung in TCP-Paketen)  


#### Unterschiede zwischen Uart, RS-232, RS-485
* Unterschied zwischen Uart und RS-232 sind die Pegel (Spannung)   
* Unterschied zwischen RS-485 und Rs-232, der RS-485 ist ein echter Modbus (mehrere Teilnehmer)  

### Kommunikationsablauf
Der Kommunikationsablauf beruht auf einem Server/Client Prinzip. Der Client (zum Beispiel ein PC) sendet einen Request zum Server (zum Beispiel ein Aktor oder Sensor). Dieser antworter mit einer Response.  
![Kommunikationsablauf](https://github.com/HTLMechatronics/m14-la1-sx/blob/mangem13/mangem13/Fivu%20-%20Server.PNG)  

Jeder Baustein muss eine Adresse haben wobei die __Adresse 0__ für einen Broadcas reserviert ist.  
In der Theorie kann jeder Knoten die Server- und/oder client-Rolle einnehmen.  
In der Praxis ist das Master/client System realisiert. Master erzeugt __request__ --> Slave sendet __response__.   

__Wichtig:__ Bei Modbus ist das Master/Slave Prinzip verpflichtend, da das Protocol keinen Arbetrierungsmechanismus definiert.  

[Function-Code](https://lms.at/dotlrn/classes/htl_elektrotechnik/610437.4AHME_LA1.17_18/xolrn/E7BE8C85F66CA/2148F16AC6F2E.symlink?resource_id=0-236827434-257560369&m=view#167572781) ist ein byte, dass die Art des Requests oder Respons genauer festlegt.  
Für Request und Responses beginnt der __Wert nicht__ wie gewohnt mit __0__ sondern mit 1...127  
Für Exceptions sind die Werte 128....255 zu verwenden. __Function-Code 0 ist nicht erlaubt.__  

### Modbus-Gateway, ADU/PDU
Ein Modbus-Gateway ist in der Lage verschiedene Modbus-Varianten miteinander zu verbinden, also zum Beispiel die Verbindung eines über die UART-Schnittstelle erreichbaren Sensors mit einem über TCP/IP erreichbaren PC.  

Das Modbus Application Layer Protocol definiert dabei als Frame sogenannte Protocol Data Units (__PDU__). PDU besteht aus einen Function-Code. PDUs enthalten noch kein Adressierungsschema, da unterschiedliche Varianten auch unterschiedliche Adressierungsarten verwenden.  
Die __ADU__ ensteht durch die definierung der Frame-Felder Adressierung und Fehlererkennung.  

![Frameaufbau](https://github.com/HTLMechatronics/m14-la1-sx/blob/mangem13/mangem13/Fivu%20-%20PDU.PNG)

## Protokollaufbau
#### RTU
> Im RTU-Modus wird der Sendebeginn durch eine Sendepause von mindestens der 3,5-fachen Zeichenlänge markiert. Die Länge der Sendepause hängt somit von der Übertragungsgeschwindigkeit ab. Das Adressfeld besteht aus acht Bit, die die Empfängeradresse darstellen. Der Slave sendet bei seiner Antwort an den Master ebendiese Adresse zurück, damit der Master die Antwort zuordnen kann. Das Funktionsfeld besteht aus 8 Bit. Hat der Slave die Anfrage des Masters korrekt empfangen, so antwortet er mit demselben Funktionscode. Ist ein Fehler aufgetreten, so verändert er den Funktionscode, indem er das höchstwertige Bit des Funktionsfeldes auf 1 setzt. Das Datenfeld enthält Hinweise, welche Register der Slave auslesen soll, und ab welcher Adresse diese beginnen. Der Slave setzt dort die ausgelesenen Daten (z. B. Messwerte) ein, um sie an den Master zu senden. Im Fehlerfall wird dort ein Fehlercode übertragen. Das Feld für die Prüfsumme, die mittels CRC ermittelt wird, beträgt 16 Bit. Das gesamte Telegramm muss in einem kontinuierlichen Datenstrom übertragen werden. Tritt zwischen zwei Zeichen eine Sendeunterbrechung auf, die länger als 1,5 Zeichen ist, so ist das Telegramm als unvollständig zu bewerten und sollte vom Empfänger verworfen werden.

#### ASCII
> Im ASCII-Modus beginnen Nachrichten mit einem vorangestellten Doppelpunkt, das Ende der Nachricht wird durch die Zeichenfolge Carriage return – Line feed (CRLF) markiert.

> Die ersten zwei Bytes enthalten zwei ASCII-Zeichen, die die Adresse des Empfängers darstellen. Der auszuführende Befehl ist auf den nächsten zwei Bytes codiert. Über ein Zeichen folgen die Daten. Über das gesamte Telegramm (ohne Start- und Ende-Markierung) wird zur Fehlerprüfung ein LRC ausgeführt, dessen Paritätsdatenwort in den abschließenden zwei Zeichen untergebracht wird. Tritt während der Übertragung eines Frames eine Pause von > 1s auf, wird der Frame als Fehlerfall bewertet. Der Benutzer kann ein längeres Timeout konfigurieren.

#### TCP/IP
| Transaktionsnummer | Protokollkennzeichen | Zahl der nachfolgenden Bytes | Adresse | Funktion | Daten |
|:------------------:|:--------------------:|:----------------------------:|:-------:|:--------:|:-----:|
| 2 Byte | 2 Byte (immer 0x0000) | 2 Byte | 1 Byte | 1 Byte | n Byte |

*Quelle: [Wikipedia, Modbus](https://de.wikipedia.org/wiki/Modbus)*  

### Objekttypen
Lese- und Schreibzugriffe auf folgende Objekttypen ist möglich:

| Schnittstellentyp | Objekttyp | Zugriff | Größe |
|:-----------------:|:---------:|:-------:|:-----:|
| Digitaler Eingang | "Discrete Input" | Lesen | 1 bit |
| Analoger Eingang | "Input Register" | Lesen | 16 bit |
| Digitaler Ein-/Ausgang | "Coil" | Lesen & Schreiben | 1 bit |
| Analoger Ein-/Ausgang | "Holding Register" | Lesen & Schreiben | 16 bit |

## Modbus verwendung mit Raspberry
Leider kann ich keinen Modbus RTU am Raspberry verwenden da ich, am Raspberry keine Kontrolle über den Uart habe.  
Somit kann ich auch nicht die Zeiten einstellen wann ein Paket geschickt wird. 
![Frame](https://github.com/HTLMechatronics/m14-la1-sx/blob/mangem13/mangem13/Fivu%20frame.PNG)  

![FrameNotok](https://github.com/HTLMechatronics/m14-la1-sx/blob/mangem13/mangem13/Framenotok-%20Fivu.PNG)  
__Lösung__: man baut einen uC dazu oder man macht das über eine Schnittstelle. 
