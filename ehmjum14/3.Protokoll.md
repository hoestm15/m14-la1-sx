# *Protokoll:* Julian Ehmann  

## **3. Einheit: Atmel Studio**  
 Name: Julian Ehmann  
 Klasse: 4AHME  
 Datum: 24.10.2017  
 Anwesend: Berger Emil, Bullner Jeremy, Böcksteiner Jakob, Ehmann Julian, Enzi Gert, Kobor Markus, Knappitsch Robert
 Abwesend: -
 
 ## **Wiederholung**  
 
Am beginn der 3ten Einheiten haben wir alles aus der vorherigen Einheit wiederholt. Darunter fallen alle durchbesprochenen Befehle für  Atmel Studio und der genau Aufbau eines µC. Siehe [2. Protokoll](https://github.com/HTLMechatronics/m14-la1-sx/edit/ehmjum14/ehmjum14/2.Protokoll.md)  

## **Fortseztung mit Atmel Studio**  

Wir begannen damit die folgende Funktion zu erstellen und zu anaylisieren.  

int main void()  
{  
   volatile unsinged char x;  
    x = 12;  
    return x;  
}  

Zuerst wird eine Variable **x** mit dem Datentyp unsinged char, welche mit dem Schlüsselwort **volatile** versehen wurde, im Stack Speicher angelegt.  
Danach bekommt sie den Wert *12* zugewiesen.  
Im Anschluss wird die Variable x nach einem Typcast auf int, zurückgegeben.   

### Assembler-Befehle
Maschinenbefehle | Beschreibungen
---------------- | ---------
PUSH R28 | Das Register R28 wird auf den nächsten freien Platz im Stack plaziert. (immer an erster Stelle)
PUSH R29 | Das Register R29 wird auf den nächsten freien Platz im Stack gelegt. (immer an erster Stelle)
PUSH R1 | Das Register R1 wird auf den nächsten freien Platz im Stack gelegt. (immer an erster Stelle) **Das Register R1 hat immer den Wert "0"**
IN R28,0x3D | Der Wert 0x3D wird aus dem I/O-Register in das angegebene Register R28 geladen.
IN R29,0x3E | Der Wert 0x3E wi rd aus dem I/O-Register in das vorne angegebene Register R29 geladen.
LDI R24,0x0C | Hierbei wird ein konstanter Wert (12) in das Register R24 geladen.
LDI R25,0x00 | Liefert den Rückgabewert.
POP R0 | Durch diesen Befehl wird die das Register R0 freigegeben.
POP R29 | Das Register R29 wird aus dem Stack geschoben. 
POP R28 | Das Register R28 wird ebenfalls aus dem Stack geschoben. 
## Addition

Als nächstes Beispiel sind wir eine Funktion, welche addieren kann, durchgegangen.

int main (void)  
{  
	volatile unsigned char a = 12;  
	volatile unsigned char b = 8;  
	return a+b;  
}  

  Hier haben wir das Programm gestartet und Debug-Modus durchgegangen.
  Anschließend wird über den Disassambly-Modus die Übersicht über die Maschinenbefehle geöffnet.  

### Assembler
Maschinenbefehl | in Worten | Kommentar
--------------- | --------- | ---------
`cf.93` | PUSH R28 | Register R28 wird auf den Stack gelegt.
`df.93` | PUSH R29 | Register R29 wird auf den Stack gelegt.
`00.d0` | RCALL PC+0x0001 | Springt zum nächsten Befehl. *Durch den RCALL werden 2 Bytes auf dem Stack reserviert, die für die Variablen a & b verwendet werden.*
`cd.b7` | IN R28,0x3D | 0x3D wird aus dem I/O-Register in R28 geladen.
`de.b7` | IN R29,0x3E | 0x3E wird aus dem I/O-Register in R29 geladen.
`8c.c0` | LDI R24,0x0C | Konstante (0C = 12) wird im Register R24 abgelegt.
`89.83` | STD Y+1,R24 | Konstante aus R24 wird am Speicherplatz des Stacks der ersten lokalen Variable (a) abgelegt.
`88.e0` | LDI R24,0x08 | Konstante (08 = 8) wird im Register R24 abgelegt.
`89.83` | STD Y+2,R24 | Konstante aus R24 wird am Speicherplatz des Stacks der zweiten lokalen Variable (b) abgelegt.
`89.81` | LDD R24,Y+1 | Variable a wird in Register R24 geladen.
`2a.81` | LDD R18,Y+2 | Variable b wird in Register R18 geladen.
`30.e0` | LDI R19, 0x00 | Konstante 0x00 wird am Register R19 abgelegt.
`28.0f` | ADD R18,R24 | Die beiden Register werden addiert, ohne Berücksichtigung des Carry-Flags. Das Endergebnis wird in R18 gespeichert.
`31.1d` | ADC R19,R1 | Addition mit Berücksichtigung des Carry-Flags. *Das Carry-Flag enthält den Übertrag einer Addition.
`0f.90` | POP R0 | Variable b wird freigegeben.
`0f.90` | POP R0 | Variable a wird freigegeben.
`df.91` | POP R29 | Register R29 wird vom Stack entfernt.
`cf.91` | POP R28 | Register R28 wird vom Stack entfernt.


## Weitere Quellcodes  

Nun folgen weitere Quellcodes welche wir in der letzten Laboreinheit geschrieben und durch besprochen haben:  

### Schleife  

#include <avr/io.h>  

int main (void)  
{  
	volatile a = 10;  
        uint8_t b;  

	for (b=0; b<10; b++)  
	{  
	}  
	return 0;  
	
### Multiplikation  

int main (void)  
{  
	volatile unsigned char a = 12;  
	volatile unsigned char b = 8;  
	  
	return a*b;  
}  

### Division  

int main (void)  
{  
	volatile unsigned char a = 12;  
	volatile unsigned char b = 8;  
	
	return a/b;  
}  

### Schlussfolgerung der Übung
  Manche Befehle sind für den µC keine große Aufgabe, z.B addieren oder multiplizieren. Hierführ gibt es eigene interne Befehle.  
  Hingegen benötigt z.B dividieren sehr viel Rechenleistung, da es für diese Aufgabe keinen speziellen Befehl gibt.  
  Auch größere Variablen können dem Prozessor viel Leistung abverlangen.  
  Dies führt wiederum zu ''Schwierigkeiten'' für den Prozessor, da die Verarbeitungszeit enorm ansteigt.  




