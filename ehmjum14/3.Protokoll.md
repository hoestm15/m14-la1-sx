# *Protokoll:* Julian Ehmann  

## **3. Einheit: Atmel Studio**  
 Name: Julian Ehmann  
 Klasse: 4AHME  
 Datum: 24.10.2017  
 Anwesend: Berger Emil, Bullner Jeremy, Böcksteiner Jakob, Ehmann Julian, Enzi Gert, Kobor Markus, Knappitsch Robert
 Abwesend: -
 
 ## **Wiederholung**  
 
Am beginn der 3ten Einheiten haben wir alles aus der vorherigen Einheit wiederholt. Darunter fallen alle durchbesprochenen Befehle für  Atmel Studio und der genau Aufbau eines µC. Siehe [2. Protokoll](https://github.com/HTLMechatronics/m14-la1-sx/edit/ehmjum14/ehmjum14/2.Protokoll.md)  

## **Fortseztung mit Atmel Studio**  

Wir begannen damit die folgende Funktion zu erstellen und zu anaylisieren.  

```c
int main void()  
{  
   volatile unsinged char x;  
    x = 12;  
    return x;  
}  
```
Zuerst wird eine Variable **x** mit dem Datentyp unsinged char, welche mit dem Schlüsselwort **volatile** versehen wurde, im Stack Speicher angelegt.  
Danach bekommt sie den Wert *12* zugewiesen.  
Im Anschluss wird die Variable x nach einem Typcast auf int, zurückgegeben.   

### Assembler-Befehle
Maschinenbefehle | Beschreibungen
---------------- | ---------
PUSH R28 | Das Register R28 wird auf den nächsten freien Platz im Stack plaziert. (immer an erster Stelle)
PUSH R29 | Das Register R29 wird auf den nächsten freien Platz im Stack gelegt. (immer an erster Stelle)
PUSH R1 | Das Register R1 wird auf den nächsten freien Platz im Stack gelegt. (immer an erster Stelle) **Das Register R1 hat immer den Wert "0"**
IN R28,0x3D | Der Wert 0x3D wird aus dem I/O-Register in das angegebene Register R28 geladen.
IN R29,0x3E | Der Wert 0x3E wi rd aus dem I/O-Register in das vorne angegebene Register R29 geladen.
LDI R24,0x0C | Hierbei wird ein konstanter Wert (12) in das Register R24 geladen.
LDI R25,0x00 | Liefert den Rückgabewert.
POP R0 | Durch diesen Befehl wird die das Register R0 freigegeben.
POP R29 | Das Register R29 wird aus dem Stack geschoben. 
POP R28 | Das Register R28 wird ebenfalls aus dem Stack geschoben. 
## Addition



Als nächstes Beispiel sind wir eine Funktion, welche addieren kann, durchgegangen.

```c
int main (void)  
{  
	volatile unsigned char a = 12;  
	volatile unsigned char b = 8;  
	return a+b;  
}  
```

  Hier haben wir das Programm gestartet und Debug-Modus durchgegangen.
  Anschließend wird über den Disassambly-Modus die Übersicht über die Maschinenbefehle geöffnet.  

### Assembler
Maschinenbefehl | Beschreibungen
--------------- | ---------------
IN R28,0x3D | Der Wert 0x3D wird aus dem I/O-Register in das angegebene Register R28 geladen.
IN R29,0x3E | Der Wert 0x3E wird aus dem I/O-Register in das vorne angegebene Register R29 geladen.
LDI R24,0x0C | Hierbei wird ein konstanter Wert (12) in das Register R24 geladen.
STD Y+1,R24 | Der konstante Wert, der aus dem R24 geladen wird, wird an erster Stelle des Stacks (Variable a) abgelegt.
LDI R24,0x08 | Die Konstante 8 wird hierbei in dem Register R24 abgelegt.
STD Y+2,R24 |Der konstante Wert, der aus dem R24 geladen wird, wird an erster Stelle des Stacks (Variable b) abgelegt.
LDI R19, 0x00 | Die Konstante 0 wird hierbei in dem Register R19 abgelegt.
ADD R18,R24 | Hier werden die beiden angegebenen Register addiert. Das Carry-Flag wird in diesem Fall nicht berücksichtigt. Das Ergebnis wird dann in dass Register R18 gespeichert.
ADC R19,R1 | Hier wird eine Addition unter Berücksichtigung des Carry-Flags durchgeführt. 

## Weitere Quellcodes  

Nun folgen weitere Quellcodes welche wir in der letzten Laboreinheit geschrieben und durch besprochen haben:  

### Schleife 

```c
#include <avr/io.h>  

int main (void)  
{  
	volatile a = 10;  
        uint8_t b;  

	for (b=0; b<10; b++)  
	{  
	}  
	return 0;  
```
### Multiplikation  

```c
int main (void)  
{  
	volatile unsigned char a = 12;  
	volatile unsigned char b = 8;  
	  
	return a*b;  
} 
```

### Division  

```c
int main (void)  
{  
	volatile unsigned char a = 12;  
	volatile unsigned char b = 8;  
	
	return a/b;  
}  
```

### Schlussfolgerung der Übung
  Manche Befehle sind für den µC keine große Aufgabe, z.B addieren oder multiplizieren. Hierführ gibt es eigene interne Befehle.  
  Hingegen benötigt z.B dividieren sehr viel Rechenleistung, da es für diese Aufgabe keinen speziellen Befehl gibt.  
  Dies führt zu ''Schwierigkeiten'' für den Prozessor, da die Verarbeitungszeiten enorm ansteigen.  
  Ebenso können "große" Variablen dem Prozessor viel Leistung abverlangen.  



