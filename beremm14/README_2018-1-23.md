# Protokoll
  Berger Emil  
  4AHME, Gruppe 1  
  23.01.18  
  Anwesend: Berger, Böcksteiner, Bullner, Ehmann, Enzi, Kobor, Knappitsch  
  Abwesend: niemand  
    
## Modbus
![Modbus](http://www.technikmedia.de/assets/images/autogen/modbus_logo.png)
Um von einem Sure-Board Daten an eine PC zu übertragen wird ein entsprechendes [Feldbusprotokoll](https://de.wikipedia.org/wiki/Feldbus) benötigt. Im Unterrichtsgegenstand *FIVU* hatten wir bereits einige besprochen, aber Varianten wie [Powerlink](https://de.wikipedia.org/wiki/Ethernet_Powerlink) ([B&R](https://de.wikipedia.org/wiki/B%26R)), [Profinet](https://de.wikipedia.org/wiki/Profinet) ([PROFIBUS](https://de.wikipedia.org/wiki/PROFIBUS_Nutzerorganisation_e.V.)) oder [Flexray](https://de.wikipedia.org/wiki/FlexRay) (div. Automobil- und Elektronikunternehmen) fallen aufgrund von fehlenden Lizenzen für unsere Zwecke flach. Eine offene, freie Alternative ist [Modbus](https://de.wikipedia.org/wiki/Modbus).

Anfänglich wurde *Modbus* für die Kommunikation zwischen SPS-Geräten entwickelt, etablierte sich aber in der Industrie als De-Facto-Standard, da es sich wie bereits erwähnt um ein offenes Protokoll handelt. Seit 2007 ist die Version *Modbus TCP* Teil der [IEC 61158](https://de.wikipedia.org/wiki/IEC_61158). Es lassen sich sowohl [RS-232](https://de.wikipedia.org/wiki/RS-232)-Netzwerke, sowie TCP/IP-Netzwerke aufbauen.

Mit Modbus kann ein **Master** mit mehreren **Slaves** verbunden werden. Jeder Teilnehmer des Netzwerkes ist berechtigt Daten zu übertragen, regeln tut dies der Master.

Man unterscheidet zwischen 3 Betriebsarten:
* Modbus ASCII (byteweise Übertragung, textuell)
* Modbus RTU (byteweise Übertragung, binär)
* Modbus TCP (Übertragung in TCP-Paketen)

### Protokollaufbau
#### RTU
> Im RTU-Modus wird der Sendebeginn durch eine Sendepause von mindestens der 3,5-fachen Zeichenlänge markiert. Die Länge der Sendepause hängt somit von der Übertragungsgeschwindigkeit ab. Das Adressfeld besteht aus acht Bit, die die Empfängeradresse darstellen. Der Slave sendet bei seiner Antwort an den Master ebendiese Adresse zurück, damit der Master die Antwort zuordnen kann. Das Funktionsfeld besteht aus 8 Bit. Hat der Slave die Anfrage des Masters korrekt empfangen, so antwortet er mit demselben Funktionscode. Ist ein Fehler aufgetreten, so verändert er den Funktionscode, indem er das höchstwertige Bit des Funktionsfeldes auf 1 setzt. Das Datenfeld enthält Hinweise, welche Register der Slave auslesen soll, und ab welcher Adresse diese beginnen. Der Slave setzt dort die ausgelesenen Daten (z. B. Messwerte) ein, um sie an den Master zu senden. Im Fehlerfall wird dort ein Fehlercode übertragen. Das Feld für die Prüfsumme, die mittels CRC ermittelt wird, beträgt 16 Bit. Das gesamte Telegramm muss in einem kontinuierlichen Datenstrom übertragen werden. Tritt zwischen zwei Zeichen eine Sendeunterbrechung auf, die länger als 1,5 Zeichen ist, so ist das Telegramm als unvollständig zu bewerten und sollte vom Empfänger verworfen werden.

#### ASCII
> Im ASCII-Modus beginnen Nachrichten mit einem vorangestellten Doppelpunkt, das Ende der Nachricht wird durch die Zeichenfolge Carriage return – Line feed (CRLF) markiert.

> Die ersten zwei Bytes enthalten zwei ASCII-Zeichen, die die Adresse des Empfängers darstellen. Der auszuführende Befehl ist auf den nächsten zwei Bytes codiert. Über ein Zeichen folgen die Daten. Über das gesamte Telegramm (ohne Start- und Ende-Markierung) wird zur Fehlerprüfung ein LRC ausgeführt, dessen Paritätsdatenwort in den abschließenden zwei Zeichen untergebracht wird. Tritt während der Übertragung eines Frames eine Pause von > 1s auf, wird der Frame als Fehlerfall bewertet. Der Benutzer kann ein längeres Timeout konfigurieren.

#### TCP/IP
| Transaktionsnummer | Protokollkennzeichen | Zahl der nachfolgenden Bytes | Adresse | Funktion | Daten |
|:------------------:|:--------------------:|:----------------------------:|:-------:|:--------:|:-----:|
| 2 Byte | 2 Byte (immer 0x0000) | 2 Byte | 1 Byte | 1 Byte | n Byte |

*Quelle: [Wikipedia, Modbus](https://de.wikipedia.org/wiki/Modbus)*  
  
### Objekttypen
Lese- und Schreibzugriffe auf folgende Objekttypen ist möglich:

| Schnittstellentyp | Objekttyp | Zugriff | Größe |
|:-----------------:|:---------:|:-------:|:-----:|
| Digitaler Eingang | "Discrete Input" | Lesen | 1 bit |
| Analoger Eingang | "Input Register" | Lesen | 16 bit |
| Digitaler Ein-/Ausgang | "Coil" | Lesen & Schreiben | 1 bit |
| Analoger Ein-/Ausgang | "Holding Register" | Lesen & Schreiben | 16 bit |

### Modbus-Gateway
  Einen Modbus-Gateway benötigt man um verschiedene Netzwerke miteinander zu verknüpfen (zB. ein RS-232 mit einem TCP/IP-Netzwerk).  
  [Weitere Informationen zu Modbus](http://www.modbus.org/docs/Modbus_Application_Protocol_V1_1b3.pdf)  

## Java Native Interface (JNI)
> JNI ermöglicht es, native Methoden zu schreiben für Situationen, in denen es nicht möglich ist, ausschließlich Java als Programmiersprache einzusetzen. Dies ist der Fall, wenn beispielsweise die Standard-Java-Klassenbibliothek bestimmte Plattform-abhängige Features oder andere Programmbibliotheken nicht unterstützt. Weiterhin ist es per JNI möglich, eine weitere in einer anderen Programmiersprache programmierte Anwendung für Java zugreifbar zu machen. Viele Klassen der Java-Standardbibliothek basieren auf JNI, um beispielsweise die Datei-Ein- und Ausgabe oder Soundwiedergabe zu ermöglichen. Indem Java Leistungs- und Plattform-abhängige Implementierungen in die Standardbibliothek integriert, kann der Java-Programmierer und -Nutzer diese Features in sicherer und Plattform-unabhängiger Weise nutzen.  
  *Quelle: [Wikipedia, JNI](https://de.wikipedia.org/wiki/Java_Native_Interface)*  
  
Wir benötigen das JNI um eine Kommunikationsschnittstelle zwischen unserer [Java Virtual Machine](https://de.wikipedia.org/wiki/Java_Virtual_Machine) und den [seriellen Schnittstellen](https://de.wikipedia.org/wiki/Serielle_Schnittstelle) auf die unserer Betriebssystem zugreift, herzustellen. Um auf USB-Schnittstellen im Speziellen zuzugreifen wird die Schnittstelle [javax.comm](https://de.wikipedia.org/wiki/Java_Communications_API) verwendet. 

### Funktionsweise in unserem Fall
![JNI](/beremm14/IMG_0613.jpg)
*Quelle: Mitschrift, BERGER Emil*

### Programmbibliotheken
In unseren *AIIT-Templates* unter Netbeans finden sich [Programmbibliotheken](https://de.wikipedia.org/wiki/Programmbibliothek) für JNI.
Jedes Betriebssystem, bzw. jede [Architektur](https://de.wikipedia.org/wiki/Rechnerarchitektur) benötigt zum Kompilieren seine/ihre eigene Bibliothek.

| Betriebssystem | Architektur | Wortbreite | Kürzel |
|:--------------:|:-----------:|:----------:|:------:|
| [Linux](https://de.wikipedia.org/wiki/Linux) | [x86](https://de.wikipedia.org/wiki/X86-Prozessor) | 32 bit | `.so` |
| [Linux](https://de.wikipedia.org/wiki/Linux) | [x86](https://de.wikipedia.org/wiki/X86-Prozessor) | 64 bit | `.so` |
| [Linux](https://de.wikipedia.org/wiki/Linux) | [ARM](https://de.wikipedia.org/wiki/ARM-Architektur) | 32 bit | `.so` |
| [macOS](https://de.wikipedia.org/wiki/MacOS) | [x86](https://de.wikipedia.org/wiki/X86-Prozessor) | 32 bit | `.jnilib` |
| [macOS](https://de.wikipedia.org/wiki/MacOS) | [x86](https://de.wikipedia.org/wiki/X86-Prozessor) | 64 bit | `.jnilib` |
| [macOS](https://de.wikipedia.org/wiki/MacOS) | [PowerPC](https://de.wikipedia.org/wiki/PowerPC) | 32 bit | `.jnilib` |
| [macOS](https://de.wikipedia.org/wiki/MacOS) | [PowerPC](https://de.wikipedia.org/wiki/PowerPC) | 64 bit | `.jnilib` |
| [Solaris](https://de.wikipedia.org/wiki/Solaris_(Betriebssystem)) | [x86](https://de.wikipedia.org/wiki/X86-Prozessor) | 32 bit | `.so` |
| [Solaris](https://de.wikipedia.org/wiki/Solaris_(Betriebssystem)) | [x86](https://de.wikipedia.org/wiki/X86-Prozessor) | 64 bit | `.so` |
| [Windows](https://de.wikipedia.org/wiki/Microsoft_Windows) | [x86](https://de.wikipedia.org/wiki/X86-Prozessor) | 32 bit | `.dll` |
| [Windows](https://de.wikipedia.org/wiki/Microsoft_Windows) | [x86](https://de.wikipedia.org/wiki/X86-Prozessor) | 64 bit | `.dll` |

## Projekt
Mit den gelernten Hilfsmitteln ist nun ein Temperaturmessgerät zu bauen. Ein analoger Temperatursensor wird an das Sure-Board angeschlossen und mit Hilfe des *Modbus-Protokolls* sollen die Daten an den Computer übertragen werden. Anschließend sind die ermessenen Werte auf dem Computer-Bildschirm zu visualisieren.
