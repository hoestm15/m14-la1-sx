# Protokoll
  Berger Emil  
  4AHME, Gruppe 1  
  16.01.18  
  Anwesend: Berger, Böcksteiner, Bullner, Ehmann, Enzi, Kobor, Knappitsch  
  Abwesend: niemand  
  
## Makefiles
Wenn ein Quelltext in ein ausführbares Programm übersetzt werden soll, verwenden wir üblicherweise eine **IDE** oder einen oder mehrere Terminal-Commands. Die IDE arbeitet mit Makefiles, die wir in dieser Übung selbst erstellten.

### make
> make (englisch für machen, erstellen) ist ein *Build-Management-Tool*, das Kommandos in Abhängigkeit von Bedingungen ausführt. Es wird hauptsächlich bei der Softwareentwicklung als Programmierwerkzeug eingesetzt.
> Genutzt wird es beispielsweise, um in Projekten, die aus vielen verschiedenen Dateien mit Quellcode bestehen, **automatisiert alle Arbeitsschritte** (Übersetzung, Linken, Dateien kopieren etc.) **zu steuern**, bis hin zum fertigen, ausführbaren Programm. make ist jedoch so flexibel ausgelegt, dass es auch beliebige andere Aufgaben steuern kann, bei denen die zeitliche Abhängigkeit von Dateien eine Rolle spielt.
> Das Hilfsprogramm make ist Teil des POSIX-Standards, dessen gegenwärtige Bezeichnung **IEEE Std 1003.1, 2008 Edition** lautet (äquivalent dazu Single UNIX Specification V3, SUSv3).
 
*Quelle: [Wikipedia, make](https://de.wikipedia.org/wiki/Make)

Zusammengefasst bedeutet dies, dass Makefiles eine Liste von Terminal-Commands zur Übersetzung von Programmen sind, aber nur ausgeführt werden, wenn bestimmte Bedingungen erfüllt sind. Diese werden dann automatisiert abgearbeitet. Es ist lauffähig auf allen **UNIX-basierten Betriebssystemen** (alle Linux-Distributionen & macOS).

### Syntax von Makefiles
```
Target 1: Dependencies
[tab]  Command 1
[tab]  Command 2
[tab]  Command n

Target 2: Dependencies
[tab]  Command 1
[tab]  Command 2
[tab]  Command n
```

### `make` aufrufen
Über das Terminal-Kommando `make` wird eine Makefile durchlaufen und alle Commands in Abhängikeit der dependencies durchlaufen um das Ziel/die Ziele (targets) zu erreichen. Sollte ein Fehler auftreten wird der gesamte Vorgang abgebrochen. Jede erstellte Datei wird mit einem *Zeitstempel* versehen. `make` vergleicht vor dem Durchlauf die Zeitstempel und entscheidet dann, ob es notwendig ist, die Commands zu durchlaufen, weil eine Makefile so effektiv wie möglich arbeiten will.

### Zeitstempel
Ich möchte aus einer `main.c` eine `main.o` erstellen. Beim ersten Mal werden die Commands für das erstellen der `main.o` durchlaufen, da sie noch nicht vorhanden ist. Beim nächsten Mal überprüft `make` die Zeitstempel. Wenn `main.o` aktuell ist, sprich einen 'neueren' Zeitstempel als `main.c` hat, wird `main.o` nicht erneut erstellt. Sollte sich `main.c` aber in der Zwischenzeit geändert haben, ist der Zeitstempel der `main.c` aktueller und die `main.o` muss erneut erstellt werden.

## Übungen mit Makefiles

### Übung 1: Übersetzen eine C-Programms mit Hilfe eines Makefiles
Die erste Übung bestand daraus, ein C-Programm für den Arduino Nano (Prozessor: Atmel ATmega 328p) mittels einer Makefile zu übersetzen. Hierfür erstellten wir ein uns bereits aus dem *FIVU*-Unterricht bekanntes Programm: Die LED am Arduino blinken lassen.

#### Syntax
```c
#define F_CPU 16000000L //Taktfrequenz des ATmega 328p

#include <avr/io.h>
#include <util/delay.h>

int main()
{
  DDRB = (1 << PB5);
  while (1)
  {
    PORTB ^= (1 << PB5);
    _delay_ms(500);
  }
  return 0;
}
```

#### Makefile
```
all: build

build: main.hex

cleanandbuild: clean build

prog: main.hex
	avrdude -c usbasp -p atmega328p -e -U flash:w:main.hex:i
	touch prog

main.hex: main.elf
	avr-objcopy -O ihex main.elf main.hex

main.elf: main.o
	avr-gcc -mmcu=atmega328p -Os -o main.elf main.o

main.o: main.c
	avr-gcc -mmcu=atmega328p -Os -c main.c

clean:
	-rm main.o
	-rm main.elf
	-rm main.hex
```

#### Die Einzelnen Schritte im Detail
| Syntax | Kommentar |
|:------:| --------- |
| `all: build` | Kann mit `make all` aufgerufen werden |
| `build: main.hex` | Kann mit `make build` aufgerufen werden |
| `cleanandbuild: clean build` | Führt zuerst ein `clean` und dann ein `build` aus |
| `prog: main.hex` | Mit dem `avrdude`-Command wird das Programm auf den Arduino Nano programmiert |
| `main.hex: main.elf` | Die gelinkte Datei wird in eine Hex-Datei umcodiert |
| `main.elf: main.o` | Dieser Schritt wird Linker genannt. Es werden die nötigen Adressen vergeben und die Hardware (ATmega 328p) bekanntgegeben |
| `main.o: main.c` | Das C-Programm wird in Maschinenbefehle übersetzt (Assembler) |
| `clean: ` | Alle erstellten Dateien (außer `main.c`!!) werden gelöscht |

> Das `-` vor dem command `rm` wird benötigt um einen einen Abbruch der des Ablaufes zu verhindern. MIt dem `-` werden Dateien, die gelöscht werden sollen, aber nicht vorhanden sind, ignoriert.

#### Aufruf `make`
| Command | Vorgang |
|:-------:| ------- |
| `make` | Alle Arbeitsschritte werden durchlaufen, wenn sie benötigt werden (siehe Punkt *Zeitstempel*) |
| | *Es können auch einzelnen Arbeitsschritte aufgerufen werden:* |
| `make clean` | Alle *generierten* Dateien werden gelöscht |
| `make main.o` | Das C-Programm wird nur in Maschinencode übersetzt, eine Assembler-Datei wird erstellt |
| `make main.elf` | `main.o` wird gelinkt (wenn keine vorhanden ist, wird eine erstellt, da `main.elf` von `main.o` abhängig ist |
| | usw. |

### Übung 2: Zusammenführen zweier C-Dateien mit Hilfe einer Makefile
In der zweiten Übung erstellten wir für das Blinken die Funktion `toggleLED();`, die in der Datei `util.c` **definiert** wurde. Um sie aber in der `main.c` aufrufen zu können muss sie dort **deklariert** werden. Dies geschieht mit der **Header-Datei** `util.h`.

#### Syntax `main.c`
```c
#define F_CPU 16000000L
#include <avr/io.h>
#include <util/delay.h>
#include "util.h"

int main () {
  DDRB = (1<<PB5);

  while (1) {
    toggleLED();
    _delay_ms(500);
    }

  return 0;
}
```

#### Syntax `util.c`
```c
#include <avr/io.h>

void toggleLED() {
    PORTB ^= (1<<PB5);
}
```

#### Syntax `util.h`
```c
#ifndef UTIL_H
#define UTIL_H

void toggleLED ();

#endif
```

#### Makefile
```
all: build

build: main.hex

cleanandbuild: clean build

prog: main.hex
	avrdude -c usbasp -p atmega328p -e -U flash:w:main.hex:i
	touch prog

main.hex: main.elf
	avr-objcopy -O ihex main.elf main.hex

main.elf: main.o util.o
	avr-gcc -mmcu=atmega328p -o main.elf main.o util.o

main.o: main.c util.h
	avr-gcc -mmcu=atmega328p -Os -c main.c

util.o: util.c
	avr-gcc -mmcu=atmega328p -Os -c util.c


clean:
	-rm main.o
	-rm util.o
	-rm main.elf
	-rm main.hex
```

#### Die Einzelnen Schritte im Detail
| Syntax | Kommentar |
|:------:| --------- |
| `all: build` | Kann mit `make all` aufgerufen werden |
| `build: main.hex` | Kann mit `make build` aufgerufen werden |
| `cleanandbuild: clean build` | Führt zuerst ein `clean` und dann ein `build` aus |
| `prog: main.hex` | Mit dem `avrdude`-Command wird das Programm auf den Arduino Nano programmiert |
| `main.hex: main.elf` | Die gelinkte Datei wird in eine Hex-Datei umcodiert |
| `main.elf: main.o util.o` | Die beiden Programme werden zusammengeführt |
| `main.o: main.c util.h` | `main.c` wird in Assembler übersetzt |
| `util.o: util.c` | `util.c` wird in Assembler übersetzt |
| `clean: ` | Alle erstellten Dateien (außer `main.c`, `util.c` und `util.h`!!) werden gelöscht |

## Einzelnachweise
  [Dateien Übung 1]() 
  [Dateien Übung 2]()  
