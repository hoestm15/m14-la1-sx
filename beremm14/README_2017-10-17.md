# Protokoll
  Berger Emil  
  4AHME, Gruppe 1  
  17.10.2017  
  Anwesend: Berger, Böcksteiner, Bullner, Ehmann, Enzi, Kobor, Knappitsch  
  Abwesend: niemand  

## Atmel Studio
Atmel Studio ist eine Entwicklungsumgebung, die die Firma **Atmel** zur Verfügung stellt.
Die IDE ist optimiert für die Entwicklung von Programmen für die hauseigenen Chips, aber auch für die Simulation der Mikrocontroller.

Mit Atmel Studio kann man die Ausführung eines Programms auf einem Atmel-Mikrokontroller simulieren. Man erhält detaillierte Informationen über die Maschinenbefehle, die aus dem Quellcode kompiliert wurden. Außerdem hat man Einblick in die Register des Controllers.

Atmel Studio wurde in *Microsoft Visual Studio* programmiert, daher ist die Software nur für Microsoft **Windows**-betriebene Systeme verfügbar.
Allein für die Prgrammierung gibt es aber Alternativen, wie das uns bekannte *NetBeans*, oder die *Arduino IDE*. Beide sind für **Linux** und Apples **OS X** ebenfalls verfügbar.

  [Website Atmel](http://www.atmel.com)  
  [Website Atmel Studio 7](http://www.atmel.com/microsite/atmel-studio/)  
  [Website Netbeans](https://netbeans.org)  
  [Website Arduino IDE](https://www.arduino.cc/en/main/software#)  

### ATmega328p
  Am Anfang des Jahres bestellten wir uns den Mikrocontroller ATmega328p von Atmel.  
  Daher wählten wir in Atmel Studio den **ATmega328**, weil der **ATmega328p** nicht verfügbar war.  
  
#### Pinbelegung des ATmega328p:
  ![ATmega328p Pins](/beremm14/atmega328w_pinout.png)
  > Quelle: https://www.jayconsystems.com/media/wysiwyg/atmega328w_pinout.png


#### Produktdaten:
- 16MHz Mikroprozessor
- 32kB Flash-Speicher
- 32 Register
- 2kB SRAM
- 1kB EEPROM

##### XYZ-Register:
Um einen Wert größer als 255 zu speichern, gibt es beim ATmega328p die XYZ-Register.
Diese setzen sich so zusammen:
- X = 26 & 27
- Y = 28 & 29
- Z = 30 & 31

## Stack
Im Stack werden Daten nach dem Last-in-first-out (LIFO) Verfahren gespeichert. Sprich, die Daten werden von unten nach oben abgelegt, gelesen werden kann aber immer nur von oben nach unten. Um in den Stack zu speichern, bzw. daraus zu lesen gibt es folgende Operationen:
- push: "Legt" die Daten auf den Stapel"
- pop: Liest das oberste Objekt aus und entfernt es aus dem Stack
- peek: Liest das oberste Objekt aus, aber belässt es auf dem Stapel

### Stackpointer
Der Stackpointer zeigt auf den *nächsten freien Platz* im Stack-Speicher. Zeigt er auf den untersten Platz, ist der Stack leer. In unserem Fall wäre dies der Wert `08FF`. Zeigt der Stackpointer über den für den Stack reservierten Platz hinaus, spricht man vom **Stackoverflow**.

#### Aufbau des SRAM im Atmega 16
  ![SRAM](/beremm14/speicherverwaltung_svg.svg)
  > Quelle: [FIVU Skriptum](https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&m=view#189503049), © DI Steiner Manfred

## Übung
In Atmel Studio wurde folgender Code erstellt:
```c
int main ()
{
return 0;
}
```

  Atmel Studio lieferte uns darauf die kompilierten Maschinenbefehle aus dem Code.  
  
  Aus dem [Instruction Set Manual](http://www.atmel.com/images/Atmel-0856-AVR-Instruction-Set-Manual.pdf) suchten wir die Beschreibung der für den Code benötigten Maschinenbefehle heraus.  
  
  #### Die wichtigsten Maschinenbefehle:
  Maschinenbefehl | Ausführung
  --------------- | ----------
  RJMP | Springt zu an einem anderen Ort gelisteten Maschinenbefehl
  CLR R1 | Das Register R1 wird mit sich selbst XOR verknüpft --> daraus folgt, es wird mit Nullen überschrieben
  OUT 0x3F, R1 | *0x3F --> Statusregister* Status-Flagregister wird auf '0' gesetzt
  SER R28 | setzt R28 auf '0xFF'
  CDI R29, 0x08 | *CDI --> lädt Konstante in Register 16-31* 0x08 wird in Register 29 geladen. Dadurch, dass R28 auf 0xFF und R29 auf 0x08 gesetzt wird, wird das Y-Register '0x08FF'
  OUT 0x3E, R29 | 
  OUT 0x3D, R29 | Dadurch wird der Stackpointer auf '08FF' gesetzt, das bedeutet er ist leer. *08FF ist der unterste Speicherplatz des Stacks.*

## Assembler
  > Eine Assemblersprache ist eine hardwarenahe Programmiersprache. Für verschiedene Computertypen gibt es jeweils eine spezielle, auf den Befehlssatz des Prozessors, Mikrocontrollers, digitalen Signalprozessors oder anderweitig programmierbaren Geräts zugeschnittene Assemblersprache. Von den Maschinensprachen unterscheiden sie sich dadurch, dass anstelle eines für den Menschen schwer verständlichen Binärcodes die Befehle und deren Operanden durch leichter verständliche mnemonische Symbole in Textform (z. B. „MOVE“), Operanden (u. a. auch) als symbolische Adressen (z. B. „PLZ“), notiert und dargestellt werden.  
  Mehr dazu: [Wiki](https://de.wikipedia.org/wiki/Assemblersprache)  
  *Quelle: Wikipedia*  
