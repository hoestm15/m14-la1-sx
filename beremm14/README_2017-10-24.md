# Protokoll
  Berger Emil  
  4AHME, Gruppe 1  
  24.10.2017  
  Anwesend: Berger, Böcksteiner, Bullner, Ehmann, Enzi, Kobor, Knappitsch  
  Abwesend: niemand  

## Stundenwiederholung
Am Anfang der dritten Einheit wiederholten wir den Stoff der zweiten Einheit:
- Besprochene Assembler-Befehle
- Atmel Studio
- Aufbau eines Mikroprozessors (ATmega328p)
Genauere Informationen sind im [Protokoll der zweiten Einheit](/beremm14/README_2017-10-17.md) zu finden.

## Assembler
In der letzten Einheit schrieben wir folgendes einfaches C-Programm:
```c
int main ()
{
return 0;
}
```
  Anschließend gingen wir die für die Programmausführung benötigten Maschinenbefehle durch.  
  *Genauere Ausführung im [Protokoll der zweiten Einheit](/beremm14/README_2017-10-17.md).*  
  In der heutigen Einheit haben wir dies fortgeführt:

### Informationen vor dem Übungsbeginn
#### Volatile
  Wir verwenden vor den Variablen das Schlüsselwort `volatile` um genaue Informationen zur Variablenerstellung zu erhalten.  
  Sollte dieses Schlüsselwort nicht gesetzt werden, bleibt uns jegliche Einsicht im Assembler verwehrt. 

#### unsigned char
  `unsigned char` verwenden wir um mit 1 Byte vorzeichenunbehaftete Zahlen zwischen 0 und 255 darstellen zu können.  
  `char` oder `signed char` sind vorzeichenbehaftet.

### Variable
#### Quellcode
```c
int main (void)
{
	volatile unsigned char x;
	x = 12;
	
	return x;
}
```
  Das Programm wurde gestartet und im Degugging-Modus aufgerufen.  
  Anschließend öffneten wir über den Disassambly-Modus die Übersicht über die Maschinenbefehle.  

#### Assembler
Maschinenbefehl | in Worten | Kommentar
--------------- | --------- | ---------
`cf.93` | PUSH R28 | Register R28 wird auf den Stack gelegt.
`df.93` | PUSH R29 | Register R29 wird auf den Stack gelegt.
`1f.92` | PUSH R1 | Register R1 wird auf den Stack gelegt. *Register R1 ist immer "0", es wird auf dem Stack der Speicher für die lokale Variable reserviert.*
`cd.b7` | IN R28,0x3D | 0x3D wird aus dem I/O-Register in R28 geladen.
`de.b7` | IN R29,0x3E | 0x3E wird aus dem I/O-Register in R29 geladen.
`8c.e0` | LDI R24,0x0C | Konstante (0C = 12) wird im Register R24 abgelegt.
`89.83` | STD Y+1,R24 | Konstante aus R24 wird am Speicherplatz des Stacks der lokalen Variable abgelegt. *R28 & R29 beschreiben das Y-Register. Da die Variable genau nach dem Y-Register auf den Stack gelegt wurde, ist die Adresse im Stack "Y+1"* Die Variable wird gespeichert.
`89.81` | LDD R24,Y+1 | Die Variable wird in Register R24 geladen.
`90.e0` | LDI R25,0x00 | Rückgabewert
`0f.90` | POP R0 | Variable wird freigegeben.
`df.91` | POP R29 | Register R29 wird vom Stack entfernt.
`cf.91` | POP R28 | Register R28 wird vom Stack entfernt. *(R29 muss zuerst enfernt werden, da im Stack nur von oben nach unten gelesen werden kann. Gespeichert kann hingegen nur von unten nach oben werden. Weiteres ist ebenfalls im [Protokoll der zweiten Einheit](/beremm14/README_2017-10-17.md) zu finden.)*

### Addition
#### Quellcode:
```c
int main (void)
{
	volatile unsigned char a = 12;
	volatile unsigned char b = 8;
	
	return a+b;
}
```
  Das Programm wurde gestartet und im Degugging-Modus aufgerufen.  
  Anschließend öffneten wir über den Disassambly-Modus die Übersicht über die Maschinenbefehle.  

#### Assembler
Maschinenbefehl | in Worten | Kommentar
--------------- | --------- | ---------
`cf.93` | PUSH R28 | Register R28 wird auf den Stack gelegt.
`df.93` | PUSH R29 | Register R29 wird auf den Stack gelegt.
`00.d0` | RCALL PC+0x0001 | Springt zum nächsten Befehl. *Durch den RCALL werden 2 Bytes auf dem Stack reserviert, die für die Variablen a & b verwendet werden.*
`cd.b7` | IN R28,0x3D | 0x3D wird aus dem I/O-Register in R28 geladen.
`de.b7` | IN R29,0x3E | 0x3E wird aus dem I/O-Register in R29 geladen.
`8c.c0` | LDI R24,0x0C | Konstante (0C = 12) wird im Register R24 abgelegt.
`89.83` | STD Y+1,R24 | Konstante aus R24 wird am Speicherplatz des Stacks der ersten lokalen Variable (a) abgelegt.
`88.e0` | LDI R24,0x08 | Konstante (08 = 8) wird im Register R24 abgelegt.
`89.83` | STD Y+2,R24 | Konstante aus R24 wird am Speicherplatz des Stacks der zweiten lokalen Variable (b) abgelegt.
`89.81` | LDD R24,Y+1 | Variable a wird in Register R24 geladen.
`2a.81` | LDD R18,Y+2 | Variable b wird in Register R18 geladen.
`30.e0` | LDI R19, 0x00 | Konstante 0x00 wird am Register R19 abgelegt.
`28.0f` | ADD R18,R24 | Die beiden Register werden addiert, ohne Berücksichtigung des Carry-Flags. Das Endergebnis wird in R18 gespeichert.
`31.1d` | ADC R19,R1 | Addition mit Berücksichtigung des Carry-Flags. *Das Carry-Flag enthält den Übertrag einer Addition. [Weitere Informationen](https://de.wikipedia.org/wiki/Übertragsbit)
`0f.90` | POP R0 | Variable b wird freigegeben.
`0f.90` | POP R0 | Variable a wird freigegeben.
`df.91` | POP R29 | Register R29 wird vom Stack entfernt.
`cf.91` | POP R28 | Register R28 wird vom Stack entfernt.

