# Protokoll
  Berger Emil  
  4AHME, Gruppe 1  
  17.04.18  
  Anwesend: Berger, Bullner, Böcksteiner, Ehmann, Enzi, Kobor, Knappitsch  
  Abwesend: Niemand
  
## Wiederholung: JNI/JSSC (Nachtrag)

### Java Native Interface ([JNI](https://de.wikipedia.org/wiki/Java_Native_Interface))
> Java Native Interface (JNI) ist eine standardisierte **Anwendungsprogrammierschnittstelle** (API), die die Möglichkeit schafft, aus der Programmiersprache Java heraus Plattform-spezifische Funktionen bzw. Methoden aufzurufen.
Im Gegensatz zu gewöhnlichen Java-Programmen ist ein Java-Programm, das JNI-Aufrufe verwendet, nur dann plattformunabhängig, wenn die native **Programmbibliothek auf allen Plattformen verfügbar ist**. <

> JNI ermöglicht es, native Methoden zu schreiben für Situationen, in denen es **nicht möglich ist**, **ausschließlich Java** als Programmiersprache einzusetzen. Dies ist der Fall, wenn beispielsweise die Standard-Java-Klassenbibliothek bestimmte Plattform-abhängige Features oder andere Programmbibliotheken nicht unterstützt. Weiterhin ist es per JNI möglich, eine weitere **in einer anderen Programmiersprache programmierte Anwendung für Java zugreifbar zu machen**. Viele Klassen der Java-Standardbibliothek basieren auf JNI, um beispielsweise die Datei-Ein- und Ausgabe oder Soundwiedergabe zu ermöglichen. Indem Java Leistungs- und Plattform-abhängige Implementierungen in die Standardbibliothek integriert, kann der Java-Programmierer und -Nutzer diese Features in sicherer und Plattform-unabhängiger Weise nutzen. <

> Gelegentlich wird JNI als **Fluchttür** ("escape hatch") für Java-Entwickler bezeichnet, da es ihnen den Zugriff auf Funktionalitäten ermöglicht, der andernfalls über die Standard-Java-API nicht möglich wäre. Es stellt die Schnittstelle zu anderen Programmiersprachen wie C oder C++ dar. <

*Quelle: [Wikipedia](https://de.wikipedia.org/wiki/Java_Native_Interface)*

![JNI Symbolbild](https://github.com/HTLMechatronics/m14-la1-sx/blob/Beremm14/beremm14/IMG_0613.jpg)
*Quelle: Mitschrift, Emil Berger*

Dieses Bild symbolisiert die Aufgabe des JNI im Falle unseres Projekts.

### Java Simple Serial Connector ([JSSC](https://code.google.com/archive/p/java-simple-serial-connector/))
  Die *jssc.jar* ist eine Bibliothek, die es ermöglicht, in Java serielle Kommunikation zu ermöglichen.  
  Diese Bibliothek muss mit einem Programm mitgeliefert werden um die *plattformunabhängigkeit* zu gewährleisten.

#### Programmbibliotheken
| Betriebssystem | Architektur | Wortbreite | Kürzel |
|:--------------:|:-----------:|:----------:|:------:|
| [Linux](https://de.wikipedia.org/wiki/Linux) | [x86](https://de.wikipedia.org/wiki/X86-Prozessor) | 32 bit | `.so` |
| [Linux](https://de.wikipedia.org/wiki/Linux) | [x86](https://de.wikipedia.org/wiki/X86-Prozessor) | 64 bit | `.so` |
| [Linux](https://de.wikipedia.org/wiki/Linux) | [ARM](https://de.wikipedia.org/wiki/ARM-Architektur) | 32 bit | `.so` |
| [macOS](https://de.wikipedia.org/wiki/MacOS) | [x86](https://de.wikipedia.org/wiki/X86-Prozessor) | 32 bit | `.jnilib` |
| [macOS](https://de.wikipedia.org/wiki/MacOS) | [x86](https://de.wikipedia.org/wiki/X86-Prozessor) | 64 bit | `.jnilib` |
| [macOS](https://de.wikipedia.org/wiki/MacOS) | [PowerPC](https://de.wikipedia.org/wiki/PowerPC) | 32 bit | `.jnilib` |
| [macOS](https://de.wikipedia.org/wiki/MacOS) | [PowerPC](https://de.wikipedia.org/wiki/PowerPC) | 64 bit | `.jnilib` |
| [Solaris](https://de.wikipedia.org/wiki/Solaris_(Betriebssystem)) | [x86](https://de.wikipedia.org/wiki/X86-Prozessor) | 32 bit | `.so` |
| [Solaris](https://de.wikipedia.org/wiki/Solaris_(Betriebssystem)) | [x86](https://de.wikipedia.org/wiki/X86-Prozessor) | 64 bit | `.so` |
| [Windows](https://de.wikipedia.org/wiki/Microsoft_Windows) | [x86](https://de.wikipedia.org/wiki/X86-Prozessor) | 32 bit | `.dll` |
| [Windows](https://de.wikipedia.org/wiki/Microsoft_Windows) | [x86](https://de.wikipedia.org/wiki/X86-Prozessor) | 64 bit | `.dll` |

  Für jedes Betriebssystem (Linux, macOS, Windows) und jeden dazugehörigen Kernel (X86, ARM, PowerPC) muss eine eigene Bibliothek mitgeliefert werden.  
  Eine sehr gute Zusammenfassung, beziehungsweise Erklärung findet man auf dieser Website: [Wikibooks (ENG)](https://en.wikibooks.org/wiki/Serial_Programming/Serial_Java)  

## Fortführung des Projekts
In der letzten Einheit haben wir das Projekt [Temperaturmessung](https://github.com/beremm14/Temperaturmessung_sure) begonnen und folgende Klassen erstellt:
  * Konstruktor
  * `showThrowable()`
  * `updateSwingControls()`
  * `refreshPorts()`
  * `connectPort()`
  * `disconnectPort()`
  
Bis jetzt kann unser Programm die am Computer verfügbaren Ports durchsuchen, das Sure-Board erkennen, sich mit dem Board verbinden und die Verbindung wieder trennen.

## Änderungen/Vervollständigungen verhandener Klassen

### `connectPort()`
```java
private void connectPort(String port) {
        serialPort = new jssc.SerialPort(port);
        try {
            if (serialPort.openPort() == false) {
                throw new jssc.SerialPortException(port, "openPort", "return value false");
            }
            if (serialPort.setParams(SerialPort.BAUDRATE_57600, SerialPort.DATABITS_8,
                    SerialPort.STOPBITS_2, SerialPort.PARITY_NONE) == false) {
                throw new jssc.SerialPortException(port, "setParams", "return value false");
            }
        } catch (Throwable ex)
        {
            showThrowable(new Exception("Serielle Schnittstelle kann nicht geöffnet werden", ex));
            serialPort = null;
        } finally {
            updateSwingControls();
        }
    }
```
Die Methode connectPort() wurde um die benötigten Parameter für die serielle Schnittstelle erweitert. Zusätzlich wurde über jede Methode eine IF-Klausel gelegt, die im Falle eines Fehlers eine `jssc.SerialPortException();` wirft.

| Parameter | Beschreibung |
| --------- | ------------ |
| SerialPort.BAUDRATE_57600 | Legt die Baudrate fest |
| SerialPort.DATABITS_8 | Legt die Anzahl der Databits fest |
| SerialPort.STOPBITS_2 | Legt die Anzahl der Stoppbits fest |
| SerialPort.PARITY_NONE | Legt fest, ob eine EVEN, ODD oder keine Parity besteht |

Alle Variablen (SerialPort.xxx) können in einer Liste des NetBeans-Assistenten ausgewählt werden, es wird empfohlen diese auch bei INT-Werten, wie zB. der Baudrate zu nutzen.

### Crashkurs [FIVU](https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/55D00BDA8A0D0.symlink?resource_id=0-237409750&m=view#205311307)

| Parameter | Beschreibung |
| --------- | ------------ |
| [Baudrate](https://de.wikipedia.org/wiki/Symbolrate) | Die Baudrate gibt die Anzahl der übertragenen "Symbole" (pro Zeitspanne T) an. Bei einem [Leitungscode](https://de.wikipedia.org/wiki/Leitungscode) ist ein Symbol oft größer als ein Bit, somit ist die Bitrate höher als die Baudrate. |
| Databits | Anzahl der in einem Paket enthaltenen Bits die Daten übertragen |
| Stopbits | Anzahl der Bits, die nach den Daten gesendet werden um dem Empfänger zu signalisieren, dass das Paket zu Ende ist |
| [Parity/Paritätsbit](https://de.wikipedia.org/wiki/Paritätsbit) | Das Paritätsbit dient dazu um Datenübertragungsfehler zu erkennen. EVEN (eng. für "gerade") und ODD (eng. für ungerade) geben an, ob die Anzahl der "HIGH"-Bits gerade oder ungerade ist. Sollte auf Grund der vorhandenen Daten die Anzahl falsch sein, wird das Paritätsbit als Ergänzungsbit eingefügt. Wenn also ein Client ein Paket empfängt, dass EVEN sein sollte, aber die Anzahl der Bits falsch ist, kann das Paket sofort als fehlerhaft identifiziert werden. |

### `updateSwingControls()`
```java
private void updateSwingControls() {
        jbutRefresh.setEnabled(true);
        jbutConnect.setEnabled(false);
        jbutDisconnect.setEnabled(false);
        jcbSerialDevice.setEnabled(false);
        jbutSingleMeasurement.setEnabled(false);
        jbutContinousMeasurement.setEnabled(false);
        jbutStopMeasurement.setEnabled(false);

        if (serialPort != null && serialPort.isOpened()) {
            jbutRefresh.setEnabled(false);
            jbutDisconnect.setEnabled(true);
            jbutConnect.setEnabled(false);
            jbutSingleMeasurement.setEnabled(true);
            return;
        }

        if (jcbSerialDevice.getModel().getSize() > 0) {
            jcbSerialDevice.setEnabled(true);
            jbutConnect.setEnabled(true);
        }

        if (activeWorker != null) {
            jbutRefresh.setEnabled(false);
            jbutConnect.setEnabled(false);
            jbutDisconnect.setEnabled(false);
            jcbSerialDevice.setEnabled(false);
            jbutSingleMeasurement.setEnabled(false);
            jbutContinousMeasurement.setEnabled(false);
            jbutStopMeasurement.setEnabled(false);
            jlaTemperatur.setEnabled(false);
            setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
        } else {
            setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
            jlaTemperatur.setEnabled(true);
        }
    }
```
  updateSwingControls() wurde um eine weitere IF-Klausel erweitert: `if (activeWorker != null) { }`  
  Dies deaktiviert die GUI während der Messung und stellt den Cursor auf *WAIT*.  
  ![macOS Wait Cursor](https://github.com/HTLMechatronics/m14-la1-sx/blob/Beremm14/beremm14/elcapitan-beachball.gif)  
  Der **WAIT-Cursor** ist das Spinning-Wheel in verschiedenen Ausführungen, bzw. bei älteren Windows-Versionen die Sanduhr.  

## Neue Klassenvariablen
```java
private SwingWorker activeWorker;
```
Diese Variable muss eine Klassenvariable sein, da wir in `updateSwingControls()` erkennen können möchten, ob gerade ein Worker aktiv ist, oder nicht. (Das Gleiche gilt für die Variable serialPort)

## Neue Methoden
```java
private void singleMeasurement() {
        activeWorker = new MySingleMeasurementWorker(serialPort);
        activeWorker.execute();
        updateSwingControls();
    }
```
singleMeasurement() startet den SwingWorker in Abhängigkeit vom geöffneten Port. Bei folgendem Event wird sie aufgerufen:
```java
private void jbutSingleMeasurementActionPerformed(java.awt.event.ActionEvent evt) {                                                          
      singleMeasurement();
  }   
```

## [SwingWorker](https://en.wikipedia.org/wiki/SwingWorker)

### Mutitasking
[Mitschrift Multitasking - AIIT](https://github.com/HTLMechatronics/m14-la1-sx/blob/Beremm14/beremm14/Multitasking.pdf)
Da ein Computer heutzutage mehrere Prozessorkerne besitzt, ist es sinnvoll belastende Aufgaben an einen anderen Prozessorkern auszulagern. Somit wird reales Multitasking möglich.

### Methoden des [SwingWorker](https://en.wikipedia.org/wiki/SwingWorker)

| Methode | Klasse | Beschreibung |
| ------- | ------ | ------------ |
| `doInBackground()` | Worker-Klasse | Alle Befehle in dieser Methode werden im zweiten [Thread](https://de.wikipedia.org/wiki/Thread_(Informatik)) ausgeführt. |
| `publish()` | Worker-Klasse | Hierdurch kann mit dem Haupt-Thread kommuniziert werden. |
| `process()` | Innere Klasse | Aufgaben im ersten Thread während der Worker arbeitet |
| `get()` | Innere Klasse | Rückgabewert von `doInBackground()` |
| `done()` | Innere Klasse | Befehlsabarbeitung unmittelbar nach `doInBackground()` |
| `execute()` | *über Objekt aufgerufen* | Startet den Worker |

### Erstellte Klassen

#### Worker-Klasse
```java
package workers;

import java.util.concurrent.TimeUnit;
import javax.swing.SwingWorker;
import jssc.SerialPort;

/**
 *
 * @author emil
 */
public class SingleMeasurementWorker extends SwingWorker<Double, String> {
    
    private final SerialPort serialPort;

    public SingleMeasurementWorker(SerialPort serialPort) {
        this.serialPort = serialPort;
    }
       
    
    @Override
    protected Double doInBackground() throws Exception {
        
        publish("Einzelmessung gestartet");
        
        //Read LM75: 02 04 00 30 00 01 31 f6 (Modbus-Konfiguration aus README)
        byte [] frame = {0x02, 0x04, 0x00, 0x30, 0x00, 0x01, 0x31, (0xf6-256)};
        //Weil "writeBytes" nur von -128 bis +127 geht.
        
        if (serialPort.writeBytes(frame) == false) {
            throw new Exception("cannot send frame");
        }
                
        TimeUnit.SECONDS.sleep(2);
        byte [] response = serialPort.readBytes();
        System.out.println(response.length);
        byte hb = response[3];
        byte lb = response[4];
        int t = (hb < 0 ? hb+256 : hb) * 256 + (lb < 0 ? lb+256 : lb);
        
        return t/256.0;
    }
    
}
```
Da der Wert die 256 möglichen Werte übersteigen kann, wird die *response* in zwei Bytes aufgeteilt, ein **l**ow**b**yte und ein **h**igh**b**yte. Die Konfigurationen stammen aus der README des Projektes, vom SVN-Server Arnfels.

#### Innere Klasse in `public class SureModbusGui`
```java
private class MySingleMeasurementWorker extends SingleMeasurementWorker {

        public MySingleMeasurementWorker(SerialPort serialPort) {
            super(serialPort);
        }

        @Override
        protected void done() {
            try {
                double temp = get();
                jlaTemperatur.setText(String.format("%.1f °C", temp));
                jtfStatus.setText(null);
            } catch (Exception e) {
                showThrowable(new Exception("Einzemessung gescheitert", e));
            } finally {
                activeWorker = null;
                updateSwingControls();
            }
        }

        @Override
        protected void process(List<String> chunks) {
            jtfStatus.setText(chunks.get(chunks.size()-1)); //String aus Publish
        }
        
    }
```
Die gemessenen Werte werden über `get()` vom Worker gelesen und in das Label geschrieben. Mit process wird der Text aus `publish()` in das Status-Textfeld geschrieben.
