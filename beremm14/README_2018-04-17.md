# Protokoll
  Berger Emil  
  4AHME, Gruppe 1  
  30.01.18  
  Anwesend: Berger, Bullner, Böcksteiner, Ehmann, Enzi, Kobor, Knappitsch  
  Abwesend: Niemand

## Fortführung des Projekts
In der letzten Einheit haben wir das Projekt [Temperaturmessung](https://github.com/beremm14/Temperaturmessung_sure) begonnen und folgende Klassen erstellt:
  * Konstruktor
  * `showThrowable()`
  * `updateSwingControls()`
  * `refreshPorts()`
  * `connectPort()`
  * `disconnectPort()`
  
Bis jetzt kann unser Programm die am Computer verfügbaren Ports durchsuchen, das Sure-Board erkennen, sich mit dem Board verbinden und die Verbindung wieder trennen.

## Änderungen/Vervollständigungen verhandener Klassen

### `connectPort()`
```java
private void connectPort(String port) {
        serialPort = new jssc.SerialPort(port);
        try {
            if (serialPort.openPort() == false) {
                throw new jssc.SerialPortException(port, "openPort", "return value false");
            }
            if (serialPort.setParams(SerialPort.BAUDRATE_57600, SerialPort.DATABITS_8,
                    SerialPort.STOPBITS_2, SerialPort.PARITY_NONE) == false) {
                throw new jssc.SerialPortException(port, "setParams", "return value false");
            }
        } catch (Throwable ex)
        {
            showThrowable(new Exception("Serielle Schnittstelle kann nicht geöffnet werden", ex));
            serialPort = null;
        } finally {
            updateSwingControls();
        }
    }
```
Die Methode connectPort() wurde um die benötigten Parameter für die serielle Schnittstelle erweitert. Zusätzlich wurde über jede Methode eine IF-Klausel gelegt, die im Falle eines Fehlers eine `jssc.SerialPortException();` wirft.

| Parameter | Beschreibung |
| --------- | ------------ |
| SerialPort.BAUDRATE_57600 | Legt die Baudrate fest |
| SerialPort.DATABITS_8 | Legt die Anzahl der Databits fest |
| SerialPort.STOPBITS_2 | Legt die Anzahl der Stoppbits fest |
| SerialPort.PARITY_NONE | Legt fest, ob eine EVEN, ODD oder keine Parity besteht |

Alle Variablen (SerialPort.xxx) können in einer Liste des NetBeans-Assistenten ausgewählt werden, es wird empfohlen diese auch bei INT-Werten, wie zB. der Baudrate zu nutzen.

### Crashkurs FIVU

| Parameter | Beschreibung |
| --------- | ------------ |
| [Baudrate](https://de.wikipedia.org/wiki/Symbolrate) | Die Baudrate gibt die Anzahl der übertragenen "Symbole" an. Bei einem [Leitungscode](https://de.wikipedia.org/wiki/Leitungscode) ist ein Symbol oft größer als ein Bit, somit ist die Bitrate höher als die Baudrate. |
| Databits | Anzahl der in einem Paket enthaltenen Bits die Daten übertragen |
| Stopbits | Anzahl der Bits, die nach den Daten gesendet werden um dem Empfänger zu signalisieren, dass das Paket zu Ende ist |
| [Parity/Paritätsbit](https://de.wikipedia.org/wiki/Paritätsbit) | Das Paritätsbit dient dazu um Datenübertragungsfehler zu erkennen. EVEN (eng. für "gerade") und ODD (eng. für ungerade) geben an, ob die Anzahl der "HIGH"-Bits gerade oder ungerade ist. Sollte auf Grund der vorhandenen Daten die Anzahl falsch sein, wird das Paritätsbit als Ergänzungsbit eingefügt. Wenn also ein Client ein Paket empfängt, dass EVEN sein sollte, aber die Anzahl der Bits falsch ist, kann das Paket sofort als fehlerhaft identifiziert werden. |

### `updateSwingControls()`
```java
private void updateSwingControls() {
        jbutRefresh.setEnabled(true);
        jbutConnect.setEnabled(false);
        jbutDisconnect.setEnabled(false);
        jcbSerialDevice.setEnabled(false);
        jbutSingleMeasurement.setEnabled(false);
        jbutContinousMeasurement.setEnabled(false);
        jbutStopMeasurement.setEnabled(false);

        if (serialPort != null && serialPort.isOpened()) {
            jbutRefresh.setEnabled(false);
            jbutDisconnect.setEnabled(true);
            jbutConnect.setEnabled(false);
            jbutSingleMeasurement.setEnabled(true);
            return;
        }

        if (jcbSerialDevice.getModel().getSize() > 0) {
            jcbSerialDevice.setEnabled(true);
            jbutConnect.setEnabled(true);
        }

        if (activeWorker != null) {
            jbutRefresh.setEnabled(false);
            jbutConnect.setEnabled(false);
            jbutDisconnect.setEnabled(false);
            jcbSerialDevice.setEnabled(false);
            jbutSingleMeasurement.setEnabled(false);
            jbutContinousMeasurement.setEnabled(false);
            jbutStopMeasurement.setEnabled(false);
            jlaTemperatur.setEnabled(false);
            setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
        } else {
            setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
            jlaTemperatur.setEnabled(true);
        }
    }
```
  updateSwingControls() wurde um eine weitere IF-Klausel erweitert: `if (activeWorker != null) { }`  
  Dies deaktiviert die GUI während der Messung und stellt den Cursor auf *WAIT*.  
  ![macOS Wait Cursor](https://upload.wikimedia.org/wikipedia/commons/7/7e/OS_X_10.11_Beta_Beach_Ball.jpg)  
  Der **WAIT-Cursor** ist das Spinning-Wheel in verschiedenen Ausführungen, bzw. bei älteren Windows-Versionen die Sanduhr.  

## Neue Klassenvariablen
```java
private SwingWorker activeWorker;
```
Diese Variable muss eine Klassenvariable sein, da wir in `updateSwingControls()` erkennen können möchten, ob gerade ein Worker aktiv ist, oder nicht. (Das Gleiche gilt für die Variable serialPort)

## Neue Methoden
```java
private void singleMeasurement() {
        activeWorker = new MySingleMeasurementWorker(serialPort);
        activeWorker.execute();
        updateSwingControls();
    }
```
singleMeasurement() startet den SwingWorker in Abhängigkeit vom geöffneten Port. Bei folgendem Event wird sie aufgerufen:
```java
private void jbutSingleMeasurementActionPerformed(java.awt.event.ActionEvent evt) {                                                          
      singleMeasurement();
  }   
```

## [SwingWorker](https://en.wikipedia.org/wiki/SwingWorker)

### Mutitasking
[Mitschrift Multitasking - AIIT](https://github.com/HTLMechatronics/m14-la1-sx/blob/Beremm14/beremm14/Multitasking.pdf)
Da ein Computer heutzutage mehrere Prozessorkerne besitzt, ist es sinnvoll belastende Aufgaben an einen anderen Prozessorkern auszulagern. Somit wird reales Multitasking möglich.

### Methoden des [SwingWorker](https://en.wikipedia.org/wiki/SwingWorker)

| Methode | Klasse | Beschreibung |
| ------- | ------ | ------------ |
| `doInBackground()` | Worker-Klasse | Alle Befehle in dieser Methode werden im zweiten [Thread](https://de.wikipedia.org/wiki/Thread_(Informatik)) ausgeführt. |
| `publish()` | Worker-Klasse | Hierdurch kann mit dem Haupt-Thread kommuniziert werden. |
| `process()` | Innere Klasse | Aufgaben im ersten Thread während der Worker arbeitet |
| `get()` | Innere Klasse | Rückgabewert von `doInBackground()` |
| `done()` | Innere Klasse | Befehlsabarbeitung unmittelbar nach `doInBackground()` |
| `execute()` | *über Objekt aufgerufen* | Startet den Worker |

### Erstellte Klassen

#### Worker-Klasse
```java
package workers;

import java.util.concurrent.TimeUnit;
import javax.swing.SwingWorker;
import jssc.SerialPort;

/**
 *
 * @author emil
 */
public class SingleMeasurementWorker extends SwingWorker<Double, String> {
    
    private final SerialPort serialPort;

    public SingleMeasurementWorker(SerialPort serialPort) {
        this.serialPort = serialPort;
    }
       
    
    @Override
    protected Double doInBackground() throws Exception {
        
        publish("Einzelmessung gestartet");
        
        //Read LM75: 02 04 00 30 00 01 31 f6 (Modbus-Konfiguration aus README)
        byte [] frame = {0x02, 0x04, 0x00, 0x30, 0x00, 0x01, 0x31, (0xf6-256)};
        //Weil "writeBytes" nur von -128 bis +127 geht.
        
        if (serialPort.writeBytes(frame) == false) {
            throw new Exception("cannot send frame");
        }
                
        TimeUnit.SECONDS.sleep(2);
        byte [] response = serialPort.readBytes();
        System.out.println(response.length);
        byte hb = response[3];
        byte lb = response[4];
        int t = (hb < 0 ? hb+256 : hb) * 256 + (lb < 0 ? lb+256 : lb);
        
        return t/256.0;
    }
    
}
```
Da der Wert die 256 möglichen Werte übersteigen kann, wird die *response* in zwei Bytes aufgeteilt, ein **l**ow**b**yte und ein **h**igh**b**yte. Die Konfigurationen stammen aus der README des Projektes, vom SVN-Server Arnfels.

#### Innere Klasse in `public class SureModbusGui`
```java
private class MySingleMeasurementWorker extends SingleMeasurementWorker {

        public MySingleMeasurementWorker(SerialPort serialPort) {
            super(serialPort);
        }

        @Override
        protected void done() {
            try {
                double temp = get();
                jlaTemperatur.setText(String.format("%.1f °C", temp));
                jtfStatus.setText(null);
            } catch (Exception e) {
                showThrowable(new Exception("Einzemessung gescheitert", e));
            } finally {
                activeWorker = null;
                updateSwingControls();
            }
        }

        @Override
        protected void process(List<String> chunks) {
            jtfStatus.setText(chunks.get(chunks.size()-1)); //String aus Publish
        }
        
    }
```
Die gemessenen Werte werden über `get()` vom Worker gelesen und in das Label geschrieben. Mit process wird der Text aus `publish()` in das Status-Textfeld geschrieben.
