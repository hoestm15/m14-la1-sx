Protokoll 7

Datum: 17.04.2018
Abwesend: Niemand

## Thema: Javaschnittstellen und Weiterführung des Projektes Temperaturmessung

### Java Native Interface

Das JNI ist eine Java-Bibliothek, in der plattform-, oder schnittstellenabhängige Methoden implementiert sind, wenn eine Verbindung mit den klassischen Java-Bibliotheken nicht möglich ist. Wie zB.: mit einem Gerät(Microcontroller etc.), dass man in einer anderen Sprache als Java programmieren muss.

### Bisherige Stand Temperaturmessung

In der vorherigen Einheit wurden bisher folgende Javamethoden erstellt:

* updateSwingControlls
* showThrowable
* refreshPorts
* connectPort
* disconnectPorts

### Vollendung bestehender Methoden

#### connectPort

Es wurden die Parameter für die serielle Schnittstelle(Bautrate, Datenbits, Parity-Bit, Stopbit) angegeben und if-Anweisungen um beim Auftritt eines Fehlers eine jssc.SerialPortException zu werfen.
```
 private void connectPort(String port) {
             serialPort = new jssc.SerialPort(port);
            try {
            if (serialPort.openPort() == false) {
                throw new jssc.SerialPortException(port, "openPort", "return value false");
            }
            if (serialPort.setParams(SerialPort.BAUDRATE_57600, SerialPort.DATABITS_8,
                    SerialPort.STOPBITS_2, SerialPort.PARITY_NONE) == false) {
                throw new jssc.SerialPortException(port, "setParams", "return value false");
            }
        } catch (Throwable ex) 
        {
            showThrowable(new Exception("Serielle Schnittstelle kann nicht geöffnet werden", ex));
            serialPort = null;
        } finally { 
            updateSwingControls();
        }
    }
```

    
#### updateSwingControls
    
Diese Klasse wurde mit einer weiteren if-Klausel ausgestattet, in der die GUI während der Messung deaktiviert und der Mauszeiger zum WAIT wechselt.
```   
private void updateSwingControls() {
        
        jbutRefresh.setEnabled(true);
        jbutConnect.setEnabled(false);
        jbutDisconnect.setEnabled(false);
        jcbSerialDevice.setEnabled(false);
        jbutSingleMeasurement.setEnabled(false);
        jbutContinousMeasurement.setEnabled(false);
        jbutStopMeasurement.setEnabled(false);

        if (serialPort != null && serialPort.isOpened()) {
            jbutRefresh.setEnabled(false);
            jbutDisconnect.setEnabled(true);
            jbutConnect.setEnabled(false);
            jbutSingleMeasurement.setEnabled(true);
            return;  //Damit er nicht unten durchfährt
        }

        if (jcbSerialDevice.getModel().getSize() > 0) {
            jcbSerialDevice.setEnabled(true);
            jbutConnect.setEnabled(true);
        }
        
        if (activeWorker != null) {
          jbutConnect.setEnabled(false);
          jbutContinousMeasurement.setEnabled(false);
          jbutDisconnect.setEnabled(false);
          jbutRefresh.setEnabled(false);
          jbutSingleMeasurement.setEnabled(false);
          jbutStopMeasurement.setEnabled(false);
          jcbSerialDevice.setEnabled(false);
          setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
        } else {
          setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
          jlaTemperatur.setEnabled(true);
        }
    }
```

### Erstellung des SwingWorkers

#### Swingworker

Swingworker werden für das sogenannte Multi-Threading verwendet. Das bedeutet, dass aufwendige Berechnungen in einen anderen Thread ausgeführt werden, um zB. die GUI eines Programmes weiterhin reaktionsfähig zu halten. Ansonsten würde dieser rechenleistungslastige Programmpfad die GUI unbenutzbar machen, bis alle Berechnungen abgeschlossen wurden. Siehe auch [Multithreading](https://de.wikipedia.org/wiki/Multithreading)

#### Workerklasse

In dieser Klasse wird die eigentliche Workerarbeit in der doinBackground-Methode ausgeführt. Zudem ist eine publish-Methode vorhanden, mit der man Zwischenergebnisse ausgeben kann.
```
package workers;

import java.util.concurrent.TimeUnit;
import javax.swing.SwingWorker;
import jssc.SerialPort;

public class SingleMeasurementWorker extends SwingWorker<Double, String> 
{
    
    private final SerialPort serialPort;

    public SingleMeasurementWorker(SerialPort serialPort) 
    {
        this.serialPort = serialPort;
    }
       
    
    @Override
    protected Double doInBackground() throws Exception 
    {
        
        publish("Einzelmessung gestartet");
        
        //Read LM75: 02 04 00 30 00 01 31 f6 (Modbus-Konfiguration aus README)
        byte [] frame = {0x02, 0x04, 0x00, 0x30, 0x00, 0x01, 0x31, (0xf6-256)};
        //Weil "writeBytes" nur von -128 bis +127 geht.
        
        if (serialPort.writeBytes(frame) == false) 
        {
            throw new Exception("cannot send frame");
        }
                
        TimeUnit.SECONDS.sleep(2);
        byte [] response = serialPort.readBytes();
        System.out.println(response.length);
        byte hb = response[3];
        byte lb = response[4];
        int t = (hb < 0 ? hb+256 : hb) * 256 + (lb < 0 ? lb+256 : lb);
        
        return t/256.0;
    }
    
}
```

#### Innere Klasse MySingleMeasurementWorker

In dieser Klasse werden die gemessenen Werte aus der Workerklasse in der GUI ausgegeben, und durch die process-Methode auch die Zwischenergebnisse, die von der publish-Methode ausgegeben werden.

```
  private class MySingleMeasurementWorker extends SingleMeasurementWorker {

    public MySingleMeasurementWorker (SerialPort serialPort)
    {
      super(serialPort);
    }

    @Override
    protected void done ()
    {
       try
      {
        double temp = get();
        jlaTemperatur.setText(String.format("%.lf C", temp));
        jtfStatus.setText(null);
      }
      catch (Exception e)
      {
        showThrowable(new Exception("Einzelmessung gescheitert", e));
        jtfStatus.setText("Fehler aufgetreten");
      } finally {
         activeWorker = null;
         updateSwingControls();
       }
    }
    
    @Override
    protected void process (List<String> chunks)
    {
      jtfStatus.setText(chunks.get(chunks.size()-1));
    } 
  }
```

