# *Protokoll:* Julian Ehmann  

## **5. Einheit: Modbus**  
 Name: Julian Ehmann  
 Klasse: 4AHME  
 Datum: 23.01.2018  
 Anwesend: Berger Emil, Bullner Jeremy, Böcksteiner Jakob, Ehmann Julian, Enzi Gert, Kobor Markus, Knappitsch Robert
 Abwesend: -
 
## Besprechung der neuen Aufgabenstellung: Temperatursensor
Aufgabenstellung: Es war ein Java-Programm aus dem Repository in die Entwicklungsumgebung zu laden, 
welches die Werte eines analogen Temperatursensors, der über das Sureboard ausgewertet wird, angezeigt. 
Zu Beginn der Übung müssen wir jedoch eine Methode zum Datenaustausch auswählen und festlegen.
Dazu wird ein Feldbusprotokoll benötigt welches festlegt, wie und wohin die Daten übertragen werden.
Aufgrund der leichten Verständlichkeit haben wir **Modbus** verwendet.



## Modbus
Grundsätzlich verwendet man das Modbus-Protokoll um zwischen SPS'en zu kommunizieren, mitlerweile wird es hauptsächlich in der Industrie
verwendet. Grund dafür ist, dass es kostenfrei verfügbar ist und RS-232, RS-485 und TCP/IP kompartible.
Über den Modbus können *Master* und einer oder mehrere *Slaves* miteinander kommunizieren.
In diesem Bus-System muss jeder Teilnehmer eine nicht verwechselbare Adresse haben. Hierbei ist allerdings zu beachten, dass die Adresse 0
bereits für den Broadcast vorbestimmt ist. Alle Bus-Systemteilnehmer können Daten austauschen, werden aber vom Master geregelt.

![] (https://github.com/HTLMechatronics/m14-la1-sx/blob/ehmjum14/ehmjum14/modbus_communication_stack_png.png)

### Textuelles Bild zur Veranschaulichung
*Master*...versendet Request  
*Slave*....liefert Response  
Dieser simple Vorgang beschreibt den Modbus eigentlich ziemlich gut, 
da er nach dem Request/Response Prinzip funktioniert.

Hierbei gibt es 3 Varianten zum Datenaustausch:  
* Modbus TCP   (per TCP Paketen)  
* Modbus RTU   (binär)  
* Modbus ACSII (textuell)

Das Model mit dem die Kommunikation stattfindet laute *Server/Client* Prinzip. 
Beispiel: PC1 (*Client*) sendet eine Request an einen beliebigen PC2, Sensor oder Aktor (*Server*). 
Der PC1(Client) erhält vom PC2(Server) eine Response.


## Modbus Daten-Model

* Input Register   = 16 Bit Wert, der nur gelesen werden kann (z.B. Temperatursensor).    
* Holding Register = 16 Bit Wert, der gelesen und beschrieben werden kann.
* Discrete Inputs  = Nur ein Bit, dass nur gelesen werden kann (z.B. Taster).    
* Coils            = Nur ein Bit, dass gelesen und beschrieben werden kann (z.B. LED).     
![](https://github.com/HTLMechatronics/m14-la1-sx/blob/ehmjum14/ehmjum14/modbus_addressing_model_png.png)  

## Function-Codes

Was sind Function-Codes?
Function-Codes definiern die Bedeutungen meherer Frames.   
Dies wird in drei Kategorien unterteilt:

* User defined Function Codes (65-72, 100-110)                    = Jeder Wert für sich darf verwendet werden.   

* Reserved Function Codes (8,9,10,13,14,41,42,90,91,125,126,127)  = Dies sind Werte,die von Unternehmen für Produkte in Verwendung sind.

* Public Function Codes(Alle Restlichen Werte)                    = Dies sind Werte, die von der Modbus.org community festgelegt werden.   

## **Modbus-Gateway**
Durch den Modbus-Gateway ist es möglich mehrere Modbus Typen miteinander zu verbinden.  

In der *Protocol Data Units* sind Dateien plus Function Code enthalten.  
In der *Application Data Unit* findet man Frame Felder die für die Adressierung plus Fehlererkennung zuständig sind.

