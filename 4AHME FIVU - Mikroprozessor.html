<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0133)https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&m=view#189503049 -->
<html lang="de"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="apple-mobile-web-app-capable" content="yes">
    <title>4AHME FIVU - Mikroprozessor</title>
    <meta name="language" content="en">
    
    <meta name="generator" lang="en" content="OpenACS version 5.9.1b3">
    <link rel="apple-touch-icon-precomposed" href="https://lms.at/resources/lms-theme/img/apple-touch-icon-precomposed.png">
    <link rel="stylesheet" href="./4AHME FIVU - Mikroprozessor_files/jquery-ui.css" type="text/css" media="all">
    <link rel="shortcut icon" href="https://lms.at/resources/lms-theme/img/favicon.ico">
    <link rel="stylesheet" href="./4AHME FIVU - Mikroprozessor_files/lms-forms.css" type="text/css" media="all">
    <link rel="stylesheet" href="./4AHME FIVU - Mikroprozessor_files/reset-min.css" type="text/css" media="all">
    <link rel="stylesheet" href="./4AHME FIVU - Mikroprozessor_files/grids-min.css" type="text/css" media="all">
    <link rel="stylesheet" href="./4AHME FIVU - Mikroprozessor_files/lms-master.css" type="text/css" media="all">
    <link rel="stylesheet" href="./4AHME FIVU - Mikroprozessor_files/tlf-master.css" type="text/css" media="all">
    <link rel="stylesheet" href="./4AHME FIVU - Mikroprozessor_files/print.css" type="text/css" media="print">
    <link rel="stylesheet" href="./4AHME FIVU - Mikroprozessor_files/screen.css" type="text/css" media="screen">
    <link rel="stylesheet" href="./4AHME FIVU - Mikroprozessor_files/neue-styles.css" type="text/css" media="all">
    <link rel="stylesheet" href="./4AHME FIVU - Mikroprozessor_files/fold.css" type="text/css" media="all">
    <link rel="stylesheet" href="./4AHME FIVU - Mikroprozessor_files/print(1).css" type="text/css" media="print">
    <link rel="stylesheet" href="./4AHME FIVU - Mikroprozessor_files/ipad-portrait.css" media="only screen and (orientation:portrait)">


<!--[if IE 8]>
<style>
#mylms.dropdown>ul>li>a:hover {border:1px solid #ebbcb0;}
#location>ul>li.dropdown>ul>li>a:hover {border:1px solid #ebbcb0;}
#favorites>div.dropdown>ul>li>a:hover {border:1px solid #ebbcb0;}
#appmenu>ul>li.dropdown>ul>li>a:hover {border:1px solid #dbdbdb;}
#ctxm>ul>li>a:hover {border:1px solid #ebebeb;}
</style>
<![endif]-->

   <script type="text/javascript" src="./4AHME FIVU - Mikroprozessor_files/core.js.Download"></script>


   <script type="text/javascript" src="./4AHME FIVU - Mikroprozessor_files/jquery.js.Download"></script>


   <script type="text/javascript" src="./4AHME FIVU - Mikroprozessor_files/utils.js.Download"></script>


   <script type="text/javascript" src="./4AHME FIVU - Mikroprozessor_files/jquery-ui.js.Download"></script>


   <script type="text/javascript" src="./4AHME FIVU - Mikroprozessor_files/lms.js.Download"></script>


   <script type="text/javascript" src="./4AHME FIVU - Mikroprozessor_files/jquery.placeholder.min.js.Download"></script>


   <script type="text/javascript" src="./4AHME FIVU - Mikroprozessor_files/fold.js.Download"></script>


   <script type="text/javascript" src="./4AHME FIVU - Mikroprozessor_files/jquery.touchSwipe.min.js.Download"></script>


   <script type="text/javascript" src="./4AHME FIVU - Mikroprozessor_files/jquery.flash.js.Download"></script>



  <link rel="stylesheet" type="text/css" href="./4AHME FIVU - Mikroprozessor_files/xowiki.css" media="all">
  <link type="text/css" rel="stylesheet" href="./4AHME FIVU - Mikroprozessor_files/menu.css" media="all">
<link type="text/css" rel="stylesheet" href="./4AHME FIVU - Mikroprozessor_files/datatable.css" media="all">
<link type="text/css" rel="stylesheet" href="./4AHME FIVU - Mikroprozessor_files/xolrn1.css" media="all">
<script src="./4AHME FIVU - Mikroprozessor_files/xolrn1.js.Download" type="text/javascript"></script>
<script src="./4AHME FIVU - Mikroprozessor_files/ctxm.js.Download" type="text/javascript"></script>
<script src="./4AHME FIVU - Mikroprozessor_files/utilities.js.Download" type="text/javascript"></script>
<script src="./4AHME FIVU - Mikroprozessor_files/container-min.js.Download" type="text/javascript"></script>
<script src="./4AHME FIVU - Mikroprozessor_files/menu-min.js.Download" type="text/javascript"></script>
<script src="./4AHME FIVU - Mikroprozessor_files/get-http-object.js.Download" type="text/javascript"></script>
<script src="./4AHME FIVU - Mikroprozessor_files/datasource-min.js.Download" type="text/javascript"></script>
<script src="./4AHME FIVU - Mikroprozessor_files/datatable.js.Download" type="text/javascript"></script>
<script src="./4AHME FIVU - Mikroprozessor_files/jquery.jstree.js.Download" type="text/javascript"></script>
<script src="./4AHME FIVU - Mikroprozessor_files/cattree1.js.Download" type="text/javascript"></script>

  
<style type="text/css" id="vakata-stylesheet">#vakata-dragged { display:block; margin:0 0 0 0; padding:4px 4px 4px 24px; position:absolute; top:-2000px; line-height:16px; z-index:10000; } #vakata-contextmenu { display:block; visibility:hidden; left:0; top:-200px; position:absolute; margin:0; padding:0; min-width:180px; background:#ebebeb; border:1px solid silver; z-index:10000; *width:180px; } #vakata-contextmenu ul { min-width:180px; *width:180px; } #vakata-contextmenu ul, #vakata-contextmenu li { margin:0; padding:0; list-style-type:none; display:block; } #vakata-contextmenu li { line-height:20px; min-height:20px; position:relative; padding:0px; } #vakata-contextmenu li a { padding:1px 6px; line-height:17px; display:block; text-decoration:none; margin:1px 1px 0 1px; } #vakata-contextmenu li ins { float:left; width:16px; height:16px; text-decoration:none; margin-right:2px; } #vakata-contextmenu li a:hover, #vakata-contextmenu li.vakata-hover > a { background:gray; color:white; } #vakata-contextmenu li ul { display:none; position:absolute; top:-2px; left:100%; background:#ebebeb; border:1px solid gray; } #vakata-contextmenu .right { right:100%; left:auto; } #vakata-contextmenu .bottom { bottom:-1px; top:auto; } #vakata-contextmenu li.vakata-separator { min-height:0; height:1px; line-height:1px; font-size:1px; overflow:hidden; margin:0 2px; background:silver; /* border-top:1px solid #fefefe; */ padding:0; } </style><style type="text/css" id="jstree-stylesheet">.jstree ul, .jstree li { display:block; margin:0 0 0 0; padding:0 0 0 0; list-style-type:none; } .jstree li { display:block; min-height:18px; line-height:18px; white-space:nowrap; margin-left:18px; min-width:18px; } .jstree-rtl li { margin-left:0; margin-right:18px; } .jstree > ul > li { margin-left:0px; } .jstree-rtl > ul > li { margin-right:0px; } .jstree ins { display:inline-block; text-decoration:none; width:18px; height:18px; margin:0 0 0 0; padding:0; } .jstree a { display:inline-block; line-height:16px; height:16px; color:black; white-space:nowrap; text-decoration:none; padding:1px 2px; margin:0; } .jstree a:focus { outline: none; } .jstree a > ins { height:16px; width:16px; } .jstree a > .jstree-icon { margin-right:3px; } .jstree-rtl a > .jstree-icon { margin-left:3px; margin-right:0; } li.jstree-open > ul { display:block; } li.jstree-closed > ul { display:none; } #vakata-dragged ins { display:block; text-decoration:none; width:16px; height:16px; margin:0 0 0 0; padding:0; position:absolute; top:4px; left:4px;  -moz-border-radius:4px; border-radius:4px; -webkit-border-radius:4px; } #vakata-dragged .jstree-ok { background:green; } #vakata-dragged .jstree-invalid { background:red; } #jstree-marker { padding:0; margin:0; font-size:12px; overflow:hidden; height:12px; width:8px; position:absolute; top:-30px; z-index:10001; background-repeat:no-repeat; display:none; background-color:transparent; text-shadow:1px 1px 1px white; color:black; line-height:10px; } #jstree-marker-line { padding:0; margin:0; line-height:0%; font-size:1px; overflow:hidden; height:1px; width:100px; position:absolute; top:-30px; z-index:10000; background-repeat:no-repeat; display:none; background-color:#456c43;  cursor:pointer; border:1px solid #eeeeee; border-left:0; -moz-box-shadow: 0px 0px 2px #666; -webkit-box-shadow: 0px 0px 2px #666; box-shadow: 0px 0px 2px #666;  -moz-border-radius:1px; border-radius:1px; -webkit-border-radius:1px; }.jstree .jstree-real-checkbox { display:none; } .jstree-themeroller .ui-icon { overflow:visible; } .jstree-themeroller a { padding:0 2px; } .jstree-themeroller .jstree-no-icon { display:none; }.jstree .jstree-wholerow-real { position:relative; z-index:1; } .jstree .jstree-wholerow-real li { cursor:pointer; } .jstree .jstree-wholerow-real a { border-left-color:transparent !important; border-right-color:transparent !important; } .jstree .jstree-wholerow { position:relative; z-index:0; height:0; } .jstree .jstree-wholerow ul, .jstree .jstree-wholerow li { width:100%; } .jstree .jstree-wholerow, .jstree .jstree-wholerow ul, .jstree .jstree-wholerow li, .jstree .jstree-wholerow a { margin:0 !important; padding:0 !important; } .jstree .jstree-wholerow, .jstree .jstree-wholerow ul, .jstree .jstree-wholerow li { background:transparent !important; }.jstree .jstree-wholerow ins, .jstree .jstree-wholerow span, .jstree .jstree-wholerow input { display:none !important; }.jstree .jstree-wholerow a, .jstree .jstree-wholerow a:hover { text-indent:-9999px; !important; width:100%; padding:0 !important; border-right-width:0px !important; border-left-width:0px !important; } .jstree .jstree-wholerow-span { position:absolute; left:0; margin:0px; padding:0; height:18px; border-width:0; padding:0; z-index:0; }</style><link rel="stylesheet" type="text/css" media="all" href="./4AHME FIVU - Mikroprozessor_files/style.css"></head>
<body id="aut">
  


<button id="backFromPrint" class="noprint" style="display:none" onclick="backFromPrint();">Druckansicht verlassen</button>
<!-- Background & Document -->
<div id="ibook-bg"><div id="doc">



<!-- Main -->
<div id="main" class="ibook">

    <!-- Normal Page -->
    <!-- App Menu -->
    
        <div id="appmenu-container">
            <div id="appmenu-title">
                <a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink#0">eBuch</a>
            </div>
            <div id="appmenu">
                <ul>
	
    <li class="dropdown" aria-haspopup="true"><span>Drucken</span><ul><li><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#" onclick="print_ibook();return false;">Alles</a></li><li><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#" onclick="print_ibook_page();return false;">Aktuelle Seite</a></li></ul></li>
	

	<li class="booktitle"><a href="javascript:close_book();"><img src="./4AHME FIVU - Mikroprozessor_files/close_grey.png" style="padding: 0 5px;"></a></li>
	<li class="booktitle appmenu_title"><div id="appmenu-booktoc"><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#start">Mikroprozessor</a>
	  <ul><li id="tocmenu_"><div id="ibook-navi" style="">
		<div id="tax_container" class="jstree jstree-1 jstree-focused jstree-default"><ul><li class="jstree-open jstree-last"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#0" data-id="node188315281" class="ibook-toc"><ins class="jstree-icon">&nbsp;</ins>Inhaltsverzeichnis</a><ul><li class="jstree-open jstree-last"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#188315330" data-id="node188315330" class=""><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1 Mikroprozessor (µP) und CPU</a><ul><li class="jstree-open"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#188315342" data-id="node188315342" class=""><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.1 Steuerwerk</a></li><li class="jstree-open"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#188315363" data-id="node188315363" class=""><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.2 Maschinenbefehle</a></li><li class="jstree-open"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#188315351" data-id="node188315351" class=""><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.3 Rechenwerk und Status-Flags</a></li><li class="jstree-open"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#188395501" data-id="node188395501" class=""><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.4 Mikroprozessorsysteme</a></li><li class="jstree-open"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#188395479" data-id="node188395479" class=""><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.5 Speicher</a></li><li class="jstree-open"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#189566980" data-id="node189566980" class=""><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.6 Der Stack</a></li><li class="jstree-open"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#189537312" data-id="node189537312" class=""><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.7 Assembler</a></li><li class="jstree-open"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#189522806" data-id="node189522806" class=""><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.8 Strukturierte Programmierung in C</a><ul><li class="jstree-open"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#189503049" data-id="node189503049" class="current_page"><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.8.1 Speicherverwaltung</a></li><li class="jstree-open"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#189509994" data-id="node189509994" class="  "><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.8.2 Speicherverwendung in C</a></li><li class="jstree-open jstree-last"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#189570773" data-id="node189570773" class="  "><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.8.3 Die Übersetzung mit make</a></li></ul></li><li class="jstree-open jstree-last"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#188395513" data-id="node188395513" class="  "><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.9 Interrupts</a></li></ul></li></ul></li></ul></div>
		<div class="powered">powered by LMS.at</div>
	  </div></li></ul>
        </div></li>
        <li><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?m=edit">Einstellungen</a></li>
</ul>
            </div>
        </div>
    
    <!-- Content -->
    <div id="ibook-content" class="content ibook_v2"><div id="content-border"><div id="content-shadow">
        <!-- Archived community message -->
        
        <!-- User messages -->
        
        <!-- TLF Learning Resources Old -->
        

<script type="text/javascript" src="./4AHME FIVU - Mikroprozessor_files/jquery.cycle.all.js.Download"></script>
  <script type="text/javascript">
  
var index_link='/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/';
var parent_url = '/mybib/NjYyNDQzMDI=/BC1635719CEDF/856C34CB936B6';
var ibook_url='/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/';
var current_url='/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink';
var package_url='/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/';
var return_url='%2fdotlrn%2fclasses%2finformatik%2f610437.4AHME_FIVU.17_18%2fxolrn%2fEC743ABCF7AB5.symlink';
var close_url='';
var book_id='188315281';
var ibook_p = 1;
var book_admin_p =0;
var BOOK;
$(document).ready(function(){
	if (sessionStorage['return_url_'+book_id] == undefined && !document.referrer.match(/\/register\//)) {
		sessionStorage['return_url_'+book_id] = document.referrer;
	}
	if (window.location.hash.length > 1) {
		BOOK=new IBook(window.location.hash.substr(1));
	} else {
		var current_page = $('#ibook_current_page').val();
		if (current_page > -1) {
		  BOOK=new IBook(current_page);
		  window.location.replace(window.location.href + '#'+current_page);
		} else {
			$('.booktoc').removeClass('booktoc');
			$('#tocmenu_').hide();
			if (ibook_p) {
				$('.dropdown').hide();
			}
		}
		
	}
	/*if (book_admin_p == 1) { 
	 	$('.ibook_item div.book_v2').each(function (){
	 		$(this).sortable({items:'div.emmbedded-book-page-wrapper', handle:'div.ctxmenu', axis:'y', containment:'document', scroll:false, tolerance: "pointer",
				cursor:'move', update:function(e,ui){
				var els = $(this).sortable('serialize',{key:'el'}) + "&m=order";
				$.post(parent_url+'/'+$('#bookpage'+$('#ibook_current_page').val()).attr('parent'), els);
				}
			});
		});
		$("div.emmbedded-book-page-wrapper div.ctxmenu").hide();
		$("div.emmbedded-book-page-wrapper").on("mouseenter", function(){ 
			$("div.emmbedded-book-page-wrapper div.ctxmenu").hide();
			$(this).find("div.ctxmenu").show(); 
		});
		
		$("div.emmbedded-book-page-wrapper").on("mouseleave", function(){ 
			$("div.emmbedded-book-page-wrapper div.ctxmenu").hide();
			$(this).find("div.ctxmenu").hide(); 
		});
	}*/
});
function close_book() {
	var url = sessionStorage['return_url_'+book_id];
	sessionStorage.removeItem('return_url_'+book_id);
	if (url == undefined || url == '') {
		if (close_url == '') {
			url = parent_url;
		} else {
			url = (close_url.charAt(0) != '/' ? package_url : '') + close_url;
		}
	}
	window.location.href = url;
}
</script>


  <div id="ibook-all" class="with-page-scrolling xowiki-content xolrn">
  
<div id="loading" style="display:none;"><img src="./4AHME FIVU - Mikroprozessor_files/loading.gif"></div>
<div id="ibook-top" class="ibook_v2">
<div class="bar2"><div class="porder"></div><table class="ibook-bar"><tbody><tr><td class="btn_prev" onclick="change_page(0);"></td><td><div class="bar1"><hr><div class="book_bar2 ui-draggable" style="position: relative; width: 48.0714px; left: 480.714px;"></div></div></td><td class="btn_next" onclick="change_page(1);"></td></tr></tbody></table></div>


</div>

<div id="ibook" class="ibook_v2">
    <div id="ibook_inner">
    <div class="Form-link_form"><div class="Form-ibook_v2_form"><div class="ibook_v2"><div id="my_pages">
	<div id="bookpage0" class="ibook_item loaded" item_id="0" data-order=" " count="0" name="EC743ABCF7AB5" parent="EC743ABCF7AB5" style="display: none;">
	        <h1>Mikroprozessor</h1>
		<h2>Inhaltsverzeichnis</h2> <br>
		<div id="moveable_tax_container" class="jstree jstree-0 jstree-default"><ul><li class="jstree-open jstree-last"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#0" data-id="node188315281" class="ibook-toc current_page"><ins class="jstree-icon">&nbsp;</ins>Inhaltsverzeichnis</a><ul><li class="jstree-open jstree-last"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#188315330" data-id="node188315330" class="  "><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1 Mikroprozessor (µP) und CPU</a><ul><li class="jstree-open"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#188315342" data-id="node188315342" class="  "><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.1 Steuerwerk</a></li><li class="jstree-open"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#188315363" data-id="node188315363" class="  "><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.2 Maschinenbefehle</a></li><li class="jstree-open"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#188315351" data-id="node188315351" class=""><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.3 Rechenwerk und Status-Flags</a></li><li class="jstree-open"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#188395501" data-id="node188395501" class="  "><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.4 Mikroprozessorsysteme</a></li><li class="jstree-open"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#188395479" data-id="node188395479" class="  "><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.5 Speicher</a></li><li class="jstree-open"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#189566980" data-id="node189566980" class="  "><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.6 Der Stack</a></li><li class="jstree-open"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#189537312" data-id="node189537312" class="  "><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.7 Assembler</a></li><li class="jstree-open"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#189522806" data-id="node189522806" class="  "><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.8 Strukturierte Programmierung in C</a><ul><li class="jstree-open"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#189503049" data-id="node189503049" class="  "><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.8.1 Speicherverwaltung</a></li><li class="jstree-open"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#189509994" data-id="node189509994" class="  "><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.8.2 Speicherverwendung in C</a></li><li class="jstree-open jstree-last"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#189570773" data-id="node189570773" class="  "><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.8.3 Die Übersetzung mit make</a></li></ul></li><li class="jstree-open jstree-last"><ins class="jstree-icon">&nbsp;</ins><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#188395513" data-id="node188395513" class="  "><ins class="jstree-icon" style="background: url(&quot;/resources/xolrn/img/aktiv_inaktiv_startseite.png&quot;) center center no-repeat;">&nbsp;</ins>1.9 Interrupts</a></li></ul></li></ul></li></ul></div>
	</div>
   <div id="bookpage188315330" class="ibook_item   loaded" item_id="188315330" data-order="1" count="1" parent="EC743ABCF7AB5" name="EC743ABCF7AB5/F607FABBC42B3" style="display: none;"><h2>Mikroprozessor (µP) und CPU</h2> <br><div class="Form-bookpage_form"><div class="ipart_v2"><div class="book_v2"><div data-order="1" id="el_188315333" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3> </h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><p>
	Der Mikroprozessor ist die moderne Form des Prozessors, bei dem alle Funktionen eines Prozessors auf einem Microcchip (IC) gefertigt sind.</p>
<p>
	Der <strong>Prozessor</strong> ist eine digitale elektronische Schaltung, welche mit Hilfe übergebener Befehle andere Schaltungsteile steuert. Die heute am häufigsten vorkommenden Prozessoren sind zentrale Recheneinheiten in Computern. Die zentrale Recheneinheit (<u>C</u>entral <u>P</u>rocessor <u>U</u>nit) wird mit <strong>CPU</strong> abgekürzt. Alle real existierenden Teile werden dabei als <strong>Hardware</strong> und die ausgeführten Befehle als <strong>Software</strong> bezeichnet.</p></div>
</div></div><div data-order="2" id="el_188315336" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3>Die Central Processing Unit (CPU)</h3><div class="Form-page_form"><div class="xolrn-page-wrapper">Hauptbestandteile einer CPU sind:
<ul>
	<li>
		<strong>Die Register</strong><br>
		Das sind Speichereinheiten die direkt mit der Recheneinheit verbunden sind. Sie beinhalten Daten, Operanden und Berechnungsergebnisse in Form von Dualzahlen, und haben in der Regel die „Wortgröße“ des Prozessors (8 Bit, 16 Bit, 32 Bit oder 64 Bit). Schaltungstechnisch handelt es sich hier meist um taktflankengesteuerte D-Flip-Flops.<br>
		&nbsp;</li>
	<li>
		<strong>Das Rechenwerk</strong> (die „Arithmetic Logic Unit“ oder kurz ALU)<br>
		Hier handelt es sich um ein digitales Schaltwerk zur Durchführung arithmetisch/logischer Befehle (addieren, subtrahieren, schieben, rotieren, NOT, AND, OR, XOR).<br>
		&nbsp;</li>
	<li>
		<strong>Das Steuerwerk</strong><br>
		Das Steuerwerk ist für die Abarbeitung des Programms verantwortlich. Es arbeitet das Programm (also die Befehlskette) Befehl für Befehl ab. Im Steuerwerk befindet sich der Befehlszähler (Programcounter, Instructionpointer) und der Befehls-Decoder.<br>
		&nbsp;</li>
	<li>
		<strong>Die Speicherverwaltungseinheit</strong><br>
		Diese ist für den Zugriff auf den Arbeitsspeicher verantwortlich. Bei großen Prozessoren ist sie durch eine Memory Manangement Unit (MMU) realisiert. Bei der MMU werden gleiche virtuelle Adressen von unterschiedlichen Prozessen auf unterschiedliche physikalische Adressen im realen Arbeitsspeicher abgebildet, damit sich unterschiedliche Prozesse (Programme) nicht gegenseitig beeinflussen können.</li>
</ul>
<p>
	&nbsp;</p>
<p>
	Das Blockdiagramm im folgenden Bild zeigt den prinzipiellen Aufbau einer CPU, wobei es sich hier nur um eine von vielen denkbaren Ausführungsformen handelt. Es gibt auch Darstellungen in denen sich die Speicherverwaltung zusammen mit einer Ein- und Ausgabeeinheit außerhalb der CPU befindet.</p>
<p>
	<a title="Blockdiagramm einer CPU" description="" href="./4AHME FIVU - Mikroprozessor_files/cpu_svg" class="page_img_188315330">  <img type="wikilink" class="image" src="./4AHME FIVU - Mikroprozessor_files/cpu_svg" alt="Blockdiagramm einer CPU" title="Blockdiagramm einer CPU"></a></p>
<div>
	Der Reset bringt das digitale System CPU in einen definierten Ausgangszustand, der Befehlszähler wird auf die Programmstartadresse - oftmals der Wert 0 - gesetzt, und die Bits im Status-Flag Register und in den Registern werden in einen definierten Grundzustand gesetzt.</div>
<p>
	<br>
	Die Speicherverwaltung greift auf den externen Speicher zu. Dabei sind zwei Design-Prinzipien zu unterscheiden:</p>
<ul>
	<li>
		Bei einer <strong>Von-Neumann-Architektur</strong> sind Befehle und Daten im gleichen Speicher abgelegt. Es reicht daher eine einzige Speicherverwaltung, so wie sie in der oberen Abbildung zu sehen ist.<br>
		&nbsp;</li>
	<li>
		Bei einer <strong>Harvard-Architektur</strong> sind Befehlsspeicher und Datenspeicher physikalisch getrennt. Dadurch lassen sich Datentransfer und Befehlstransfer parallelisieren, und auch der Schutz des Programms vor unbeabsichtigter Zerstörung ist einfacher zu realisieren.</li>
</ul>
<p>
	Befehle, die der Prozessor unmittelbar ausführen kann, werden als <strong>Maschinenbefehl</strong> (auch Maschinencode oder nativer Code) bezeichnet. Diese Befehle sind in Form von Bitketten (Dualzahlen) definiert, und werden normalerweise mit Software-Entwicklungs-Tools aus Assemblerprogrammen oder Programmquelltext einer Hochsprache (zum Beispiel einem C-Quelltext) erzeugt.</p></div>
</div></div>
	    <script type="text/javascript">
		if (book_admin_p == 1) {
			$('.ibook_item div.book_v2').each(function (){
				$(this).sortable({
					items:'div.emmbedded-book-page-wrapper',
					handle:'div.ctxmenu',
					axis:'y',
					containment:'document',
					scroll:false,
					tolerance:'pointer',
					cursor:'move',
					update:function(e,ui){
						var els = $(this).sortable('serialize',{key:'el'}) + '&m=order';
						$.post(parent_url+'/'+$('#bookpage'+$('#ibook_current_page').val()).attr('parent'), els);
					}
				});
			});
			$('div.emmbedded-book-page-wrapper div.ctxmenu').hide();
			$('div.emmbedded-book-page-wrapper').on('mouseenter', function(){
				$(this).find('div.ctxmenu').show();
			});
			$('div.emmbedded-book-page-wrapper').on('mouseleave', function(){
				$('div.emmbedded-book-page-wrapper div.ctxmenu').hide();
			});
		}
	    </script>
	
	<script type="text/javascript" src="./4AHME FIVU - Mikroprozessor_files/jquery.lightbox.js.Download"></script>
	<link type="text/css" href="./4AHME FIVU - Mikroprozessor_files/jquery.lightbox.css" rel="stylesheet">
	<script type="text/javascript">
		$('#bookpage188315330 .emmbedded-book-page-wrapper.page img').each(function() {
        if ($(this).parent().is("a")) {return;}
			$(' <a title="'+$(this).attr('title')+'"  description=""  href="'+$(this).attr('src')+'"  class="page_img_188315330">  </a>  ').insertAfter(this).append(this);
		});
		$('#bookpage188315330 .emmbedded-book-page-wrapper.photo .photo-or-thumb a:first').addClass('page_img_188315330');
		$('#bookpage188315330 .emmbedded-book-page-wrapper.photo-album .photo-show .photo-container .thumbnail a').addClass('page_img_188315330');
		$('a.page_img_188315330').lightBox();
	</script>
    </div></div>
</div><div class="content-chunk-footer"></div>
</div><div id="bookpage188315342" class="ibook_item   loaded" item_id="188315342" data-order="1.1" count="2" parent="EC743ABCF7AB5/F607FABBC42B3" name="EC743ABCF7AB5/F607FABBC42B3/6951DF1117DC8" style="display: none;"><h2>Steuerwerk</h2> <br><div class="Form-bookpage_form"><div class="ipart_v2"><div class="book_v2"><div data-order="1" id="el_188315348" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3>Befehlsabarbeitung</h3><div class="Form-page_form"><div class="xolrn-page-wrapper">Bei einer Von-Neumann-Architektur lässt sich die Befehlsababeitung in Phasen zerlegen, die zeitlich hintereinander ausgeführt werden (Von-Neumann-Zyklus). Der zeitliche Ablauf wird dabei durch das von außen zugeführte Taktsignal (den Clock) bestimmt. Üblicherweise wird bei jeder steigenden Taktflanke eine neue Phase des Von-Neumann-Zyklus ausgeführt.
<ol>
	<li>
		<strong>Phase Fetch</strong><br>
		Das Steuerwerk lädt aus dem Speicher mit Hilfe der&nbsp; Speicherverwaltung den nächsten Befehl.<br>
		Der Wert im Befehls-Zähler dient dabei als Speicheradresse.<br>
		&nbsp;</li>
	<li>
		<strong>Phase Decode</strong><br>
		Der Befehls-Decoder dekodiert den Befehl und erzeugt abhängig vom Maschinencode (Befehlscode) Signale auf den internen Steuerleitungen (in der Abbildung der CPU rot gezeichnet).<br>
		&nbsp;</li>
	<li>
		<strong>Phase Fetch Operands</strong><br>
		Die Operanden der jetzt folgenden Rechenoperation werden ausgewählt und dem Rechenwerk (der ALU) zugeführt.<br>
		&nbsp;</li>
	<li>
		<strong>Phase Execute</strong><br>
		Der Befehl wird ausgeführt.<br>
		&nbsp;</li>
	<li>
		<strong>Update Instruction-Pointer</strong><br>
		Der Befehls-Zähler, auch Instruction-Pointer (IP) oder Programcounter (PC) genannt, wird aktualisiert. Je nach Befehl wird er entweder nur um 1 erhöht, damit der nachfolgenden Befehl ausgeführt wird, oder bei einem Sprungbefehl bekommt der Befehlszähler einen völlig neuen Wert, die Adresse des Sprungziels.</li>
</ol></div>
</div></div><div data-order="2" id="el_188315345" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3>Design-Philosophien</h3><div class="Form-page_form"><div class="xolrn-page-wrapper">Auch bei der Realisierung des Steuerwerks und dem damit verbundenen Befehlsumfang sind zwei unterschiedliche Design-Philosophien&nbsp; anzutreffen:
<ul>
	<li>
		<strong>CISC (Complex Instruction Set Computer)</strong><br>
		Der Prozessor verfügt über viele unterschiedliche Befehle (Complex Instruction Set), wobei für die Abarbeitung eines Befehls im Steuerwerk ein eigener „kleiner Computer“, eine sogenannte Mikroprogrammeinheit eingebaut ist. Der Befehl wird also in eine Reihe sequentiell ablaufender „Microinstructions“ zerlegt, und die Abarbeitung eines Maschinenbefehls dauert viele Taktzyklen. Da es viele Maschinenbefehle gibt, besteht der Maschinenbefehl aus vielen Bits.<br>
		&nbsp;</li>
	<li>
		<strong>RISC (Reduced Instruction Set Computer)</strong><br>
		Der Prozessor versteht nur die nötigsten Befehle (Reduced Instruction Set), dafür ist keine Mikroprogrammeinheit erforderlich und die Befehlsexekution (Phase Execute) kann in einem Taktschritt erfolgen. Da es nur wenige Maschinenbefehle gibt, sind verglichen zur CISC-Philosophie weniger Bits pro Maschinenbefehl erforderlich.</li>
</ul>
Heutige Prozessoren sind meist nach der RISC Philosophie realisiert, so auch der Atmega CPU Core. Solche Prozessoren sind sehr schnell. Bei komplexere Operationen, wie zum Beispiel die Division zweier Zahlen, oder die Verschiebung von Bits um viele Stellen muss der Compiler allerdings viele Maschinenbefehle vorsehen.</div>
</div></div>
	    <script type="text/javascript">
		if (book_admin_p == 1) {
			$('.ibook_item div.book_v2').each(function (){
				$(this).sortable({
					items:'div.emmbedded-book-page-wrapper',
					handle:'div.ctxmenu',
					axis:'y',
					containment:'document',
					scroll:false,
					tolerance:'pointer',
					cursor:'move',
					update:function(e,ui){
						var els = $(this).sortable('serialize',{key:'el'}) + '&m=order';
						$.post(parent_url+'/'+$('#bookpage'+$('#ibook_current_page').val()).attr('parent'), els);
					}
				});
			});
			$('div.emmbedded-book-page-wrapper div.ctxmenu').hide();
			$('div.emmbedded-book-page-wrapper').on('mouseenter', function(){
				$(this).find('div.ctxmenu').show();
			});
			$('div.emmbedded-book-page-wrapper').on('mouseleave', function(){
				$('div.emmbedded-book-page-wrapper div.ctxmenu').hide();
			});
		}
	    </script>
	
	<script type="text/javascript" src="./4AHME FIVU - Mikroprozessor_files/jquery.lightbox.js.Download"></script>
	<link type="text/css" href="./4AHME FIVU - Mikroprozessor_files/jquery.lightbox.css" rel="stylesheet">
	<script type="text/javascript">
		$('#bookpage188315342 .emmbedded-book-page-wrapper.page img').each(function() {
        if ($(this).parent().is("a")) {return;}
			$(' <a title="'+$(this).attr('title')+'"  description=""  href="'+$(this).attr('src')+'"  class="page_img_188315342">  </a>  ').insertAfter(this).append(this);
		});
		$('#bookpage188315342 .emmbedded-book-page-wrapper.photo .photo-or-thumb a:first').addClass('page_img_188315342');
		$('#bookpage188315342 .emmbedded-book-page-wrapper.photo-album .photo-show .photo-container .thumbnail a').addClass('page_img_188315342');
		$('a.page_img_188315342').lightBox();
	</script>
    </div></div>
</div><div class="content-chunk-footer"></div>
</div><div id="bookpage188315363" class="ibook_item   loaded" item_id="188315363" data-order="1.2" count="3" parent="EC743ABCF7AB5/F607FABBC42B3" name="EC743ABCF7AB5/F607FABBC42B3/126375B8CAB0F" style="display: none;"><h2>Maschinenbefehle</h2> <br><div class="Form-bookpage_form"><div class="ipart_v2"><div class="book_v2"><div data-order="1" id="el_188315366" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3></h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><p>
	Maschinenbefehle sind Befehle, die der Prozessor unmittelbar ausführen kann. Sie werden auch als <em>„Machinecode“</em>, <em>bytecode</em> oder „<em>native code</em>“ bezeichnet. Jeder Befehl wird als eindeutiges Bitmuster codiert.</p>
<p>
	Beim Atmega µC besteht dieses Bitmuster aus dem Befehlstyp, gefolgt vom Adress- und/oder Datenteil. Da diese&nbsp; Bitmuster für Menschen praktisch unleserlich sind, werden ihnen symbolische Namen, sogenannte <em>Menmonics</em> zugeordnet, mit denen dann auch Assemblerprogramme geschrieben werden, oder in die ein Disassembler ein Maschinenprogramm zurück übersetzt.</p>
<p>
	Ein Prozessor verfügt üblicherweise über die folgenden Maschinenbefehlstypen (die konkreten Mnemonics sind in Großbuchstaben geschrieben und sind dem AVR Instruction Manual entnommen) :</p>
<ul>
	<li>
		<strong>Arithmetische Befehle</strong><br>
		Führen Berechnungen durch (ADD, ADC, SUB, SBC, SUBI, INC, DEC, MUL, MULS, NEG).<br>
		&nbsp;</li>
	<li>
		<strong>Logische Befehle</strong><br>
		Die einzelnen Bits werden logisch bearbeitet (AND, OR, EOR, COM).<br>
		&nbsp;</li>
	<li>
		<strong>Bit-orientierte Befehle</strong><br>
		Mit ihnen können einzelne Bits verändert (BCLR, BSET, CLZ, SEZ, CBI, SBI) oder ganze Bitfelder verschoben (ASR, LSL, LSR, ROL, ROR) werden.<br>
		&nbsp;</li>
	<li>
		<strong>Speicher- und Registerdatentransferbefehle</strong><br>
		Übertragen von Daten (IN, OUT, LDI, LDS, STS, LPM, SPM, MOV, MOVW, XCH, SWAP) und Stack-Datentransfer-Befehle (PUSH,POP).<br>
		&nbsp;</li>
	<li>
		<strong>Vergleichsbefehle</strong><br>
		Vergleich von Werten (CP, CPI, CPC).<br>
		&nbsp;</li>
	<li>
		<strong>Sprungbefehle</strong><br>
		Sprungbefehle dienen zur Änderung des Programmablaufs.<br>
		Es gibt <strong>unbedingte Sprünge</strong> (JMP), <strong>bedingte Sprünge</strong> (BREQ, BRNE, BRGE, BRLT, BRMI, BRPL) und Sprünge mit relativen Sprungzielen (IJMP, RJMP).<br>
		Daneben gibt es auch Funktionsaufrufe bei denen die Rücksprungadresse am Stack gespeichert wird (CALL, ICALL) und Funktionsrücksprung-Befehle (RET).<br>
		&nbsp;</li>
	<li>
		<strong>Sonderbefehle</strong><br>
		Füllbefehl (NOP), Rücksprung aus einer Interrupt-Service Routine (RETI).</li>
</ul>
<p>
	Der Maschinenbefehlssatz variiert je nach Hersteller und Prozessorfamilie. Daher kann das Maschinenprogramm eines Prozessors nicht auf einem anderen Prozessortyp ablaufen.</p>
<p>
	Neben dem Befehlssatz sind auch die Adressierungsarten ein wesentliches Prozessormerkmal.<br>
	Details siehe: <a href="http://de.wikipedia.org/wiki/Adressierung_(Datenverarbeitung)" target="_blank">http://de.wikipedia.org/wiki/Adressierung_(Datenverarbeitung)</a></p>
<p>
	&nbsp;</p></div>
</div></div><div data-order="2" id="el_189537370" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3>Beispiel Maschinenprogramm für den Atmega16</h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><p>
	Der folgende <strong>hexdump</strong> einer Datei zeigt ein Maschinenprogramm für den µC Atmel Atmega16:</p>
<pre>user@linux-pc:~/$ <strong>hexdump -C prog</strong>
00000000  <span style="color:#0000ff;">0c 94 2a 00 0c 94 47 00  0c 94 47 00 0c 94 47 00</span>  |..*...G...G...G.|
00000010  <span style="color:#0000ff;">0c 94 47 00 0c 94 47 00  0c 94 47 00 0c 94 47 00</span>  |..G...G...G...G.|
*
00000050  <span style="color:#0000ff;">0c 94 47 00 11 24 1f be  cf e5 d4 e0 de bf cd bf</span>  |..G..$..........|
00000060  <span style="color:#0000ff;">10 e0 a0 e6 b0 e0 ec e0  f1 e0 02 c0 05 90 0d 92</span>  |................|
00000070  <span style="color:#0000ff;">ac 36 b1 07 d9 f7 20 e0  ac e6 b0 e0 01 c0 1d 92</span>  |.6.... .........|
00000080  <span style="color:#0000ff;">a2 37 b2 07 e1 f7 0e 94  49 00 0c 94 84 00 0c 94</span>  |.7......I.......|
00000090  <span style="color:#0000ff;">00 00 8f e0 8a bb d5 e0  ca e0 db bb cb bb 80 e6</span>  |................|
000000a0  <span style="color:#0000ff;">90 e0 0e 94 54 00 f9 cf  0f 93 1f 93 cf 93 df 93</span>  |....T...........|
000000b0  <span style="color:#0000ff;">e0 91 6e 00 f0 91 6f 00  23 81 21 ff 1b c0 8c 01</span>  |..n...o.#.!.....|
000000c0  <span style="color:#0000ff;">d0 e0 c0 e0 f8 01 81 91  8f 01 60 91 6e 00 70 91</span>  |..........`.n.p.|
000000d0  <span style="color:#0000ff;">6f 00 db 01 18 96 ed 91  fc 91 19 97 88 23 31 f0</span>  |o............#1.|
000000e0  <span style="color:#0000ff;">09 95 89 2b 79 f3 df ef  cf ef ec cf 8a e0 09 95</span>  |...+y...........|
000000f0  <span style="color:#0000ff;">89 2b 19 f0 8f ef 9f ef  02 c0 8d 2f 9c 2f df 91</span>  |.+........././..|
00000100  <span style="color:#0000ff;">cf 91 1f 91 0f 91 08 95  f8 94 ff cf 48 65 6c 6c</span>  |............Hell|
00000110  <span style="color:#0000ff;">6f 20 77 6f 72 6c 64 00</span>                           |o world.|</pre>
<p>
	Das Programm in der Datei <em>prog</em> besteht aus den blau gefärbten Bytes (in der oberen Ausgabe hexadezimal codiert) und umfasst 280 Bytes.</p>
<p>
	Die ersten 4 Bytes Hex <em>0c 94 2a 00</em> stellen den Operatios-Code (<em>Opcode</em>) des Maschinenbefehls&nbsp;<em>JMP</em> dar.</p>
<p>
	Dem AVR Instruction Set Manual lässt sich folgende Information für diesen Befehl entnehmen:</p>
<div>
	<a title="Beschreibung des Maschinenbefehls JMP" description="" href="./4AHME FIVU - Mikroprozessor_files/assembler_jmp_svg" class="page_img_188315363">  <img type="wikilink" class="image" src="./4AHME FIVU - Mikroprozessor_files/assembler_jmp_svg" alt="Beschreibung des Maschinenbefehls JMP" title="Beschreibung des Maschinenbefehls JMP"></a></div>
<p>
	<br>
	Damit lässt sich die Bytefolge 0c 94 2a 00 wie folgt analysieren:</p>
<pre>Programmdatei:
  Hex Bytes:      0    c     9    4     2    a     0    0
  Dual:        0000 1100  1001 0100  0010 1010  0000 0000

Little-Endian Tausch:
  Hex Bytes:      9    4     0    c     0    0     2    a
  Dual:        1001 0100  0000 1100  0000 0000  0010 1010

AVR Instruction Set Manual:
               1001 010k  kkkk 110k  kkkk kkkk  kkkk kkkk

Fertiger Befehl: k = 00 0000 0000 0000 0010 1010b = 0x2a
               JMP Wortadresse 0x2a  
</pre>
<pre>Assemblerbefehl:
               JMP 0x54</pre>
<p>
	Die Little-Endian Notation ist eine Festlegungen des Herstellers. Sie besagt, dass bei 16-Bit Daten das Hi-Byte immer an der niederwertigeren Adresse gespeichert wird.<br>
	Siehe auch:&nbsp;<a href="https://en.wikipedia.org/wiki/Endianness" target="_blank">https://en.wikipedia.org/wiki/Endianness</a></p>
<p>
	Bei der Adress 0x2a handelt es sich um eine Wortadresse. Bei Wortadressen hat jedes Wort (=16 Bit) im Programmspeicher eine eigene Adresse. Die Wortadresse erhöht sich alse alle 16 Bit = 2 Bytes um 1. Auch der Programcounter des Atmega16 speichert nur Wortadressen.</p>
<p>
	Assembler und Disassambler arbeiten in der Regel mit Byte-Adressen. Jedes Byte im Programmspeicher hat eine eigene Adresse. Wortadressen lassen sich einfach in Byte-Adressen umwandeln, indem die Wortadresse mit 2 multipliziert wird.</p>
<p>
	Mit einem Disassambler lässt sich der Maschinencode in lesbaren Assembler übersetzen.</p>
<pre>user@linux-pc:~/$ <strong>avr-objdump -D -b binary -m avr prog</strong>

test.raw: Dateiformat binary
Disassembly of section .data:

00000000 &lt;.data&gt;:
   0:<span class="Apple-tab-span" style="white-space:pre"> </span>0c 94 2a 00 <span class="Apple-tab-span" style="white-space:pre"> </span>jmp<span class="Apple-tab-span" style="white-space:pre"> </span>0x54<span class="Apple-tab-span" style="white-space:pre"> </span>;  0x54
   4:<span class="Apple-tab-span" style="white-space:pre"> </span>0c 94 47 00 <span class="Apple-tab-span" style="white-space:pre"> </span>jmp<span class="Apple-tab-span" style="white-space:pre"> </span>0x8e<span class="Apple-tab-span" style="white-space:pre"> </span>;  0x8e
   ...
</pre>
<p>
	&nbsp;</p></div>
</div></div>
	    <script type="text/javascript">
		if (book_admin_p == 1) {
			$('.ibook_item div.book_v2').each(function (){
				$(this).sortable({
					items:'div.emmbedded-book-page-wrapper',
					handle:'div.ctxmenu',
					axis:'y',
					containment:'document',
					scroll:false,
					tolerance:'pointer',
					cursor:'move',
					update:function(e,ui){
						var els = $(this).sortable('serialize',{key:'el'}) + '&m=order';
						$.post(parent_url+'/'+$('#bookpage'+$('#ibook_current_page').val()).attr('parent'), els);
					}
				});
			});
			$('div.emmbedded-book-page-wrapper div.ctxmenu').hide();
			$('div.emmbedded-book-page-wrapper').on('mouseenter', function(){
				$(this).find('div.ctxmenu').show();
			});
			$('div.emmbedded-book-page-wrapper').on('mouseleave', function(){
				$('div.emmbedded-book-page-wrapper div.ctxmenu').hide();
			});
		}
	    </script>
	
	<script type="text/javascript" src="./4AHME FIVU - Mikroprozessor_files/jquery.lightbox.js.Download"></script>
	<link type="text/css" href="./4AHME FIVU - Mikroprozessor_files/jquery.lightbox.css" rel="stylesheet">
	<script type="text/javascript">
		$('#bookpage188315363 .emmbedded-book-page-wrapper.page img').each(function() {
        if ($(this).parent().is("a")) {return;}
			$(' <a title="'+$(this).attr('title')+'"  description=""  href="'+$(this).attr('src')+'"  class="page_img_188315363">  </a>  ').insertAfter(this).append(this);
		});
		$('#bookpage188315363 .emmbedded-book-page-wrapper.photo .photo-or-thumb a:first').addClass('page_img_188315363');
		$('#bookpage188315363 .emmbedded-book-page-wrapper.photo-album .photo-show .photo-container .thumbnail a').addClass('page_img_188315363');
		$('a.page_img_188315363').lightBox();
	</script>
    </div></div>
</div><div class="content-chunk-footer"></div>
</div><div id="bookpage188315351" class="ibook_item   loaded" item_id="188315351" data-order="1.3" count="4" parent="EC743ABCF7AB5/F607FABBC42B3" name="EC743ABCF7AB5/F607FABBC42B3/2F3C1366817FF" style="display: none;"><h2>Rechenwerk und Status-Flags</h2> <br><div class="Form-bookpage_form"><div class="ipart_v2"><div class="book_v2"><div data-order="1" id="el_188315354" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3>Das Rechwerk (ALU)</h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><p>
	Das Rechenwerk (<em><u>A</u>rithmetic <u>L</u>ogic <u>U</u>nit</em>, kurz <strong>ALU</strong>) ist eine digitale Schaltung (ein Schaltwerk), das logische und arithmetische Operationen ausführt.</p>
<p>
	Dazu zählen:</p>
<ul>
	<li>
		<strong>Addition und Subtraktion</strong><br>
		Zwei Ganzzahlen aus zwei Registern (im Bild der CPU im Block „Register“) können addiert oder subtrahiert werden. Das Ergebnis landet entweder in einem eigenen Register (dem Akkumulator, kurz Accu) oder direkt in einem Allzweck-Register des Steuerwerks.<br>
		&nbsp;</li>
	<li>
		<strong>Schieben und Rotieren</strong><br>
		Die Bits im Akkumulator (oder in einem Allzweck-Register) werden um eine Stelle nach links oder rechts geschoben. Beim Schieben wird auf der einen Seite 0 hinein geschoben, und das auf der anderen Seite heraus geschobene Bit landet im Carry-Flag (ein Bit im Status-Flag-Register). Beim Rotieren wird anstelle der 0 das Carry-Flag hinein geschoben.<br>
		&nbsp;</li>
	<li>
		<strong>Inkrementieren und Dekrementieren</strong><br>
		Der Wert im Akkumulator (oder einem Allzweck-Register) wird um 1 erhöht oder vermindert.<br>
		&nbsp;</li>
	<li>
		<strong>Invertierung (Complement) und Negierung</strong><br>
		Der Wert im Akkumulator (oder einem Allzweck-Register) wird entweder bitweise invertiert oder negiert (das entspricht der Multiplikation einer im Zweierkomplement codierten Dualzahl mit -1).<br>
		&nbsp;</li>
	<li>
		<strong>Logische Operationen</strong><br>
		Zwei Register werden bitweise logisch verknüpft (AND, OR, XOR). Das Ergebnis landet entweder im Akkumulator oder in einem Allzweck-Register.</li>
</ul>
<p>
	&nbsp;</p></div>
</div></div><div data-order="2" id="el_189106946" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3>Die Status-Flags</h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><p>
	Die ALU erzeugt bei der Durchführung einer Rechenoperation auch zusätzliche Statusinformationen, die sich nach der Befehlsausführung im Status-Flag Register befinden. Bei manchen Maschinenbefehlen werden sogar nur „Status-Flags“ erzeugt, während das Ergebnis der Operation nirgendwo gespeichert wird (zum Beispiel bei den Compare-Befehlen CP, CPC oder CPI des Atmega).</p>
<p>
	Folgende Status-Bits (Flags) sind im Status-Flag-Register (<strong>SFR</strong>) einer CPU zu finden:</p>
<ul>
	<li>
		<strong>Das Zero-Flag (Z)</strong><br>
		Es bekommt den Wert 1 wenn das Ergebnis Null ist, ansonsten den Wert 0.<br>
		&nbsp;</li>
	<li>
		<strong>Das Carry-Flag (C)</strong><br>
		Es bekommt den Wert 1 wenn bei der Operation, bei der die Operanden als vorzeichenlose Dualzahl interpretiert werden, ein Überlauf eintritt. Die Anzahl der Bits im Ergebnisregister reicht nicht aus um das Ergebnis vollständig aufzunehmen. Wenn kein Überlauf auftritt, hat das Carry-Flag den Wert 0. Das Carry-Flag wird auch bei Schiebe- und Rotieroperationen verwendet um heraus geschobene Bits aufzunehmen.<br>
		&nbsp;</li>
	<li>
		<strong>Das Overflow-Flag (V)</strong><br>
		Es bekommt den Wert 1 wenn bei der Operation, bei der die Operanden als Dualzahl im Zweierkomplement interpretiert werden, ein Überlauf eintritt. Ansonsten bekommt es den Wert 0.</li>
</ul>
<p>
	<br>
	Mit Hilfe der ALU-Subtraktion und der Status-Flags kann das Steuerwerk Vergleichsoperationen (Compare-Befehle) realisieren. Um zum Beispiel bei Gleichheit zweier Zahlen einen Sprung auszuführen, wird zunächst mit einem Compare-Befehl (CP beim Atmega) eine ALU-Subtraktion durchgeführt. Allerdings werden nur die Status-Flags im Status Register&nbsp; gespeichert. Das Ergebnis der Subtraktion wird nicht gespeichert. Anschließend kann mit einem Sprungbefehl Branch if Equal (BREQ beim Atmega) abhängig vom Wert im Zero-Flag der Sprung durchgeführt werden.</p>
<p>
	<u>Beispiel:</u> (Atmega16):</p>
<table border="0" cellpadding="5" style="border-collapse: separate; border-spacing: 0px; width: 100%;">
	<tbody>
		<tr>
			<td style="padding:5px">
				<pre><strong>int</strong> main ()
{
  <strong>volatile</strong> <strong>char</strong> i = 0;
  <strong>volatile</strong> <strong>char</strong> x;

  <strong>if</strong> (i==0)
    x = 1;
  <strong>else</strong>
    x = 2;
 
  <strong>return</strong> 0;
}</pre>
			</td>
			<td style="padding:5px">
				<pre>main:
    ...
   
    ldd r24,Y+1
    tst r24
    brne .L2
    ldi r24,lo8(1)
    std Y+2,r24
    rjmp .L3
.L2:
    ldi r24,lo8(2)
    std Y+2,r24
.L3:
    ldi r24,0
    ldi r25,0
    
    ...
 
    ret</pre>
			</td>
		</tr>
	</tbody>
</table>
<p>
	Der Assemblerbefehl <em>tst r24</em> weist die ALU an, vom internen Register r24 den Wert 0 zu subtrahieren. Ist das Ergebnis 0, so wird das Z-Flag im SFR gesetzt.</p>
<p>
	Der Befehl <em>brne ...</em> (branch if not equal) springt an die angegebene Adresse wenn das Z-Flag nicht gesetzt ist.</p>
<p>
	Die Kombination aus <em>tst</em> und <em>brne</em> ist daher in diesem Fall die Umsetzung der if-Anweisung in C.<br>
	&nbsp;</p></div>
</div></div>
	    <script type="text/javascript">
		if (book_admin_p == 1) {
			$('.ibook_item div.book_v2').each(function (){
				$(this).sortable({
					items:'div.emmbedded-book-page-wrapper',
					handle:'div.ctxmenu',
					axis:'y',
					containment:'document',
					scroll:false,
					tolerance:'pointer',
					cursor:'move',
					update:function(e,ui){
						var els = $(this).sortable('serialize',{key:'el'}) + '&m=order';
						$.post(parent_url+'/'+$('#bookpage'+$('#ibook_current_page').val()).attr('parent'), els);
					}
				});
			});
			$('div.emmbedded-book-page-wrapper div.ctxmenu').hide();
			$('div.emmbedded-book-page-wrapper').on('mouseenter', function(){
				$(this).find('div.ctxmenu').show();
			});
			$('div.emmbedded-book-page-wrapper').on('mouseleave', function(){
				$('div.emmbedded-book-page-wrapper div.ctxmenu').hide();
			});
		}
	    </script>
	
	<script type="text/javascript" src="./4AHME FIVU - Mikroprozessor_files/jquery.lightbox.js.Download"></script>
	<link type="text/css" href="./4AHME FIVU - Mikroprozessor_files/jquery.lightbox.css" rel="stylesheet">
	<script type="text/javascript">
		$('#bookpage188315351 .emmbedded-book-page-wrapper.page img').each(function() {
        if ($(this).parent().is("a")) {return;}
			$(' <a title="'+$(this).attr('title')+'"  description=""  href="'+$(this).attr('src')+'"  class="page_img_188315351">  </a>  ').insertAfter(this).append(this);
		});
		$('#bookpage188315351 .emmbedded-book-page-wrapper.photo .photo-or-thumb a:first').addClass('page_img_188315351');
		$('#bookpage188315351 .emmbedded-book-page-wrapper.photo-album .photo-show .photo-container .thumbnail a').addClass('page_img_188315351');
		$('a.page_img_188315351').lightBox();
	</script>
    </div></div>
</div><div class="content-chunk-footer"></div>
</div><div id="bookpage188395501" class="ibook_item   loaded" item_id="188395501" data-order="1.4" count="5" parent="EC743ABCF7AB5/F607FABBC42B3" name="EC743ABCF7AB5/F607FABBC42B3/4706E96BC4330" style="display: none;"><h2>Mikroprozessorsysteme</h2> <br><div class="Form-bookpage_form"><div class="ipart_v2"><div class="book_v2"><div data-order="1" id="el_188395504" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3></h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><p>
	Das folgende Bild zeigt den prinzipiellen Aufbau eines Mikroprozessorsystems.</p>
<p>
	<a title="Mikroprozessorsystem" description="" href="./4AHME FIVU - Mikroprozessor_files/mc_system_svg" class="page_img_188395501">  <img type="wikilink" class="image" src="./4AHME FIVU - Mikroprozessor_files/mc_system_svg" alt="Mikroprozessorsystem" title="Mikroprozessorsystem" style="width:  640px;height:  363px;"></a></p>
<p>
	Folgende Komponenten sind erforderlich:</p>
<ul>
	<li>
		<strong>CPU (Central Processing Unit)</strong><br>
		Die zentrale Recheneinheit führt die Software-Befehle aus.<br>
		<br>
		Die CPU muss mit elektrischer Spannung (VCC) versorgt werden. Der Spannungsbereich liegt heute zwischen 1,2 V und 5 V.<br>
		<br>
		Der Reset dient dazu, die CPU beim Start des Systems (zum Beispiel beim Einschalten), in einen definierten Startzustand zu versetzen. Aber auch bei Spannungseinbrüchen unter die Minimalspannung muss eine Resetierung erfolgen, da die korrekte Programmabarbeitung unter der Minimalspannung nicht gewährleistet ist. Interne oder externe Spannungsüberwachungsmodule sorgen für die Generierung des Reset (Brownout- oder Undervoltage-Detection).<br>
		<br>
		Der Takt ist meist ein periodisches rechteckförmiges Spannungssignal, bei dessen steigender Flanke die CPU einen Bearbeitungsschritt durchführt. Daher ist die Arbeitsgeschwindigkeit des Systems direkt proportional der Taktfrequenz. Der Takt kann entweder im Baustein generiert oder von außen zugeführt werden. Dafür eignen sich Taktbausteine, Schwingquarze, Resonatoren, Ringoszillatoren aus digitalen Invertern oder RC-Oszillatoren.<br>
		<br>
		Bei Mikrocontrollern liegt der übliche Frequenzbereich zwischen zwischen 1 MHz und 16 MHz. Frequenzen über 50 MHz sind nicht gebräuchlich, da hier die Entwickler über sehr gute Hochfrequenz-Kenntnisse verfügen müssen. In Sonderfällen sind auch Frequenzen im kHz Bereich in Verwendung (bei leistungsarmen Systemen, da der elektrische Leistungsbedarf linear mit der Taktfrequenz steigt).<br>
		<br>
		Bei manchen Systemen wird mit Hilfe einer <strong>PLL</strong> (<em><u>P</u>hased <u>L</u>ocked <u>L</u>oop</em>) aus einem niederfrequenten Takt (zB 16 MHz) ein hochfrequenter interner Takt (zB. 320 MHz) erzeugt.<br>
		&nbsp;</li>
	<li>
		<strong>Timer</strong><br>
		Bei einem „Timer“ handelt es sich um einen digitalen Zähler, der mit dem Systemtakt betrieben wird, und dessen Zählerstand der CPU bzw. dem Programm zur Verfügung steht. Die zeitliche Genauigkeit hängt somit von der Genauigkeit der Taktfrequenz ab. Daher sind bei der Takterzeugung häufig Quarze oder Resonatoren mit einer Frequenzgenauigkeit von typisch 100ppm (ppm = parts per million = Faktor 0,000001) im Einsatz. Nur in speziellen Fällen sind Sonderlösungen wie Quarzofen oder RTC-Bausteine (<em><u>R</u>eal <u>T</u>ime <u>C</u>lock</em>) erforderlich.<br>
		<br>
		In Prozessrechnern ist ein Timer für die Realisierung von Echtzeitanforderungen unverzichtbar.<br>
		&nbsp;</li>
	<li>
		<strong>Arbeitsspeicher</strong><br>
		Hier liegen alle globalen Variablen eines Programms, der Heap (für die dynamische Speicherverwaltung) und der Stack (für lokale Variable, Funktionsparameter und Rücksprungadressen).<br>
		<br>
		Der Inhalt des Arbeitsspeichers geht normalerweise nach Abschaltung der elektrischen Versorgungsspannung verloren. Man spricht auch von einem <em>flüchtigen Speicher</em>. Es gibt aber auch Sonderlösungen bei denen der Speicherinhalt<br>
		automatisch gesichert und beim Einschalten wiederhergestellt wird (Non Volatile RAM).<br>
		<br>
		Im Mikrocontroller Bereich wird der Arbeitsspeicher normalerweise mit statischen RAM-Bausteinen (<strong>SRAM</strong>) realisiert. Im PC- und Embedded-PC Bereich werden aus Kostengründen dynamische Speicherbausteine (<strong>DRAM</strong>) verwendet.<br>
		&nbsp;</li>
	<li>
		<strong>Programmspeicher</strong><br>
		Im Programmspeicher sind Konstante und das eigentliche Programm, also die Maschinenbefehle, zu finden.<br>
		<br>
		Im PC-Bereich wird der Programmspeicher im DRAM realisiert und über eine MMU (<em><u>M</u>emory <u>M</u>anagement <u>U</u>nit</em>) wird der richtige Zugriff (lesend/schreibend) sichergestellt.<br>
		<br>
		Im Mikrocontrollerbereich ist der Programmspeicher oftmals als eigener ROM, meist als <strong>Flash-Baustein</strong>, realisiert. Ein solcher Flash-Baustein behält auch nach Abschaltung der elektrischen Versorgungsspannung seinen Inhalt und kann während des normalen Betriebs nur gelesen aber nicht beschrieben werden.<br>
		&nbsp;</li>
	<li>
		<strong>I/O</strong> <strong>(<u>I</u>nput/<u>O</u>utput)</strong><br>
		Der I/O-Block umfasst alle Komponenten die zur Ein- und Ausgabe von Signalen erforderlich sind.<br>
		Im Mikrocontrollerbereich ist das im einfachsten Fall ein digitaler Portpin, eine ADC-Einheit zur Erfassung analoger Spannungswerte oder eine Schnittstellen-Einheit (zB für serielle Schnittstelle/UART).<br>
		&nbsp;</li>
	<li>
		<strong>Bussystem</strong><br>
		Bussysteme dienen dazu, dass mehr als zwei Komponenten untereinander Informationen austauschen können. Ein Bus wird aus einer festgelegten Anzahl digitaler Leitungen gebildet.<br>
		<br>
		Die Busleitungen lassen sich wieder in eine der drei Gruppen zuteilen:<br>
		– <strong>Adressbus:</strong> gibt die Adresse (Nummer) der Speicherstelle an.<br>
		– <strong>Datenbus:</strong> Über diese Leitungen werden die Daten transportiert.<br>
		– <strong>Steuerbus:</strong> Leitungen zur Steuerung des Datenaustauschs.<br>
		<br>
		Oft agiert die CPU als Busmaster, das heißt, sie generiert eine Adresse, und schreibt bzw. ließt die Daten über den Datenbus. Manchmal werden die Leitungen des Daten- und Adressbus zusammengefasst. Dann legt eine eigene Steuerleitung (oft mit dem Namen ALE für „<em><u>A</u>ddress <u>L</u>atch <u>E</u>nable</em>“) fest, ob sich bei den Bits auf den Leitungen gerade um eine Adresse oder eine<br>
		Information (Datum) handelt.<br>
		<br>
		Jede Leitung in einem Bussystem darf maximal eine Signalquelle haben. Sind mehrere Signalquellen (Treiber) aktiv, so entstehen unter Umständen fehlerhafte Signalzustände. Es kann also zu einem Buszugriffskonflikt kommen. Ist<br>
		keine Signalquelle aktiv, so floated die Spannung auf der Leitung und es kann sich ebenfalls ein fehlerhafter Signalzustand einstellen. Falls es daher längere Zeitspannen ohne Signalquelle gibt, sollte auf der betroffenen Leitung ein Pull-Up oder Pull-Down Widerstand vorgesehen werden. Zwingend erforderlich ist das für Steuerleitungen.<br>
		<br>
		Bussysteme können zur „Außenwelt“ geführt werden, damit dort weitere Bausteine angeschlossen werden können. Oftmals wird aber das Bussystem nur im System intern realisiert, und externe Bausteine werden über spezielle Schnittstellen wie SPI oder I<sup>2</sup>C angebunden.</li>
</ul>
<p>
	&nbsp;</p></div>
</div></div><div data-order="2" id="el_188395510" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3>DMA (Direct Memory Access)</h3><div class="Form-page_form"><div class="xolrn-page-wrapper">Normalerweise müssen alle Daten über die CPU verarbeitet werden. Das kostet Zeit. Wenn Bausteine und CPU mit einer DMA-Funktion versehen sind, kann ein Baustein kurzfristig die Busmaster-Funktion übernehmen, und direkt mit einem Speicherbaustein - also ohne CPU - kommunizieren.<br>
Ein anderer Lösungsansatz ist der <em>Peripheral Event Controller</em> der Infineon C166er Familie, der einzelne MOV-Befehle für den Datentransfer bei Bedarf automatisch in die Abarbeitung einfügt.</div>
</div></div>
	    <script type="text/javascript">
		if (book_admin_p == 1) {
			$('.ibook_item div.book_v2').each(function (){
				$(this).sortable({
					items:'div.emmbedded-book-page-wrapper',
					handle:'div.ctxmenu',
					axis:'y',
					containment:'document',
					scroll:false,
					tolerance:'pointer',
					cursor:'move',
					update:function(e,ui){
						var els = $(this).sortable('serialize',{key:'el'}) + '&m=order';
						$.post(parent_url+'/'+$('#bookpage'+$('#ibook_current_page').val()).attr('parent'), els);
					}
				});
			});
			$('div.emmbedded-book-page-wrapper div.ctxmenu').hide();
			$('div.emmbedded-book-page-wrapper').on('mouseenter', function(){
				$(this).find('div.ctxmenu').show();
			});
			$('div.emmbedded-book-page-wrapper').on('mouseleave', function(){
				$('div.emmbedded-book-page-wrapper div.ctxmenu').hide();
			});
		}
	    </script>
	
	<script type="text/javascript" src="./4AHME FIVU - Mikroprozessor_files/jquery.lightbox.js.Download"></script>
	<link type="text/css" href="./4AHME FIVU - Mikroprozessor_files/jquery.lightbox.css" rel="stylesheet">
	<script type="text/javascript">
		$('#bookpage188395501 .emmbedded-book-page-wrapper.page img').each(function() {
        if ($(this).parent().is("a")) {return;}
			$(' <a title="'+$(this).attr('title')+'"  description=""  href="'+$(this).attr('src')+'"  class="page_img_188395501">  </a>  ').insertAfter(this).append(this);
		});
		$('#bookpage188395501 .emmbedded-book-page-wrapper.photo .photo-or-thumb a:first').addClass('page_img_188395501');
		$('#bookpage188395501 .emmbedded-book-page-wrapper.photo-album .photo-show .photo-container .thumbnail a').addClass('page_img_188395501');
		$('a.page_img_188395501').lightBox();
	</script>
    </div></div>
</div><div class="content-chunk-footer"></div>
</div><div id="bookpage188395479" class="ibook_item   loaded" item_id="188395479" data-order="1.5" count="6" parent="EC743ABCF7AB5/F607FABBC42B3" name="EC743ABCF7AB5/F607FABBC42B3/F3F1F94EF3E71" style="display: none;"><h2>Speicher</h2> <br><div class="Form-bookpage_form"><div class="ipart_v2"><div class="book_v2"><div data-order="1" id="el_188395482" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3></h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><p>
	<style type="text/css">
li {margin-bottom:7px}	</style>
	Grundsätzlich unterscheiden wir aus Sicht des Programmierers <strong>Arbeitsspeicher</strong> und <strong>Programmspeicher</strong>.</p>
<p>
	Im Programmspeicher ist das eigentliche Programm, also die Maschinenbefehle, zu finden. Der Arbeitsspeicher wird während der Ausführung des Programmes (während der Arbeit) für Variable, Rücksprungadressen, ... benötigt.</p>
<p>
	Ob für diese beiden Speicherarten tatsächlich verschiedene Speicherbausteine (bzw. Technologien) verwendet werden, oder ob diese sich in einem gemeinsamen (physikalischen) Speicher befinden, ist systemabhängig.</p>
<p>
	In einem PC-System (zB x86- oder amd64-Architektur) sind Programm- und Arbeitstspeicher gemeinsam im <em>DRAM</em> (siehe unten) zu finden.</p>
<p>
	Auf einem Atmel 8-Bit µC System ist der Arbeitsspeicher in einem statischen RAM-Modul (<em>SRAM</em>) zu finden, während die Maschinenbefehle in einem <em>FLash</em>&nbsp;abgelegt sind. Beide Speicher befinden sich im µC Baustein.</p>
<p>
	Die Zugriffsgeschwindigkeit auf den Speicher hat maßgeblichen Einfluss auf die Arbeitsgeschwindigkeit des Systems. Daher sind bei schnellen Systemen im Prozessor zusätzlich schnelle Speicher eingebaut, die Daten und Befehle temporär speichern, sogenannte <strong>Cache-Speicher</strong>.</p>
<p>
	Die wichtigsten Merkmale eines Speicherbausteins sind:</p>
<ul>
	<li style="margin-bottom:3px&quot;">
		Typ und Technologie</li>
	<li style="margin-bottom:3px&quot;">
		Speichergröße (wie viele Bits)</li>
	<li style="margin-bottom:3px&quot;">
		Zugriffsgeschwindigkeit</li>
	<li style="margin-bottom:3px&quot;">
		Preis</li>
</ul>
<p>
	&nbsp;</p></div>
</div></div><div data-order="2" id="el_189103433" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3>Speicherarten und Technologien</h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><p>
	<style type="text/css">
li {margin-bottom:7px}	</style>
</p>
<p>
	Es gibt verschiedenste Speicherarten und Technologien:</p>
<ul>
	<li>
		<strong>RAM</strong> (<em><u>R</u>andom <u>A</u>ccess <u>M</u>emory</em>)<br>
		Mit Hilfe einer Adresse kann auf den Speicherinhalt lesend oder schreibend zugegriffen werden.</li>
	<li>
		<strong>ROM </strong>(<em><u>R</u>ead <u>O</u>nly <u>M</u>emory</em>)<br>
		Mit Hilfe einer Adresse wird auf den Speicherinhalt lesend zugegriffen. Der Dateninhalt ist (durch die Herstellung) vorgegeben.</li>
	<li>
		<strong>PROM</strong> (<em><u>P</u>rogrammable </em>ROM)<strong>:</strong><br>
		Programmierbares ROM.</li>
	<li>
		<strong>OTP-ROM</strong> (<em><u>O</u>ne <u>T</u>ime </em>P<em>rogramable </em>ROM):<br>
		Nur einmal programmierbares ROM</li>
	<li>
		<strong>EPROM</strong> (<em><u>E</u>rasable<u> PROM</u></em>):<br>
		Wiederprogrammierbares ROM. Kann mit UV-Licht gelöscht werden.</li>
	<li>
		<strong>EEPROM</strong> (<em><u>E</u>lectrical <u>E</u>raseable <u>PROM</u></em>):<br>
		Wiederprogrammierbares ROM. Kann auf elektrische Weise gelöscht werden, zB durch eine höhere Spannung an einem speziellen Pin.</li>
	<li>
		<strong>Flash</strong><br>
		Eine besondere Bauform eines EEPROM. Das Löschen und Reprogrammieren erfolgt hier besonders schnell (blitzschnell, Flash = Blitz).</li>
</ul>
<p>
	Darüber hinaus sind beim RAM folgende Varianten zu finden:</p>
<ul>
	<li>
		<strong>SRAM</strong> (<em><u>S</u>tatic <u>RAM</u></em>):<br>
		Die Speicherzellen behalten ihren Inhalt solange der Speicherbaustein mit ausreichend Spannung versorgt wird.<br>
		<br>
		Beispiel eines SRAM-Bausteins: wie groß ist der Speicher?<br>
		<a title="Pin-Belegung eines SRAM Bausteins" description="" href="./4AHME FIVU - Mikroprozessor_files/sram_svg" class="page_img_188395479">  <img type="wikilink" class="image" src="./4AHME FIVU - Mikroprozessor_files/sram_svg" alt="Pin-Belegung eines SRAM Bausteins" title="Pin-Belegung eines SRAM Bausteins"></a><br>
		&nbsp;</li>
	<li>
		<strong>DRAM</strong> (<em><u>D</u>ynamic <u>RAM</u></em>):<br>
		Die Speicherzellen verlieren mit der Zeit ihren Inhalt, daher müssen diese in einem Refresh-Zyklus immer wieder aufgefrischt werden.</li>
	<li>
		<strong>NV-RAM</strong> (<em><u>N</u>on <u>V</u>olatile <u>RAM</u></em>):<br>
		Kombination aus RAM und Flash. Beim Abschalten wird der Inhalt des RAM automatisch ins Flash übertragen. Beim Einschalten wird der Inhalt des Flash automatisch ins RAM übertragen.</li>
</ul>
Weitere detaillierte Informationen sind sehr ausführlich bei Wikipedia zu finden.<br>
<p>
	Siehe: <a href="http://de.wikipedia.org/wiki/Datenspeicher" target="_blank">http://de.wikipedia.org/wiki/Datenspeicher</a></p></div>
</div></div>
	    <script type="text/javascript">
		if (book_admin_p == 1) {
			$('.ibook_item div.book_v2').each(function (){
				$(this).sortable({
					items:'div.emmbedded-book-page-wrapper',
					handle:'div.ctxmenu',
					axis:'y',
					containment:'document',
					scroll:false,
					tolerance:'pointer',
					cursor:'move',
					update:function(e,ui){
						var els = $(this).sortable('serialize',{key:'el'}) + '&m=order';
						$.post(parent_url+'/'+$('#bookpage'+$('#ibook_current_page').val()).attr('parent'), els);
					}
				});
			});
			$('div.emmbedded-book-page-wrapper div.ctxmenu').hide();
			$('div.emmbedded-book-page-wrapper').on('mouseenter', function(){
				$(this).find('div.ctxmenu').show();
			});
			$('div.emmbedded-book-page-wrapper').on('mouseleave', function(){
				$('div.emmbedded-book-page-wrapper div.ctxmenu').hide();
			});
		}
	    </script>
	
	<script type="text/javascript" src="./4AHME FIVU - Mikroprozessor_files/jquery.lightbox.js.Download"></script>
	<link type="text/css" href="./4AHME FIVU - Mikroprozessor_files/jquery.lightbox.css" rel="stylesheet">
	<script type="text/javascript">
		$('#bookpage188395479 .emmbedded-book-page-wrapper.page img').each(function() {
        if ($(this).parent().is("a")) {return;}
			$(' <a title="'+$(this).attr('title')+'"  description=""  href="'+$(this).attr('src')+'"  class="page_img_188395479">  </a>  ').insertAfter(this).append(this);
		});
		$('#bookpage188395479 .emmbedded-book-page-wrapper.photo .photo-or-thumb a:first').addClass('page_img_188395479');
		$('#bookpage188395479 .emmbedded-book-page-wrapper.photo-album .photo-show .photo-container .thumbnail a').addClass('page_img_188395479');
		$('a.page_img_188395479').lightBox();
	</script>
    </div></div>
</div><div class="content-chunk-footer"></div>
</div><div id="bookpage189566980" class="ibook_item   loaded" item_id="189566980" data-order="1.6" count="7" parent="EC743ABCF7AB5/F607FABBC42B3" name="EC743ABCF7AB5/F607FABBC42B3/AFE000B466EB6" style="display: none;"><h2>Der Stack</h2> <br><div class="Form-bookpage_form"><div class="ipart_v2"><div class="book_v2"><div data-order="2" id="el_189567114" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3></h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><style type="text/css">
li {margin-bottom:8px}</style>
<p>
	Siehe auch:&nbsp;<a href="http://de.wikipedia.org/wiki/Stapelspeicher" target="_blank">http://de.wikipedia.org/wiki/Stapelspeicher</a></p>
<p>
	Ein Stack ist ein Stapelspeicher. Er funktioniert nach dem <strong>LIFO-Prinzip</strong> (<strong>L</strong>ast <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut). Das Ablegen von Daten am Stack wird <strong>push</strong> genannt, das Holen der Daten vom Stack <strong>pop</strong>.</p>
<p style="text-align: center;">
	&nbsp;</p>
<p style="text-align: center;">
	<a title="Funktionsprinzip eines Stack" description="" href="./4AHME FIVU - Mikroprozessor_files/data_stack_svg" class="page_img_189566980">  <img type="wikilink" class="image" src="./4AHME FIVU - Mikroprozessor_files/data_stack_svg" alt="Funktionsprinzip eines Stack" title="Funktionsprinzip eines Stack" style="width:  300px;height:  216px;"></a></p>
<p>
	Sehr häufig ist ein Stack-Speicher (kurz "Stack") fixer Bestandteil einer CPU und wird je nach Prozessortyp in der CPU oder im Arbeitsspeicher realisiert. In den µCs der Atmel megaAVR Familie ist der Stack am Ende des Arbeitspeichers (SRAM) zu finden.</p>
<p>
	Viele Programmiersprachen (auch C, C++, Java, ...) benutzen den Stack als Speicher für Funktionsrücksprungadressen,&nbsp;lokale Variable in Funktionen (bzw. Anweisungsblöcken), eventuell auch für&nbsp;Funktionsparameter und Funktionsrückgabewerte, und letztlich immer dann wenn interne Arbeitsregister temporär gespeichert werden müssen.</p>
<p>
	In der CPU ist ein&nbsp;spezielles Register (= Gruppe von Flip-Flops oder Latches)&nbsp;als&nbsp;<strong>Stack Pointer</strong> realisiert. Sein Inhalt enthält jene Adresse, auf die bei der nächsten Stack-push Operation Daten gespeichert werden.</p>
<p>
	Bei einer<strong> push-Operation</strong> werden die Daten an jener Adresse abgespeichert auf die der <em>Stack Pointer</em> zeigt, und anschließend der <em>Stack Pointer</em> automatisch verringert. Der Stack wächst daher von "unten" (hohe Adresswerte) nach "oben" (kleine Adresswerte).</p>
<p>
	Bei einer <strong>pop-Operation</strong> wird zunächst der <em>Stack Pointer</em> erhöht, und dann werden die Daten von jener Adresse gelesen auf die der Stack Pointer zeigt. Die gelesenen Daten bleiben im Stack erhalten bis sie von neuen Daten überschrieben werden. Dieses Prinzip kann bei sicherheitskritischen Belangen problematisch sein.</p>
<p>
	Bei einem <strong>call Befehl </strong>wird der aktuelle Wert des Program Counter, also die Adresse des nächsten Maschinenbefehls, am Stack gespeichert (push-Operation).</p>
<p>
	Beim <strong>ret Befehl</strong> wird mittels pop-Operation ein Wert vom Stack genommen und in den Program Counter geschrieben.</p>
<p>
	Mit dem call- und ret-Befehl können Funktionsaufrufe mit Rücksprung realisiert werden.</p>
<p>
	&nbsp;</p></div>
</div></div><div data-order="3" id="el_189567183" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3>Beispiel: Der Stack Pointer beim Atmel Atmega16</h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><style type="text/css">
li {margin-bottom:8px}</style>
<p>
	Der <em>Stack Pointer</em> umfasst 16 Bit, wobei die oberen 8 Bit als I/O-Register <em>SPH</em> und die unteren 8 Bit als I/O-Register <em>SPL</em> im Speicher zu finden sind.&nbsp;</p>
<div>
	<a title="Stack Pointer im Atmega16" description="" href="./4AHME FIVU - Mikroprozessor_files/stackpointer_atmega16_svg" class="page_img_189566980">  <img type="wikilink" class="image" src="./4AHME FIVU - Mikroprozessor_files/stackpointer_atmega16_svg" alt="Stack Pointer im Atmega16" title="Stack Pointer im Atmega16" style="width:  640px;height:  165px;"></a></div>
<p>
	Der <em>Stack Pointer</em> hat nach dem Reset den Wert 0 und muss daher durch entsprechende Maschinenbefehle des Programmes zu Beginn initialisiert werden:</p>
<pre>0000002C  cf.e5  LDI R28,0x5F
0000002D  d4.e0  LDI R29,0x04
0000002E  de.bf  OUT 0x3E,R29
0000002F  cd.bf  OUT 0x3D,R28</pre>
<p>
	Diese Code-Sequenz ist dem Disassembler der IDE Atmel Studio entnommen. Mnemonics werden im Gegensatz zum gcc hier in Großbuchstaben geschrieben, ganz links ist die Wortadresse im Programmspeicher zu finden. In der Mitte ist der eigentliche Maschinenbefehl als Hex-Code zu finden, wobei High-Byte und Low-Byte vertauscht sind (der Befehl <em>OUT 0x3D,R28</em> hat laut AVR Instruction Manual das Bitmuster 1011 1111 1100 1101 also Hex <em>bfcd&nbsp;</em>).</p>
<p>
	Der <em>Stack Pointer</em> hat nach diesen 4 Maschinenbefehlen den Wert 0x045f. Das ist die Adresse des letzten Byte im SRAM.</p></div>
</div></div>
	    <script type="text/javascript">
		if (book_admin_p == 1) {
			$('.ibook_item div.book_v2').each(function (){
				$(this).sortable({
					items:'div.emmbedded-book-page-wrapper',
					handle:'div.ctxmenu',
					axis:'y',
					containment:'document',
					scroll:false,
					tolerance:'pointer',
					cursor:'move',
					update:function(e,ui){
						var els = $(this).sortable('serialize',{key:'el'}) + '&m=order';
						$.post(parent_url+'/'+$('#bookpage'+$('#ibook_current_page').val()).attr('parent'), els);
					}
				});
			});
			$('div.emmbedded-book-page-wrapper div.ctxmenu').hide();
			$('div.emmbedded-book-page-wrapper').on('mouseenter', function(){
				$(this).find('div.ctxmenu').show();
			});
			$('div.emmbedded-book-page-wrapper').on('mouseleave', function(){
				$('div.emmbedded-book-page-wrapper div.ctxmenu').hide();
			});
		}
	    </script>
	
	<script type="text/javascript" src="./4AHME FIVU - Mikroprozessor_files/jquery.lightbox.js.Download"></script>
	<link type="text/css" href="./4AHME FIVU - Mikroprozessor_files/jquery.lightbox.css" rel="stylesheet">
	<script type="text/javascript">
		$('#bookpage189566980 .emmbedded-book-page-wrapper.page img').each(function() {
        if ($(this).parent().is("a")) {return;}
			$(' <a title="'+$(this).attr('title')+'"  description=""  href="'+$(this).attr('src')+'"  class="page_img_189566980">  </a>  ').insertAfter(this).append(this);
		});
		$('#bookpage189566980 .emmbedded-book-page-wrapper.photo .photo-or-thumb a:first').addClass('page_img_189566980');
		$('#bookpage189566980 .emmbedded-book-page-wrapper.photo-album .photo-show .photo-container .thumbnail a').addClass('page_img_189566980');
		$('a.page_img_189566980').lightBox();
	</script>
    </div></div>
</div><div class="content-chunk-footer"></div>
</div><div id="bookpage189537312" class="ibook_item   loaded" item_id="189537312" data-order="1.7" count="8" parent="EC743ABCF7AB5/F607FABBC42B3" name="EC743ABCF7AB5/F607FABBC42B3/2931AC3FCF4BA" style="display: none;"><h2>Assembler</h2> <br><div class="Form-bookpage_form"><div class="ipart_v2"><div class="book_v2"><div data-order="1" id="el_189102617" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3>Assemblerquelltext</h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><p>
	Die Programmierung mit Maschinensprache, zum Beispiel mittels Lochkarten, war sehr umständlich, unübersichtlich und zeitraubend. Daher kam es in den 1960er Jahren zum nächsten Evolutionsschritt, der Programmierung in Assembler.</p>
<p>
	Dabei wird jedem Maschinenbefehl (Opcode) eine für den Menschen gut lesbare textuelle Form zugeordnet. Der Programmierer erstellt nun eine Assembler-Quelltextdatei, in dem er diese Assemblerbefehle textuell nacheinander hineinschreibt. Ein spezielles Programm, der <strong>Assembler</strong>, &nbsp;übersetzt die Assembler-Quelltextdatei in eine Objektdatei. Ein weiteres Programm, der <strong>Linker</strong>, fügt mehrere Objektdateien zusammen und erstellt ein ausführbares Maschinenprogramm.</p>
<p>
	Bei einem Microcontroller muss dieses Programm noch mit Hilfe eines speziellen Programmes in das Flash des µC programmiert werden. Diese <strong>Programmer</strong> benötigen manchmal spezielle Dateiformate (Intel Hex, S-Record, ...), sodass eventuell noch eine Konvertierung der Programmdatei in ein geeignetes Format erforderlich ist.</p>
<p>
	&nbsp;</p></div>
</div></div><div data-order="2" id="el_189537315" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3>Beispiel: Assembler-Programm für einen Atmel Atmega16 µC</h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><p>
	<u><strong>Schritt 1:</strong></u> Erstellen einer Assembler-Quelltextdatei <em>prog.sx</em> mit einem Texteditor</p>
<p>
	<u>Wichtiger Hinweis bezüglich der Dateiendung .sx und .s:</u><br>
	Enden Assemblerdateien mit der Endung <em>.s</em>, so wird kein Preprozessor gestartet, und es müssen dann alle prozessorspezifischen Symbole (DDRA, PORTA, ...) als Adressen selbst angegeben werden. Wird die Endung .sx, verwendet so wird avr-gcc bei der Assemblierung zunächst den Preprozessor starten. Dieser bindet die #include Dateien ein und ersetzt die prozessorspezifischen Symbole durch deren Werte.</p>
<pre>#include &lt;avr/io.h&gt;

.global<span class="Apple-tab-span" style="white-space:pre"> </span>main

 .text
main:
  ldi  r17,lo8(1)
  ldi  r16,lo8(0x0f)
  out  _SFR_IO_ADDR(DDRA),r16
  ldi  r16,lo8(0x0e)
  out  _SFR_IO_ADDR(PORTA),r16
  clr r16
  out _SFR_IO_ADDR(UBRRH),r16
  out _SFR_IO_ADDR(UCSRA),r16
  ldi r16,lo8(12)   ; 57600 Bit/s
  out _SFR_IO_ADDR(UBRRL),r16
  ldi r16,lo8(0x86) ; URSEL, UCSZ1, UCSZ0 (8 Bit)
  out _SFR_IO_ADDR(UCSRC),r16
  ldi r16,lo8(0x08) ; TXEN
  out _SFR_IO_ADDR(UCSRB),r16

loop:
  ldi  r28,lo8(message)
  ldi  r29,hi8(message)
  call write

  IN   r16,_SFR_IO_ADDR(PORTA)
  eor  r16,r17
  OUT  _SFR_IO_ADDR(PORTA),r16
  rjmp loop


.section .rodata
.global __do_copy_data

message:
  .string "Hello world\n\r"

</pre>
<p>
	<u><strong>Schritt 2:</strong></u> Assemblieren der Datei <em>test.sx</em> zur Objektdatei<em> test.o</em></p>
<pre>user@linux-pc:~$ <strong>avr-gcc -mmcu=atmega16 -c test.sx </strong></pre>
<p>
	Das Ergebnis lässt sich disassembliert ausgeben. Man sieht, dass an der Sprungstelle (call) die Adresse noch fehlt.</p>
<pre>user@linux-pc:~$ <strong>avr-objdump -D -S test.o</strong>

test.o:     Dateiformat elf32-avr

Disassembly of section .text:

00000000 &lt;main&gt;:
   0:<span class="Apple-tab-span" style="white-space:pre"> </span>0f e0       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r16, 0x0F<span class="Apple-tab-span" style="white-space:pre"> </span>; 15
   2:<span class="Apple-tab-span" style="white-space:pre"> </span>0a bb       <span class="Apple-tab-span" style="white-space:pre"> </span>out<span class="Apple-tab-span" style="white-space:pre"> </span>0x1a, r16<span class="Apple-tab-span" style="white-space:pre"> </span>; 26
   4:<span class="Apple-tab-span" style="white-space:pre"> </span>0e e0       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r16, 0x0E<span class="Apple-tab-span" style="white-space:pre"> </span>; 14
   6:<span class="Apple-tab-span" style="white-space:pre"> </span>0b bb       <span class="Apple-tab-span" style="white-space:pre"> </span>out<span class="Apple-tab-span" style="white-space:pre"> </span>0x1b, r16<span class="Apple-tab-span" style="white-space:pre"> </span>; 27
   8:<span class="Apple-tab-span" style="white-space:pre"> </span>00 27       <span class="Apple-tab-span" style="white-space:pre"> </span>eor<span class="Apple-tab-span" style="white-space:pre"> </span>r16, r16
   a:<span class="Apple-tab-span" style="white-space:pre"> </span>00 bd       <span class="Apple-tab-span" style="white-space:pre"> </span>out<span class="Apple-tab-span" style="white-space:pre"> </span>0x20, r16<span class="Apple-tab-span" style="white-space:pre"> </span>; 32
   c:<span class="Apple-tab-span" style="white-space:pre"> </span>0b b9       <span class="Apple-tab-span" style="white-space:pre"> </span>out<span class="Apple-tab-span" style="white-space:pre"> </span>0x0b, r16<span class="Apple-tab-span" style="white-space:pre"> </span>; 11
   e:<span class="Apple-tab-span" style="white-space:pre"> </span>0c e0       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r16, 0x0C<span class="Apple-tab-span" style="white-space:pre"> </span>; 12
  10:<span class="Apple-tab-span" style="white-space:pre"> </span>09 b9       <span class="Apple-tab-span" style="white-space:pre"> </span>out<span class="Apple-tab-span" style="white-space:pre"> </span>0x09, r16<span class="Apple-tab-span" style="white-space:pre"> </span>; 9
  12:<span class="Apple-tab-span" style="white-space:pre"> </span>06 e8       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r16, 0x86<span class="Apple-tab-span" style="white-space:pre"> </span>; 134
  14:<span class="Apple-tab-span" style="white-space:pre"> </span>00 bd       <span class="Apple-tab-span" style="white-space:pre"> </span>out<span class="Apple-tab-span" style="white-space:pre"> </span>0x20, r16<span class="Apple-tab-span" style="white-space:pre"> </span>; 32
  16:<span class="Apple-tab-span" style="white-space:pre"> </span>08 e0       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r16, 0x08<span class="Apple-tab-span" style="white-space:pre"> </span>; 8
  18:<span class="Apple-tab-span" style="white-space:pre"> </span>0a b9       <span class="Apple-tab-span" style="white-space:pre"> </span>out<span class="Apple-tab-span" style="white-space:pre"> </span>0x0a, r16<span class="Apple-tab-span" style="white-space:pre"> </span>; 10

0000001a &lt;loop&gt;:
  1a:<span class="Apple-tab-span" style="white-space:pre"> </span>c0 e0       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r28, 0x00<span class="Apple-tab-span" style="white-space:pre"> </span>; 0
  1c:<span class="Apple-tab-span" style="white-space:pre"> </span>d0 e0       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r29, 0x00<span class="Apple-tab-span" style="white-space:pre"> </span>; 0
  1e:<span class="Apple-tab-span" style="white-space:pre"> </span>0e 94 00 00 <span class="Apple-tab-span" style="white-space:pre"> </span>call<span class="Apple-tab-span" style="white-space:pre"> </span>0<span class="Apple-tab-span" style="white-space:pre"> </span>; 0x0 &lt;main&gt;
  22:<span class="Apple-tab-span" style="white-space:pre"> </span>0b b3       <span class="Apple-tab-span" style="white-space:pre"> </span>in<span class="Apple-tab-span" style="white-space:pre"> </span>r16, 0x1b<span class="Apple-tab-span" style="white-space:pre"> </span>; 27
  24:<span class="Apple-tab-span" style="white-space:pre"> </span>01 27       <span class="Apple-tab-span" style="white-space:pre"> </span>eor<span class="Apple-tab-span" style="white-space:pre"> </span>r16, r17
  26:<span class="Apple-tab-span" style="white-space:pre"> </span>0b bb       <span class="Apple-tab-span" style="white-space:pre"> </span>out<span class="Apple-tab-span" style="white-space:pre"> </span>0x1b, r16<span class="Apple-tab-span" style="white-space:pre"> </span>; 27
  28:<span class="Apple-tab-span" style="white-space:pre"> </span>00 c0       <span class="Apple-tab-span" style="white-space:pre"> </span>rjmp<span class="Apple-tab-span" style="white-space:pre"> </span>.+0      <span class="Apple-tab-span" style="white-space:pre"> </span>; 0x2a &lt;loop+0x10&gt;

Disassembly of section .rodata:

00000000 &lt;message&gt;:
   0:<span class="Apple-tab-span" style="white-space:pre"> </span>48 65       <span class="Apple-tab-span" style="white-space:pre"> </span>ori<span class="Apple-tab-span" style="white-space:pre"> </span>r20, 0x58<span class="Apple-tab-span" style="white-space:pre"> </span>; 88
   2:<span class="Apple-tab-span" style="white-space:pre"> </span>6c 6c       <span class="Apple-tab-span" style="white-space:pre"> </span>ori<span class="Apple-tab-span" style="white-space:pre"> </span>r22, 0xCC<span class="Apple-tab-span" style="white-space:pre"> </span>; 204
   4:<span class="Apple-tab-span" style="white-space:pre"> </span>6f 20       <span class="Apple-tab-span" style="white-space:pre"> </span>and<span class="Apple-tab-span" style="white-space:pre"> </span>r6, r15
   6:<span class="Apple-tab-span" style="white-space:pre"> </span>77 6f       <span class="Apple-tab-span" style="white-space:pre"> </span>ori<span class="Apple-tab-span" style="white-space:pre"> </span>r23, 0xF7<span class="Apple-tab-span" style="white-space:pre"> </span>; 247
   8:<span class="Apple-tab-span" style="white-space:pre"> </span>72 6c       <span class="Apple-tab-span" style="white-space:pre"> </span>ori<span class="Apple-tab-span" style="white-space:pre"> </span>r23, 0xC2<span class="Apple-tab-span" style="white-space:pre"> </span>; 194
   a:<span class="Apple-tab-span" style="white-space:pre"> </span>64 0a       <span class="Apple-tab-span" style="white-space:pre"> </span>sbc<span class="Apple-tab-span" style="white-space:pre"> </span>r6, r20
   c:<span class="Apple-tab-span" style="white-space:pre"> </span>0d 00       <span class="Apple-tab-span" style="white-space:pre"> </span>.word<span class="Apple-tab-span" style="white-space:pre"> </span>0x000d<span class="Apple-tab-span" style="white-space:pre"> </span>; ????</pre>
<p>
	&nbsp;</p>
<p>
	<u><strong>Schritt 3:</strong></u>&nbsp;Erstellen der zweiten Assembler-Quelltextdatei write<em>.sx</em>&nbsp;mit einem Texteditor</p>
<pre>#include &lt;avr/io.h&gt;

.global<span class="Apple-tab-span" style="white-space:pre"> </span>write

 .text

write:
  push r16
  push r28
  push r29

loop:   ; Wait for empty transmit buffer
  sbis _SFR_IO_ADDR(UCSRA),5      ; skip if bit UDRE is set
  rjmp loop
  ld  r16,Y+
  tst r16
  breq exit
  out _SFR_IO_ADDR(UDR),r16
  rjmp loop

exit:
  pop r29
  pop r28
  pop r16
  ret</pre>
<p>
	<br>
	<strong><u>Schritt 4:</u></strong> Assemblieren der Datei&nbsp;<em>write.sx</em>&nbsp;zur Objektdatei<em>&nbsp;write.o</em></p>
<pre>user@linux-pc:~$ <strong>avr-gcc -mmcu=atmega16 -c write.sx </strong></pre>
<p>
	Das Ergebnis lässt sich disassembliert ausgeben.&nbsp;</p>
<pre>user@linux-pc:~$&nbsp;<strong>avr-objdump -D -S write.o
</strong>
write.o:     Dateiformat elf32-avr

Disassembly of section .text:

00000000 &lt;write&gt;:
   0:  0f 93       push  r16
   2:  cf 93       push  r28
   4:  df 93       push  r29

00000006 &lt;loop&gt;:
   6:  5d 9b       sbis  0x0b, 5        ; 11
   8:  00 c0       rjmp  .+0            ; 0xa &lt;loop+0x4&gt;
   a:  09 91       ld    r16, Y+
   c:  00 23       and   r16, r16
   e:  01 f0       breq  .+0            ; 0x10 &lt;loop+0xa&gt;
  10:  0c b9       out   0x0c, r16      ; 12
  12:  00 c0       rjmp  .+0            ; 0x14 &lt;exit&gt;

00000014 &lt;exit&gt;:
  14:  df 91       pop   r29
  16:  cf 91       pop   r28
  18:  0f 91       pop   r16
  1a:  08 95       ret</pre>
<p>
	<br>
	<u><strong>Schritt 5:</strong></u> Zusammenbinden (Linken) der beiden Objektdateien <em>test.o</em> und <em>write.o</em></p>
<pre>user@linux-pc:~$ <strong>avr-gcc -mmcu=atmega16 -o prog test.o write.o</strong></pre>
<p>
	Das Ergebnis lässt sich disassembliert ausgeben.<br>
	Man sieht, dass an der Sprungstelle (call) jetzt die Adresse eingetragen ist.</p>
<pre>user@linux-pc:~$ <strong>avr-objdump -D -S prog</strong>

prog:     Dateiformat elf32-avr

Disassembly of section .text:

00000000 &lt;__vectors&gt;:
   0:<span class="Apple-tab-span" style="white-space:pre"> </span>0c 94 2a 00 <span class="Apple-tab-span" style="white-space:pre"> </span>jmp<span class="Apple-tab-span" style="white-space:pre"> </span>0x54<span class="Apple-tab-span" style="white-space:pre"> </span>; 0x54 &lt;__ctors_end&gt;
   4:<span class="Apple-tab-span" style="white-space:pre"> </span>0c 94 3f 00 <span class="Apple-tab-span" style="white-space:pre"> </span>jmp<span class="Apple-tab-span" style="white-space:pre"> </span>0x7e<span class="Apple-tab-span" style="white-space:pre"> </span>; 0x7e &lt;__bad_interrupt&gt;
   8:<span class="Apple-tab-span" style="white-space:pre"> </span>0c 94 3f 00 <span class="Apple-tab-span" style="white-space:pre"> </span>jmp<span class="Apple-tab-span" style="white-space:pre"> </span>0x7e<span class="Apple-tab-span" style="white-space:pre"> </span>; 0x7e &lt;__bad_interrupt&gt;
   ...   
   4c:<span class="Apple-tab-span" style="white-space:pre"> </span>0c 94 3f 00 <span class="Apple-tab-span" style="white-space:pre"> </span>jmp<span class="Apple-tab-span" style="white-space:pre"> </span>0x7e<span class="Apple-tab-span" style="white-space:pre"> </span>; 0x7e &lt;__bad_interrupt&gt;
   50:<span class="Apple-tab-span" style="white-space:pre"> </span>0c 94 3f 00 <span class="Apple-tab-span" style="white-space:pre"> </span>jmp<span class="Apple-tab-span" style="white-space:pre"> </span>0x7e<span class="Apple-tab-span" style="white-space:pre"> </span>; 0x7e &lt;__bad_interrupt&gt;

00000054 &lt;__ctors_end&gt;:
  54:<span class="Apple-tab-span" style="white-space:pre"> </span>11 24       <span class="Apple-tab-span" style="white-space:pre"> </span>eor<span class="Apple-tab-span" style="white-space:pre"> </span>r1, r1
  56:<span class="Apple-tab-span" style="white-space:pre"> </span>1f be       <span class="Apple-tab-span" style="white-space:pre"> </span>out<span class="Apple-tab-span" style="white-space:pre"> </span>0x3f, r1<span class="Apple-tab-span" style="white-space:pre"> </span>; 63
  58:<span class="Apple-tab-span" style="white-space:pre"> </span>cf e5       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r28, 0x5F<span class="Apple-tab-span" style="white-space:pre"> </span>; 95
  5a:<span class="Apple-tab-span" style="white-space:pre"> </span>d4 e0       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r29, 0x04<span class="Apple-tab-span" style="white-space:pre"> </span>; 4
  5c:<span class="Apple-tab-span" style="white-space:pre"> </span>de bf       <span class="Apple-tab-span" style="white-space:pre"> </span>out<span class="Apple-tab-span" style="white-space:pre"> </span>0x3e, r29<span class="Apple-tab-span" style="white-space:pre"> </span>; 62
  5e:<span class="Apple-tab-span" style="white-space:pre"> </span>cd bf       <span class="Apple-tab-span" style="white-space:pre"> </span>out<span class="Apple-tab-span" style="white-space:pre"> </span>0x3d, r28<span class="Apple-tab-span" style="white-space:pre"> </span>; 61

00000060 &lt;__do_copy_data&gt;:
  60:<span class="Apple-tab-span" style="white-space:pre"> </span>10 e0       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r17, 0x00<span class="Apple-tab-span" style="white-space:pre"> </span>; 0
  62:<span class="Apple-tab-span" style="white-space:pre"> </span>a0 e6       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r26, 0x60<span class="Apple-tab-span" style="white-space:pre"> </span>; 96
  64:<span class="Apple-tab-span" style="white-space:pre"> </span>b0 e0       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r27, 0x00<span class="Apple-tab-span" style="white-space:pre"> </span>; 0
  66:<span class="Apple-tab-span" style="white-space:pre"> </span>ec ec       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r30, 0xCC<span class="Apple-tab-span" style="white-space:pre"> </span>; 204
  68:<span class="Apple-tab-span" style="white-space:pre"> </span>f0 e0       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r31, 0x00<span class="Apple-tab-span" style="white-space:pre"> </span>; 0
  6a:<span class="Apple-tab-span" style="white-space:pre"> </span>02 c0       <span class="Apple-tab-span" style="white-space:pre"> </span>rjmp<span class="Apple-tab-span" style="white-space:pre"> </span>.+4      <span class="Apple-tab-span" style="white-space:pre"> </span>; 0x70 &lt;__do_copy_data+0x10&gt;
  6c:<span class="Apple-tab-span" style="white-space:pre"> </span>05 90       <span class="Apple-tab-span" style="white-space:pre"> </span>lpm<span class="Apple-tab-span" style="white-space:pre"> </span>r0, Z+
  6e:<span class="Apple-tab-span" style="white-space:pre"> </span>0d 92       <span class="Apple-tab-span" style="white-space:pre"> </span>st<span class="Apple-tab-span" style="white-space:pre"> </span>X+, r0
  70:<span class="Apple-tab-span" style="white-space:pre"> </span>ae 36       <span class="Apple-tab-span" style="white-space:pre"> </span>cpi<span class="Apple-tab-span" style="white-space:pre"> </span>r26, 0x6E<span class="Apple-tab-span" style="white-space:pre"> </span>; 110
  72:<span class="Apple-tab-span" style="white-space:pre"> </span>b1 07       <span class="Apple-tab-span" style="white-space:pre"> </span>cpc<span class="Apple-tab-span" style="white-space:pre"> </span>r27, r17
  74:<span class="Apple-tab-span" style="white-space:pre"> </span>d9 f7       <span class="Apple-tab-span" style="white-space:pre"> </span>brne<span class="Apple-tab-span" style="white-space:pre"> </span>.-10     <span class="Apple-tab-span" style="white-space:pre"> </span>; 0x6c &lt;__do_copy_data+0xc&gt;
  76:<span class="Apple-tab-span" style="white-space:pre"> </span>0e 94 41 00 <span class="Apple-tab-span" style="white-space:pre"> </span>call<span class="Apple-tab-span" style="white-space:pre"> </span>0x82<span class="Apple-tab-span" style="white-space:pre"> </span>; 0x82 &lt;main&gt;
  7a:<span class="Apple-tab-span" style="white-space:pre"> </span>0c 94 64 00 <span class="Apple-tab-span" style="white-space:pre"> </span>jmp<span class="Apple-tab-span" style="white-space:pre"> </span>0xc8<span class="Apple-tab-span" style="white-space:pre"> </span>; 0xc8 &lt;_exit&gt;

0000007e &lt;__bad_interrupt&gt;:
  7e:<span class="Apple-tab-span" style="white-space:pre"> </span>0c 94 00 00 <span class="Apple-tab-span" style="white-space:pre"> </span>jmp<span class="Apple-tab-span" style="white-space:pre"> </span>0<span class="Apple-tab-span" style="white-space:pre"> </span>; 0x0 &lt;__vectors&gt;

00000082 &lt;main&gt;:
  82:<span class="Apple-tab-span" style="white-space:pre"> </span>0f e0       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r16, 0x0F<span class="Apple-tab-span" style="white-space:pre"> </span>; 15
  84:<span class="Apple-tab-span" style="white-space:pre"> </span>0a bb       <span class="Apple-tab-span" style="white-space:pre"> </span>out<span class="Apple-tab-span" style="white-space:pre"> </span>0x1a, r16<span class="Apple-tab-span" style="white-space:pre"> </span>; 26
  86:<span class="Apple-tab-span" style="white-space:pre"> </span>0e e0       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r16, 0x0E<span class="Apple-tab-span" style="white-space:pre"> </span>; 14
  88:<span class="Apple-tab-span" style="white-space:pre"> </span>0b bb       <span class="Apple-tab-span" style="white-space:pre"> </span>out<span class="Apple-tab-span" style="white-space:pre"> </span>0x1b, r16<span class="Apple-tab-span" style="white-space:pre"> </span>; 27
  8a:<span class="Apple-tab-span" style="white-space:pre"> </span>00 27       <span class="Apple-tab-span" style="white-space:pre"> </span>eor<span class="Apple-tab-span" style="white-space:pre"> </span>r16, r16
  8c:<span class="Apple-tab-span" style="white-space:pre"> </span>00 bd       <span class="Apple-tab-span" style="white-space:pre"> </span>out<span class="Apple-tab-span" style="white-space:pre"> </span>0x20, r16<span class="Apple-tab-span" style="white-space:pre"> </span>; 32
  8e:<span class="Apple-tab-span" style="white-space:pre"> </span>0b b9       <span class="Apple-tab-span" style="white-space:pre"> </span>out<span class="Apple-tab-span" style="white-space:pre"> </span>0x0b, r16<span class="Apple-tab-span" style="white-space:pre"> </span>; 11
  90:<span class="Apple-tab-span" style="white-space:pre"> </span>0c e0       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r16, 0x0C<span class="Apple-tab-span" style="white-space:pre"> </span>; 12
  92:<span class="Apple-tab-span" style="white-space:pre"> </span>09 b9       <span class="Apple-tab-span" style="white-space:pre"> </span>out<span class="Apple-tab-span" style="white-space:pre"> </span>0x09, r16<span class="Apple-tab-span" style="white-space:pre"> </span>; 9
  94:<span class="Apple-tab-span" style="white-space:pre"> </span>06 e8       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r16, 0x86<span class="Apple-tab-span" style="white-space:pre"> </span>; 134
  96:<span class="Apple-tab-span" style="white-space:pre"> </span>00 bd       <span class="Apple-tab-span" style="white-space:pre"> </span>out<span class="Apple-tab-span" style="white-space:pre"> </span>0x20, r16<span class="Apple-tab-span" style="white-space:pre"> </span>; 32
  98:<span class="Apple-tab-span" style="white-space:pre"> </span>08 e0       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r16, 0x08<span class="Apple-tab-span" style="white-space:pre"> </span>; 8
  9a:<span class="Apple-tab-span" style="white-space:pre"> </span>0a b9       <span class="Apple-tab-span" style="white-space:pre"> </span>out<span class="Apple-tab-span" style="white-space:pre"> </span>0x0a, r16<span class="Apple-tab-span" style="white-space:pre"> </span>; 10

0000009c &lt;loop&gt;:
  9c:<span class="Apple-tab-span" style="white-space:pre"> </span>c0 e6       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r28, 0x60<span class="Apple-tab-span" style="white-space:pre"> </span>; 96
  9e:<span class="Apple-tab-span" style="white-space:pre"> </span>d0 e0       <span class="Apple-tab-span" style="white-space:pre"> </span>ldi<span class="Apple-tab-span" style="white-space:pre"> </span>r29, 0x00<span class="Apple-tab-span" style="white-space:pre"> </span>; 0
  a0:<span class="Apple-tab-span" style="white-space:pre"> </span>0e 94 56 00 <span class="Apple-tab-span" style="white-space:pre"> </span>call<span class="Apple-tab-span" style="white-space:pre"> </span>0xac<span class="Apple-tab-span" style="white-space:pre"> </span>; 0xac &lt;write&gt;
  a4:<span class="Apple-tab-span" style="white-space:pre"> </span>0b b3       <span class="Apple-tab-span" style="white-space:pre"> </span>in<span class="Apple-tab-span" style="white-space:pre"> </span>r16, 0x1b<span class="Apple-tab-span" style="white-space:pre"> </span>; 27
  a6:<span class="Apple-tab-span" style="white-space:pre"> </span>01 27       <span class="Apple-tab-span" style="white-space:pre"> </span>eor<span class="Apple-tab-span" style="white-space:pre"> </span>r16, r17
  a8:<span class="Apple-tab-span" style="white-space:pre"> </span>0b bb       <span class="Apple-tab-span" style="white-space:pre"> </span>out<span class="Apple-tab-span" style="white-space:pre"> </span>0x1b, r16<span class="Apple-tab-span" style="white-space:pre"> </span>; 27
  aa:<span class="Apple-tab-span" style="white-space:pre"> </span>f8 cf       <span class="Apple-tab-span" style="white-space:pre"> </span>rjmp<span class="Apple-tab-span" style="white-space:pre"> </span>.-16     <span class="Apple-tab-span" style="white-space:pre"> </span>; 0x9c &lt;loop&gt;

000000ac &lt;write&gt;:
  ac:<span class="Apple-tab-span" style="white-space:pre"> </span>0f 93       <span class="Apple-tab-span" style="white-space:pre"> </span>push<span class="Apple-tab-span" style="white-space:pre"> </span>r16
  ae:<span class="Apple-tab-span" style="white-space:pre"> </span>cf 93       <span class="Apple-tab-span" style="white-space:pre"> </span>push<span class="Apple-tab-span" style="white-space:pre"> </span>r28
  b0:<span class="Apple-tab-span" style="white-space:pre"> </span>df 93       <span class="Apple-tab-span" style="white-space:pre"> </span>push<span class="Apple-tab-span" style="white-space:pre"> </span>r29

000000b2 &lt;loop&gt;:
  b2:<span class="Apple-tab-span" style="white-space:pre"> </span>5d 9b       <span class="Apple-tab-span" style="white-space:pre"> </span>sbis<span class="Apple-tab-span" style="white-space:pre"> </span>0x0b, 5<span class="Apple-tab-span" style="white-space:pre"> </span>; 11
  b4:<span class="Apple-tab-span" style="white-space:pre"> </span>fe cf       <span class="Apple-tab-span" style="white-space:pre"> </span>rjmp<span class="Apple-tab-span" style="white-space:pre"> </span>.-4      <span class="Apple-tab-span" style="white-space:pre"> </span>; 0xb2 &lt;loop&gt;
  b6:<span class="Apple-tab-span" style="white-space:pre"> </span>09 91       <span class="Apple-tab-span" style="white-space:pre"> </span>ld<span class="Apple-tab-span" style="white-space:pre"> </span>r16, Y+
  b8:<span class="Apple-tab-span" style="white-space:pre"> </span>00 23       <span class="Apple-tab-span" style="white-space:pre"> </span>and<span class="Apple-tab-span" style="white-space:pre"> </span>r16, r16
  ba:<span class="Apple-tab-span" style="white-space:pre"> </span>11 f0       <span class="Apple-tab-span" style="white-space:pre"> </span>breq<span class="Apple-tab-span" style="white-space:pre"> </span>.+4      <span class="Apple-tab-span" style="white-space:pre"> </span>; 0xc0 &lt;exit&gt;
  bc:<span class="Apple-tab-span" style="white-space:pre"> </span>0c b9       <span class="Apple-tab-span" style="white-space:pre"> </span>out<span class="Apple-tab-span" style="white-space:pre"> </span>0x0c, r16<span class="Apple-tab-span" style="white-space:pre"> </span>; 12
  be:<span class="Apple-tab-span" style="white-space:pre"> </span>f9 cf       <span class="Apple-tab-span" style="white-space:pre"> </span>rjmp<span class="Apple-tab-span" style="white-space:pre"> </span>.-14     <span class="Apple-tab-span" style="white-space:pre"> </span>; 0xb2 &lt;loop&gt;

000000c0 &lt;exit&gt;:
  c0:<span class="Apple-tab-span" style="white-space:pre"> </span>df 91       <span class="Apple-tab-span" style="white-space:pre"> </span>pop<span class="Apple-tab-span" style="white-space:pre"> </span>r29
  c2:<span class="Apple-tab-span" style="white-space:pre"> </span>cf 91       <span class="Apple-tab-span" style="white-space:pre"> </span>pop<span class="Apple-tab-span" style="white-space:pre"> </span>r28
  c4:<span class="Apple-tab-span" style="white-space:pre"> </span>0f 91       <span class="Apple-tab-span" style="white-space:pre"> </span>pop<span class="Apple-tab-span" style="white-space:pre"> </span>r16
  c6:<span class="Apple-tab-span" style="white-space:pre"> </span>08 95       <span class="Apple-tab-span" style="white-space:pre"> </span>ret


000000c8 &lt;_exit&gt;:
  c8:<span class="Apple-tab-span" style="white-space:pre"> </span>f8 94       <span class="Apple-tab-span" style="white-space:pre"> </span>cli

000000ca &lt;__stop_program&gt;:
  ca:<span class="Apple-tab-span" style="white-space:pre"> </span>ff cf       <span class="Apple-tab-span" style="white-space:pre"> </span>rjmp<span class="Apple-tab-span" style="white-space:pre"> </span>.-2      <span class="Apple-tab-span" style="white-space:pre"> </span>; 0xca &lt;__stop_program&gt;


Disassembly of section .data:

00800060 &lt;__data_start&gt;:
  800060:<span class="Apple-tab-span" style="white-space:pre"> </span>48 65       <span class="Apple-tab-span" style="white-space:pre"> </span>ori<span class="Apple-tab-span" style="white-space:pre"> </span>r20, 0x58<span class="Apple-tab-span" style="white-space:pre"> </span>; 88
  800062:<span class="Apple-tab-span" style="white-space:pre"> </span>6c 6c       <span class="Apple-tab-span" style="white-space:pre"> </span>ori<span class="Apple-tab-span" style="white-space:pre"> </span>r22, 0xCC<span class="Apple-tab-span" style="white-space:pre"> </span>; 204
  800064:<span class="Apple-tab-span" style="white-space:pre"> </span>6f 20       <span class="Apple-tab-span" style="white-space:pre"> </span>and<span class="Apple-tab-span" style="white-space:pre"> </span>r6, r15
  800066:<span class="Apple-tab-span" style="white-space:pre"> </span>77 6f       <span class="Apple-tab-span" style="white-space:pre"> </span>ori<span class="Apple-tab-span" style="white-space:pre"> </span>r23, 0xF7<span class="Apple-tab-span" style="white-space:pre"> </span>; 247
  800068:<span class="Apple-tab-span" style="white-space:pre"> </span>72 6c       <span class="Apple-tab-span" style="white-space:pre"> </span>ori<span class="Apple-tab-span" style="white-space:pre"> </span>r23, 0xC2<span class="Apple-tab-span" style="white-space:pre"> </span>; 194
  80006a:<span class="Apple-tab-span" style="white-space:pre"> </span>64 0a       <span class="Apple-tab-span" style="white-space:pre"> </span>sbc<span class="Apple-tab-span" style="white-space:pre"> </span>r6, r20
  80006c:<span class="Apple-tab-span" style="white-space:pre"> </span>0d 00       <span class="Apple-tab-span" style="white-space:pre"> </span>.word<span class="Apple-tab-span" style="white-space:pre"> </span>0x000d<span class="Apple-tab-span" style="white-space:pre"> </span>; ????

Disassembly of section .note.gnu.avr.deviceinfo:

00000000 &lt;.note.gnu.avr.deviceinfo&gt;:
   0:<span class="Apple-tab-span" style="white-space:pre"> </span>04 00       <span class="Apple-tab-span" style="white-space:pre"> </span>.word<span class="Apple-tab-span" style="white-space:pre"> </span>0x0004<span class="Apple-tab-span" style="white-space:pre"> </span>; ????
   2:<span class="Apple-tab-span" style="white-space:pre"> </span>00 00       <span class="Apple-tab-span" style="white-space:pre"> </span>nop
   ...
  36:<span class="Apple-tab-span" style="white-space:pre"> </span>61 31       <span class="Apple-tab-span" style="white-space:pre"> </span>cpi<span class="Apple-tab-span" style="white-space:pre"> </span>r22, 0x11<span class="Apple-tab-span" style="white-space:pre"> </span>; 17
  38:<span class="Apple-tab-span" style="white-space:pre"> </span>36 00       <span class="Apple-tab-span" style="white-space:pre"> </span>.word<span class="Apple-tab-span" style="white-space:pre"> </span>0x0036<span class="Apple-tab-span" style="white-space:pre"> </span>; ????</pre>
<p>
	<br>
	<u><strong>Schritt 6:</strong></u> Erzeugen der Programmierdateien</p>
<p>
	Aus der fertigen Programmdatei <em>prog</em> kann nun die reine Binärdatei <em>prog.raw</em> und die Programmer-Datei <em>prog.hex</em> (im Intel Hex Format) generiert werden. Es handelt sich dabei lediglich um eine Unwandlung aus einem Dateiformat in ein anderes.</p>
<div>
	<pre>user@linux-pc:~ $ <strong>avr-objcopy -O binary prog prog.raw
</strong></pre>
</div>
<pre>user@linux-pc:~ $ <strong>hexdump -C prog.raw</strong>
00000000  0c 94 2a 00 0c 94 3f 00  0c 94 3f 00 0c 94 3f 00  |..*...?...?...?.|
00000010  0c 94 3f 00 0c 94 3f 00  0c 94 3f 00 0c 94 3f 00  |..?...?...?...?.|
*
00000050  0c 94 3f 00 11 24 1f be  cf e5 d4 e0 de bf cd bf  |..?..$..........|
00000060  10 e0 a0 e6 b0 e0 ec ec  f0 e0 02 c0 05 90 0d 92  |................|
00000070  ae 36 b1 07 d9 f7 0e 94  41 00 0c 94 64 00 0c 94  |.6......A...d...|
00000080  00 00 0f e0 0a bb 0e e0  0b bb 00 27 00 bd 0b b9  |...........'....|
00000090  0c e0 09 b9 06 e8 00 bd  08 e0 0a b9 c0 e6 d0 e0  |................|
000000a0  0e 94 56 00 0b b3 01 27  0b bb f8 cf 0f 93 cf 93  |..V....'........|
000000b0  df 93 5d 9b fe cf 09 91  00 23 11 f0 0c b9 f9 cf  |..]......#......|
000000c0  df 91 cf 91 0f 91 08 95  f8 94 ff cf 48 65 6c 6c  |............Hell|
000000d0  6f 20 77 6f 72 6c 64 0a  0d 00                    |o world...|
000000da</pre>
<p>
	&nbsp;</p>
<div>
	<pre>user@linux-pc:~ $ <strong>avr-objcopy -O ihex prog prog.hex</strong></pre>
</div>
<pre>user@linux-pc:~ $ <strong>cat prog.hex</strong>
:100000000C942A000C943F000C943F000C943F0089
:100010000C943F000C943F000C943F000C943F0064
:100020000C943F000C943F000C943F000C943F0054
:100030000C943F000C943F000C943F000C943F0044
:100040000C943F000C943F000C943F000C943F0034
:100050000C943F0011241FBECFE5D4E0DEBFCDBF1E
:1000600010E0A0E6B0E0ECECF0E002C005900D92EC
:10007000AE36B107D9F70E9441000C9464000C948D
:1000800000000FE00ABB0EE00BBB002700BD0BB960
:100090000CE009B906E800BD08E00AB9C0E6D0E006
:1000A0000E9456000BB301270BBBF8CF0F93CF93E1
:1000B000DF935D9BFECF0991002311F00CB9F9CFBE
:0C00C000DF91CF910F910895F894FFCFCD
:0E00CC0048656C6C6F20776F726C640A0D00D3
:00000001FF</pre>
<p>
	Weitere Infos zum Intel-Hex Dateiformat siehe&nbsp;<a href="https://de.wikipedia.org/wiki/Intel_HEX" target="_blank">https://de.wikipedia.org/wiki/Intel_HEX</a></p>
<p>
	Diese Datei <em>prog.hex</em> kann nun mit einer Programmer-Software (zB Easyprogrammer) auf den Atmega16 geflasht werden.</p></div>
</div></div>
	    <script type="text/javascript">
		if (book_admin_p == 1) {
			$('.ibook_item div.book_v2').each(function (){
				$(this).sortable({
					items:'div.emmbedded-book-page-wrapper',
					handle:'div.ctxmenu',
					axis:'y',
					containment:'document',
					scroll:false,
					tolerance:'pointer',
					cursor:'move',
					update:function(e,ui){
						var els = $(this).sortable('serialize',{key:'el'}) + '&m=order';
						$.post(parent_url+'/'+$('#bookpage'+$('#ibook_current_page').val()).attr('parent'), els);
					}
				});
			});
			$('div.emmbedded-book-page-wrapper div.ctxmenu').hide();
			$('div.emmbedded-book-page-wrapper').on('mouseenter', function(){
				$(this).find('div.ctxmenu').show();
			});
			$('div.emmbedded-book-page-wrapper').on('mouseleave', function(){
				$('div.emmbedded-book-page-wrapper div.ctxmenu').hide();
			});
		}
	    </script>
	
	<script type="text/javascript" src="./4AHME FIVU - Mikroprozessor_files/jquery.lightbox.js.Download"></script>
	<link type="text/css" href="./4AHME FIVU - Mikroprozessor_files/jquery.lightbox.css" rel="stylesheet">
	<script type="text/javascript">
		$('#bookpage189537312 .emmbedded-book-page-wrapper.page img').each(function() {
        if ($(this).parent().is("a")) {return;}
			$(' <a title="'+$(this).attr('title')+'"  description=""  href="'+$(this).attr('src')+'"  class="page_img_189537312">  </a>  ').insertAfter(this).append(this);
		});
		$('#bookpage189537312 .emmbedded-book-page-wrapper.photo .photo-or-thumb a:first').addClass('page_img_189537312');
		$('#bookpage189537312 .emmbedded-book-page-wrapper.photo-album .photo-show .photo-container .thumbnail a').addClass('page_img_189537312');
		$('a.page_img_189537312').lightBox();
	</script>
    </div></div>
</div><div class="content-chunk-footer"></div>
</div><div id="bookpage189522806" class="ibook_item   loaded" item_id="189522806" data-order="1.8" count="9" parent="EC743ABCF7AB5/F607FABBC42B3" name="EC743ABCF7AB5/F607FABBC42B3/C99A4B07024AA" style="display: none;"><h2>Strukturierte Programmierung in C</h2> <br><div class="Form-bookpage_form"><div class="ipart_v2"><div class="book_v2"><div data-order="1" id="el_189522809" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3>Geschichte</h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><p>
	Mikroprozessoren wurden anfänglich direkt in Maschinensprache, etwas später (1960-1990) in Assembler-Quelltext programmiert. Der Assembler-Quelltext wurde mit einem Assembler in ein Objektformat übersetzt, und der Linker sorgte für das Zusammenfügen der Objektdateien in ein ausführbares Maschinenprogramm.</p>
<p>
	Damit waren möglich:</p>
<ul>
	<li style="margin-bottom:7px">
		<strong>Befehlssequenzen</strong> (ein Befehl nach dem anderen)</li>
	<li style="margin-bottom:7px">
		<strong>Verzweigungen</strong> (Status Flags in Kombination mit bedingten Sprungbefehlen)<br>
		Beispiel:&nbsp;<em>beq</em>&nbsp;... branch equal ... springe wenn das Z-Flag gesetzt ist</li>
	<li style="margin-bottom:7px">
		<strong>Programmsprünge</strong> (<em>jmp</em>)</li>
	<li style="margin-bottom:7px">
		<strong>Programmsprünge mit Rückkehrmöglichkeit</strong> (<em>call</em>)<br>
		Hier wird bei einem&nbsp;<strong>call</strong>&nbsp;die Adresse des kommenden Befehls am Stack gespeichert und die gewünschte Adresse (das Sprungziel) in den Program Counter gespeichert. Mit dem Befehl&nbsp;<strong>ret</strong>&nbsp;wird ein Wert vom Stack geholt und in den Program Counter geschrieben. Somit wird mit <strong>ret</strong> der Rücksprung an die ursprüngliche Wegsprungstelle realisiert.</li>
	<li>
		<strong>Interrupts</strong> (automatische Unterbrechung und Rückkehrmöglichkeit)</li>
</ul>
<p>
	Ein grafische Darstellung des Programmflusses erfolgt mit einem Flussdiagramm (<em>flow chart</em>), heute (nach der Normunung) auch Programmablaufplan genannt: siehe auch&nbsp;<a href="https://de.wikipedia.org/wiki/Programmablaufplan" target="_blank">https://de.wikipedia.org/wiki/Programmablaufplan</a></p>
<p>
	<br>
	Mit größer werdenden Programmen stellte sich bald heraus, dass es sehr aufwändig wurde fehlerfreie Programme zu erstellen. Auch die Wartung und Weiterpflege bestehender Software gestaltete sich zunehmend schwierig. Eine Wiederverwendung bereits bestehender Lösung war so gut wie unmöglich.</p>
<p>
	Daher entstanden in den frühen 1970er und 1980er Jahren eine Reihe von <strong>höheren Programmiersprachen</strong> die dem Programmierparadigma der <strong>strukturierten Programmierung</strong> folgten.</p>
<p>
	Eine dieser strukturierten Sprachen ist die <strong>Programmiersprache C</strong>. Sie hat bis heute überlebt, da es sich um eine sehr hardwarenahe Sprache handelt und sie sich daher sehr gut im Bereich einfacher Microcontroller bewährt. Aber auch Teile des Betriebssystem-Kernels oder von Gerätetreibern sind heute noch in der Sprache C geschrieben.</p>
<p>
	Erst in den 1990 Jahren entwickelten sich objektorientierte Sprachen bei denen Objekte eine zentrale Rolle spielen.</p>
<p>
	&nbsp;</p></div>
</div></div><div data-order="2" id="el_189570355" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3>Merkmale der strukturierten Programmierung</h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><p>
	Merkmale der strukturierten Programmierung sind:</p>
<ul>
	<li style="margin-bottom:7px">
		Eine große Aufgabe wird mit Hilfe von Funktionen (oder Prozeduren) in kleinere Aufgaben zerlegt.<br>
		Diese Funktionen stellen im Optimalfall eine in sich abgeschlossene Lösung dar und können in anderen Projekten wiederverwendet werden.</li>
	<li style="margin-bottom:7px">
		In einer Funktion stehen <strong>Programmsequenzen</strong>, <strong>Verzweigungen</strong>, <strong>Wiederholungen</strong> (Schleifen) und natürlich <strong>Funktionsaufrufe</strong> zur Verfügung</li>
</ul>
<p>
	Wir sprechen bei diesen Sprachen auch von&nbsp;<strong>prozeduralen Sprachen</strong>, da hier die Prozeduren ( = Funktionen in C) eine zentrale Rolle einnehmen.</p>
<div>
	Eine grafische Darstellung kann mit Struktogrammen erfolgen, siehe auch&nbsp;<a href="https://de.wikipedia.org/wiki/Nassi-Shneiderman-Diagramm" target="_blank">https://de.wikipedia.org/wiki/Nassi-Shneiderman-Diagramm</a></div>
<p>
	Im Gegensatz zur Assembler-Programmierung gibt es in der strukturierten Programmierung nur bei Verzweigungen, Schleifen und Funktionsaufrufen und Funktionsrücksprungen einen Sprung in der Befehlsabarbeitung. Andere Sprünge, wie sie bei Assembler zum Beispiel mit dem Befehl JMP möglich sind, gibt es nicht.</p>
<p>
	Die Programmiersprache C verfügt mit dem Schlüsselwort <strong>goto</strong> über die Möglichkeit direkter Sprünge. Sie sollten am besten gar nicht, oder nur in bestimmten wenigen Ausnahmefällen (zum Beispiel bei der Fehlerbehandlung) angewendet werden.</p>
<p>
	&nbsp;</p></div>
</div></div><div data-order="3" id="el_189102385" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3>Übersetzungsvorgang</h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><p>
	Programme werde heute normalerweise in einer höheren Programmiersprache geschrieben. Beispiele solcher Sprachen sind C, C++, Java, C#, ...</p>
<p>
	Die dabei verwendeten Programmanweisungen sind für eine direkte Ausführung auf einem Mikroprozessor ungeeignet. Daher wird mit Hilfe eines anderen Programmes das Programm, genauer gesagt der Programmquelltext (Source-Code), in Maschinenbefehle übersetzt.</p>
<p>
	Das für die Übersetzung verwendete Programm wird <strong>Compiler</strong> genannt, bzw. ist Teil einer Tool-Familie, die unter dem Begriff <strong>Compiler-Suite</strong> zusammengefasst wird.</p>
<p>
	Wir verwenden bei unseren Übungen den GNU-Compiller <em>gcc</em> (bzw. den <em>avrgcc</em> für Atmel 8-Bit µCs).</p>
<p>
	Das folgende Bild (Quelle: <a href="https://de.wikipedia.org/wiki/GNU_Compiler_Collection" target="_blank">https://de.wikipedia.org/wiki/GNU_Compiler_Collection</a>) zeigt den Übersetzungsvorgang:</p>
<p style="text-align: center;">
	<a title="GCC Übersetzungsvorgang" description="" href="./4AHME FIVU - Mikroprozessor_files/gcc_schema_svg" class="page_img_189522806">  <img type="wikilink" class="image" src="./4AHME FIVU - Mikroprozessor_files/gcc_schema_svg" alt="GCC Übersetzungsvorgang" title="GCC Übersetzungsvorgang" style="width:  500px;height:  823px;"></a></p>
<p>
	Zunächst wird der C-Qellcode präprozessiert. Dabei werden alle Präprozessoranweisungen (<em>#include, #define, #ifdef, ...</em>) verarbeitet.</p>
<p>
	Anschließend erfolgt durch den Compiler die eigentliche Übersetzung der C-Anwesiungen in Assembler (Quelltext). Darin sind in textueller Form nur mehr die Befehle enthalten, die der Mikroprozessor tatsächlich ausführen kann.</p>
<p>
	Danach wird vom (Programm) <strong>Assembler</strong> der Assemblerquelltext in die binären Maschinenbefehlsmuster übersetzt. Es entsteht dadurch eine <strong>Objektdatei</strong> (Endung .o). In der Objektdatei sind Sprungziele (zB bei Funktionsaufrufen) nur als Symbole vermerkt, da noch nicht festgelegt worden ist an welcher konkreten Adresse des Programmspeichers die Maschinenbefehle abgelegt werden.</p>
<p>
	Der Linker fügt alle Maschinenbefehle aus den verschiedenen Objektdateien und aus Bibliotheken (zB für die Funktion <em>printf</em>) zusammen. Er muss entscheiden an welcher Speicheradresse die einzelnen Programmteile positioniert werden (<strong>Relocation</strong>). Jetzt können auch die Adresssymbole (des Compilers) durch echte Adressen ersetzt werden.</p>
<p>
	Danach ist das Programm zur Ausführung auf einer CPU bereit. Sofern mit der Option -o nichts anderes festgelegt wird, erzeugt der <em>gcc</em> auf einem Windows-System die Datei aout.exe, bzw. bei µCs oder auf Linux die Datei a.out</p>
<p>
	&nbsp;</p></div>
</div></div>
	    <script type="text/javascript">
		if (book_admin_p == 1) {
			$('.ibook_item div.book_v2').each(function (){
				$(this).sortable({
					items:'div.emmbedded-book-page-wrapper',
					handle:'div.ctxmenu',
					axis:'y',
					containment:'document',
					scroll:false,
					tolerance:'pointer',
					cursor:'move',
					update:function(e,ui){
						var els = $(this).sortable('serialize',{key:'el'}) + '&m=order';
						$.post(parent_url+'/'+$('#bookpage'+$('#ibook_current_page').val()).attr('parent'), els);
					}
				});
			});
			$('div.emmbedded-book-page-wrapper div.ctxmenu').hide();
			$('div.emmbedded-book-page-wrapper').on('mouseenter', function(){
				$(this).find('div.ctxmenu').show();
			});
			$('div.emmbedded-book-page-wrapper').on('mouseleave', function(){
				$('div.emmbedded-book-page-wrapper div.ctxmenu').hide();
			});
		}
	    </script>
	
	<script type="text/javascript" src="./4AHME FIVU - Mikroprozessor_files/jquery.lightbox.js.Download"></script>
	<link type="text/css" href="./4AHME FIVU - Mikroprozessor_files/jquery.lightbox.css" rel="stylesheet">
	<script type="text/javascript">
		$('#bookpage189522806 .emmbedded-book-page-wrapper.page img').each(function() {
        if ($(this).parent().is("a")) {return;}
			$(' <a title="'+$(this).attr('title')+'"  description=""  href="'+$(this).attr('src')+'"  class="page_img_189522806">  </a>  ').insertAfter(this).append(this);
		});
		$('#bookpage189522806 .emmbedded-book-page-wrapper.photo .photo-or-thumb a:first').addClass('page_img_189522806');
		$('#bookpage189522806 .emmbedded-book-page-wrapper.photo-album .photo-show .photo-container .thumbnail a').addClass('page_img_189522806');
		$('a.page_img_189522806').lightBox();
	</script>
    </div></div>
</div><div class="content-chunk-footer"></div>
</div><div id="bookpage189503049" class="ibook_item   loaded" item_id="189503049" data-order="1.8.1" count="10" parent="EC743ABCF7AB5/F607FABBC42B3/C99A4B07024AA" name="EC743ABCF7AB5/F607FABBC42B3/C99A4B07024AA/07DF9D4FB10E6" style="display: block;"><h2>Speicherverwaltung</h2> <br><div class="Form-bookpage_form"><div class="ipart_v2"><div class="book_v2"><div data-order="1" id="el_189503052" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3>GNU C-Compiler Sections</h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><style type="text/css">
li {margin-bottom:8px}</style>
<p>
	Siehe auch: <a href="http://www.rn-wissen.de/index.php/Avr-gcc/Interna#Sections" target="_blank">http://www.rn-wissen.de/index.php/Avr-gcc/Interna#Sections</a></p>
<p>
	Speicherblöcke werden beim GNU Compiler (<em>gcc</em> und <em>avr-gcc</em>) in sogenannten <strong>Sections</strong> verwaltet. Sie sind vergleichbar mit Kastenladen, in die bestimmte Dinge die zusammengehören abgelegt werden.</p>
<p>
	Sections sind zusammenhängende Speicherbereiche, die an einer bestimmten Speicheradresse beginnen und eine bestimmte Anzahl an Bytes groß sind.</p>
<p>
	Die wichtigsten vordefinierten Sections sind:</p>
<ul>
	<li>
		<strong>.text</strong><br>
		Normaler Program-Code (Maschinenbefehle) im Flash</li>
	<li>
		<strong>.data</strong><br>
		Daten im SRAM die initialisiert werden (zum Beispiel globale Variable)</li>
	<li>
		<strong>.rodata</strong><br>
		Daten die nur gelesen werden. Werden vom avr-gcc als <em>.data</em> Sections behandelt und somit im SRAM abgelegt.</li>
	<li>
		<strong>.bss</strong><br>
		Daten im SRAM die mit 0 initialisiert werden.</li>
</ul>
<p>
	Bei den µCs der megaAVR Familie legt der avr-gcc Linker die <em>.text</em> Sections automatisch in den Flash-Speicher. Die restlichen Sections werden wie folgt am Anfang des SRAM Arbeitsspeichers angelegt (niedrige Adresse links, hohe Adressen rechts).</p>
<p>
	&nbsp;</p></div>
</div></div><div data-order="1" id="el_189570551" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3>Heap</h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><p>
	Unter einem Heap wird ein Speicherhaufen verstanden. Er wird in der Programmiersprache C für die dynamische Speicherverwaltung benötigt.</p>
<p>
	Mit der C-Bibliotheksfunktion <em>malloc(...)</em> (=<strong>m</strong>emory <strong>alloc</strong>ate) kann ein Speicherblock im Heap reserviert (allokiert) werden. Als Parameter wird die benötigte Größe in bytes verwendet. Der Rückgabewert ist ein Zeiger auf den Beginn des allokierten Speicherblocks im Heap.</p>
<p>
	Mit der C-Bliotheksfunktion <em>free(...)</em> kann ein zuvor allokierter Block wieder frei gegeben werden. Als Parameter wird der von der Funktion <em>malloc</em> zurückgelieferte Zeiger verwendet.</p>
<p>
	Bei µCs mit einem kleinen Arbeitsspeicher wird oftmals auf die Verwendung der dynamischen Speicherverwaltung verzichtet. Alle verwendeten Variablen werden als statische Variable an fixen Speicheradressen oder als lokale Variablen am Stack angelegt.</p>
<p>
	Wird auch auf rekursive Funktionsaufrufe und Interrupts innherhalb von Interrupt-Service Routinen verzichtet, so kann der Bedarf an Stack-Speicher exakt bestimmt werden. Ein unbeabsichtigter "Out of Memory" bzw. Stack-Overflow kann dann mit Sicherheit ausgeschlossen werden. Unter Umständen ist das für die Zertifizierung von Software-Applikationen in sicherheitskritischen Anwendungen nötig.</p>
<p>
	Auch wir werden bei den Programmierübungen mit dem Atmega16 und Atmega328P auf die Verwendung der dynamischen Speicherverwaltung verzichten.</p>
<p>
	&nbsp;</p></div>
</div></div><div data-order="2" id="el_189508874" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3>C und die Harvard-Architektur</h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><p>
	Bei den µCs der Atmel mageAVR Familie (Atmega16, Atmega328P, ...) ist ein völlig getrennter Programm- und Arbeitspeicher realisiert. Das entspricht dem Prinzip der Harvard-Architektur.</p>
<p>
	Für den Arbeitsspeicher ist ein statisches RAM (SRAM) und für den Programmspeicher eine Flash realisiert. Zusätzlich gibt es noch ein EEPROM.</p>
<pre style="font-size:80%">                         |      Atmega16       |     Atmega328P      |     At90CAN128
-------------------------+---------------------+---------------------+-----------------------
Arbeitsspeicher (SRAM)   |  1 KiB =  1024 Byte |  2 KiB =  2048 Byte |   4 KiB =   4096 Byte
Programmspeicher (Flash) | 16 KiB = 16384 Byte | 32 KiB = 32768 Byte | 128 KiB = 131072 Byte
EEPROM                   |            512 byte |           1024 Byte |             4096 Byte
</pre>
<p>
	Das EEPROM wird gerne für die Speicherung von Kalibrierdaten verwendet. Die Daten im EEPROM gehen bei Abschaltung der Versorgungsspannung nicht verloren und bleiben beim "<em>flashen"</em> eines neuen Programmes unverändert. Darüber hinaus lassen sich Bytes im EEPROM byteweise lesen und schreiben, während Daten im Flash nur blockweise (als Flash-Page, beim Atmega16 128 Byte groß) gelöscht und geschrieben werden können.</p>
<p>
	Die Programmiersprache C ist für eine solche Harvard-Architektur nicht ausgelegt. Der Datentyp <em>Zeiger</em>&nbsp;(<em>Pointer</em>) kann nur die Adresse für Daten im SRAM speichern. Es können daher mit Zeigern in C nur Variable im SRAM, sowie I/O-Register und CPU-Register addressiert werden, nicht aber Konstante oder Maschinenbefehler im programmspeicher oder Daten im EEPROM. Der Zugriff auf Inhalte im Programmspeicher oder EEPROM-Speicher erfolgt daher über spezielle Funktionen der avr-libc.</p>
<div>
	Der Zugriff auf Adressen von I/O-Registern wird vom <em>avr-gcc</em> automatisch in I/O-Register Befehle (<em>IN</em>, <em>OUT</em>) umgewandelt.</div>
<p>
	Werden Konstante bei der Programmlaufzeit benötigt, so werden diese vor Beginn der <em>main()</em> Funktion durch den automatisch hinzugefügten startup-code vom Programmspeicher in den Arbeitsspeicher transferiert.</p>
<p>
	<u>Beispiel:</u> Atmega16:</p>
<pre>printf("Guten Morgen\n");</pre>
<p>
	Die konstante Textzeichenkette <em>"Guten Morgen\n"</em> befindet sich zweimal im Speicher, einmal im Programmspeicher, wo sie bei Abschaltung der Versorgungsspannung nicht verloren gehen kann, und einmal im SRAM (Section <em>.data</em>).</p>
<p>
	Ursache:<br>
	Bim Aufruf der <em>printf</em>-Funktion wird ein Zeiger auf den Text übergeben. Da der Zeiger nur auf etwas im SRAM zeigen kann, muss der startup-code zu Beginn den Text aus dem Programmspeicher (Flash) in das SRAM kopieren.</p>
<p>
	Bei sehr vielen solchen Texten im Programm ist man daher mit der Situation konfrontiert, dass sowohl Programm- als auch Arbeitsspeicher für diese Texte reserviert wird und anderen Aufgaben (zB Variablen) nicht mehr zur Verfügung steht.</p>
<p>
	&nbsp;</p></div>
</div></div><div data-order="3" id="el_189507988" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3>Beispiel: Arbeitsspeicher beim Atmega16</h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><style type="text/css">
li {margin-bottom:8px}</style>
<p>
	Beim Atmega16 ist der Arbeitsspeicher in einem internen 1024 (=0x400) Byte großen SRAM realisiert. Allerdings beginnt das SRAM nicht bei Adresse 0, sondern erst bei Adresse 0x60.</p>
<p>
	Auf den ersten Adressen sind die 32 CPU-Register R0...R31, und dahinter die diversen I/O-Register (<em>SREG</em>, <em>SPH</em>, <em>SPL</em>, DDRA, <em>PORTA</em>, ...) abgebildet (<em>gemappt</em>).&nbsp;</p>
<div style="text-align: center;">
	<a title="Arbeitsspeicher beim Atmega16" description="" href="./4AHME FIVU - Mikroprozessor_files/speicherverwaltung_svg" class="page_img_189503049">  <img type="wikilink" class="image" src="./4AHME FIVU - Mikroprozessor_files/speicherverwaltung_svg" alt="Arbeitsspeicher beim Atmega16" title="Arbeitsspeicher beim Atmega16" style="width:  500px;height:  510px;"></a></div>
<p>
	Der zwischen Heap und Stack verbleibende Speicher ist der <strong><em>freie Speicher</em></strong>.</p>
<p>
	Bei dynamischer Speicherverwaltung wächst der Heap nach unten (also in Richtung größerer Adressen). Ist kein freier Speicher mehr verfügbar kommt es zu einem <em>Out of Memory</em>. Bei manchen Systemen liefert die Funktion <em>alloc()</em>&nbsp;dann den Wert NULL.</p>
<p>
	Der Stack wächst immer nach oben (in Richtung kleinerer Adressen). Ist kein freier Speicher mehr vorhanden kommt es zu einem Out-of-Stack-Memory Fehler. Überprüft ein System das nicht und beginnt bei einem <em>push</em> (oder <em>call</em>) in den Heap zu schreiben, so kommt es zu einem <strong>Stack-Overflow</strong>. Ein Stack-Overflow ist eine schwerwiegende Programmfehlfunktion und führt früher oder später wahrscheinlich zu einem Programmabsturz.</p>
<p>
	Bei manchen Mikroprozessoren sind in der CPU spezielle Register vorgesehen, mit deren Hilfe ein Stack-Overflow als Stack-Overflow Exception behandelt werden kann, und somit ein Stack-Overflow und der damit verbundene Programmabsturz vermieden wird. Bei den megaAVR µCs gibt es solche Register oder Stack-Overflow Exceptions nicht.</p>
<p>
	&nbsp;</p></div>
</div></div><div data-order="4" id="el_189503058" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3>Sections für Spezialaufgaben</h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><style type="text/css">
li {margin-bottom:8px}</style>
<p>
	Neben den wichtigen Sections <em>.text</em>, <em>.data</em> und<em> .bss</em> sind beim <em>gcc</em> /&nbsp;<em>avr-gcc</em> fallweise noch folgende Sections in Verwendung:</p>
<ul>
	<li>
		<em><strong>.progmem.data</strong></em><br>
		Wird für <em>Read Only Daten</em> verwendet, die im Flash platziert werden. Der Zugriff erfolgt über spezielle Bibliotheks-Routinen.</li>
	<li>
		<em><strong>.eeprom</strong></em><br>
		Wird für Variablen verwendet die im EEPROM platziert werden.</li>
	<li>
		<em><strong>.noinit</strong></em><br>
		Diese Section ist eigentlich Teil der <em>.bss</em> Section. Allerdings werden Variable in diesem Bereich nicht initialisiert.</li>
	<li>
		<strong><em>.init0, .inint1, ... , .init9</em></strong><br>
		Diese Sections sind Teil der <em>.text</em> Section. Hier wird Startup-Code platziert, der vor Ausführung der Funktion main() ausgeführt wird. <em>.init0,</em> <em>.init2</em> und <em>.init4</em>, <em>.init6</em> und <em>.init9</em> werden normalerweise vom C/C++ Compiler verwendet, der Rest kann vom Programmierer verwendet werden.</li>
	<li>
		<em><strong>.fin0, .fin1, ... , fin9</strong></em><br>
		Diese Sections sind Teil der <em>.text</em> Section. Hier wird Startup-Code platziert, der nach Ausführung der Funktion main(), oder bei Aufruf der Funktion <em>exit()</em>&nbsp; ausgeführt wird. <em>.fin6 </em>und fin0 werden normalerweise vom C/C++ Compiler verwendet, der Rest kann vom Programmierer verwendet werden.</li>
	<li>
		<em><strong>.vector</strong></em><br>
		Für Interrupt und Reset Vektoren (Tabelle mit Sprügen zur ISR)</li>
	<li>
		<strong><em>.bootloader</em></strong><br>
		Für Bootloader Programm-Code.</li>
	<li>
		<em><strong>.stab*</strong></em> und <em><strong>.debug*</strong></em><br>
		Debug-Info die normalerweise nicht geladen wird.</li>
</ul>
<p>
	&nbsp;</p></div>
</div></div><div data-order="5" id="el_189503061" class="emmbedded-book-page-wrapper page ready"><span style="float: right;"></span><h3>Registerverwendung beim avr-gcc bei den Atmel megaAVR µCs</h3><div class="Form-page_form"><div class="xolrn-page-wrapper"><style type="text/css">
li {margin-bottom:8px}</style>
<p>
	Normalerweise werden bei Funktionsaufrufen Rücksprungadressen, Funktionsparameter, lokale Variable und Funktionsrückgabewerte am Stack abgelegt.</p>
<p>
	Aus Gründen der Performance und der Minimierung des erforderlichen Flash Speichers verwendet der avr-gcc für Funktionsparameter, lokale Variable und Funktionsrückgabewerte normalerweise die CPU-Register (General Purpose Registers). Erst wenn diese nicht reichen, verwendet der Compiler zusätzlich Stack-Speicher. Daher sollten niemals große Strukturen als Parameter übergeben bzw. zurückgegeben werden! Stattdessen werden große Strukturen oft als gloable Variable, oder lokale Variable im Funktionsblock der Startfunktion <em>main()</em> definiert (erzeugt).</p>
<p>
	Die Register werden wie folgt verwendet:</p>
<ul>
	<li>
		<strong>R0</strong><br>
		temporäres Arbeitsregister</li>
	<li>
		<strong>R1</strong><br>
		enthält immer den Wert 0</li>
	<li>
		<strong>R1-R17, R28-R29(Y)</strong><br>
		Register, die durch einen Funktionsaufruf nicht verändert werden dürfen.<br>
		Falls sie in einer Funktion verändert werden, muss deren Inhalt vorher am Stack gesichert und nachher vom Stack wiederhergestellt werden.</li>
	<li>
		<strong>R18-R27, R30-R31(Z)</strong><br>
		Register, die durch den Funktionsaufruf verändert werden dürfen.</li>
</ul>
<p>
	Für Parameterübergaben und Funktionsrückgabewerte werden die Register R8 bis R25 verwendet. Dabei wird auf 16 Bit gerundet und mit R25 begonnen.</p>
<p>
	Beispiel:</p>
<pre>int32_t function (uint16_t x, uint8_t y, uint32_t z);</pre>
<p>
	Es wird <em>x</em> in den Registern <em>R25:R24</em>, <em>y</em> im Register <em>R22 und</em> <em>z</em> in den Registern <em>R21:R20:R19:R18</em> übergeben. Der Rückgabewert wird in den Registern <em>R22:R23:R24:R25</em> übergeben. Da <em>y</em> ein 8-Bit Wert ist, wird <em>R23</em> nicht verwendet.</p>
<p>
	&nbsp;</p></div>
</div></div>
	    <script type="text/javascript">
		if (book_admin_p == 1) {
			$('.ibook_item div.book_v2').each(function (){
				$(this).sortable({
					items:'div.emmbedded-book-page-wrapper',
					handle:'div.ctxmenu',
					axis:'y',
					containment:'document',
					scroll:false,
					tolerance:'pointer',
					cursor:'move',
					update:function(e,ui){
						var els = $(this).sortable('serialize',{key:'el'}) + '&m=order';
						$.post(parent_url+'/'+$('#bookpage'+$('#ibook_current_page').val()).attr('parent'), els);
					}
				});
			});
			$('div.emmbedded-book-page-wrapper div.ctxmenu').hide();
			$('div.emmbedded-book-page-wrapper').on('mouseenter', function(){
				$(this).find('div.ctxmenu').show();
			});
			$('div.emmbedded-book-page-wrapper').on('mouseleave', function(){
				$('div.emmbedded-book-page-wrapper div.ctxmenu').hide();
			});
		}
	    </script>
	
	<script type="text/javascript" src="./4AHME FIVU - Mikroprozessor_files/jquery.lightbox.js.Download"></script>
	<link type="text/css" href="./4AHME FIVU - Mikroprozessor_files/jquery.lightbox.css" rel="stylesheet">
	<script type="text/javascript">
		$('#bookpage189503049 .emmbedded-book-page-wrapper.page img').each(function() {
        if ($(this).parent().is("a")) {return;}
			$(' <a title="'+$(this).attr('title')+'"  description=""  href="'+$(this).attr('src')+'"  class="page_img_189503049">  </a>  ').insertAfter(this).append(this);
		});
		$('#bookpage189503049 .emmbedded-book-page-wrapper.photo .photo-or-thumb a:first').addClass('page_img_189503049');
		$('#bookpage189503049 .emmbedded-book-page-wrapper.photo-album .photo-show .photo-container .thumbnail a').addClass('page_img_189503049');
		$('a.page_img_189503049').lightBox();
	</script>
    </div></div>
</div><div class="content-chunk-footer"></div>
</div><div id="bookpage189509994" class="ibook_item  " item_id="189509994" data-order="1.8.2" count="11" parent="EC743ABCF7AB5/F607FABBC42B3/C99A4B07024AA" name="EC743ABCF7AB5/F607FABBC42B3/C99A4B07024AA/168ACBA263CA9" style="display: none;"><h2>Speicherverwendung in C</h2></div><div id="bookpage189570773" class="ibook_item  " item_id="189570773" data-order="1.8.3" count="12" parent="EC743ABCF7AB5/F607FABBC42B3/C99A4B07024AA" name="EC743ABCF7AB5/F607FABBC42B3/C99A4B07024AA/E155BB4D3FD11" style="display: none;"><h2>Die Übersetzung mit make</h2></div><div id="bookpage188395513" class="ibook_item  " item_id="188395513" data-order="1.9" count="13" parent="EC743ABCF7AB5/F607FABBC42B3" name="EC743ABCF7AB5/F607FABBC42B3/2825CDA9B768C" style="display: none;"><h2>Interrupts</h2></div></div><input id="ibook_current_page" type="hidden" value="189503049">
	<script type="text/javascript">
	    $(document).ready(function(){
	        $(function () { 
	$("#moveable_tax_container").jstree({
		"json_data" : {
			"data" : {
				"data" : {
					"title" : "Inhaltsverzeichnis",
					"attr" : { "href" : "#0", "data-id" : "node188315281", "class" : "ibook-toc current_page" }
				},
				"state": "open",
				"children": [
      {
	"data":  { 
			"title" : "1 Mikroprozessor (µP) und CPU",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#188315330", "data-id" : "node188315330", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   
      {
	"data":  { 
			"title" : "1.1 Steuerwerk",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#188315342", "data-id" : "node188315342", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},
      {
	"data":  { 
			"title" : "1.2 Maschinenbefehle",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#188315363", "data-id" : "node188315363", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},
      {
	"data":  { 
			"title" : "1.3 Rechenwerk und Status-Flags",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#188315351", "data-id" : "node188315351", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},
      {
	"data":  { 
			"title" : "1.4 Mikroprozessorsysteme",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#188395501", "data-id" : "node188395501", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},
      {
	"data":  { 
			"title" : "1.5 Speicher",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#188395479", "data-id" : "node188395479", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},
      {
	"data":  { 
			"title" : "1.6 Der Stack",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#189566980", "data-id" : "node189566980", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},
      {
	"data":  { 
			"title" : "1.7 Assembler",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#189537312", "data-id" : "node189537312", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},
      {
	"data":  { 
			"title" : "1.8 Strukturierte Programmierung in C",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#189522806", "data-id" : "node189522806", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   
      {
	"data":  { 
			"title" : "1.8.1 Speicherverwaltung",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#189503049", "data-id" : "node189503049", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},
      {
	"data":  { 
			"title" : "1.8.2 Speicherverwendung in C",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#189509994", "data-id" : "node189509994", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},
      {
	"data":  { 
			"title" : "1.8.3 Die Übersetzung mit make",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#189570773", "data-id" : "node189570773", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},]},
      {
	"data":  { 
			"title" : "1.9 Interrupts",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#188395513", "data-id" : "node188395513", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},]},]
			}
		},
		"plugins" : ["themes", "json_data",  "ui"]
	}).bind("select_node.jstree", function (e, data) {
		window.location = data.rslt.obj[0].childNodes[1].href;
	});
     });
	        $(function () { 
	$("#tax_container").jstree({
		"json_data" : {
			"data" : {
				"data" : {
					"title" : "Inhaltsverzeichnis",
					"attr" : { "href" : "#0", "data-id" : "node188315281", "class" : "ibook-toc current_page" }
				},
				"state": "open",
				"children": [
      {
	"data":  { 
			"title" : "1 Mikroprozessor (µP) und CPU",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#188315330", "data-id" : "node188315330", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   
      {
	"data":  { 
			"title" : "1.1 Steuerwerk",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#188315342", "data-id" : "node188315342", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},
      {
	"data":  { 
			"title" : "1.2 Maschinenbefehle",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#188315363", "data-id" : "node188315363", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},
      {
	"data":  { 
			"title" : "1.3 Rechenwerk und Status-Flags",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#188315351", "data-id" : "node188315351", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},
      {
	"data":  { 
			"title" : "1.4 Mikroprozessorsysteme",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#188395501", "data-id" : "node188395501", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},
      {
	"data":  { 
			"title" : "1.5 Speicher",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#188395479", "data-id" : "node188395479", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},
      {
	"data":  { 
			"title" : "1.6 Der Stack",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#189566980", "data-id" : "node189566980", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},
      {
	"data":  { 
			"title" : "1.7 Assembler",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#189537312", "data-id" : "node189537312", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},
      {
	"data":  { 
			"title" : "1.8 Strukturierte Programmierung in C",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#189522806", "data-id" : "node189522806", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   
      {
	"data":  { 
			"title" : "1.8.1 Speicherverwaltung",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#189503049", "data-id" : "node189503049", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},
      {
	"data":  { 
			"title" : "1.8.2 Speicherverwendung in C",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#189509994", "data-id" : "node189509994", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},
      {
	"data":  { 
			"title" : "1.8.3 Die Übersetzung mit make",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#189570773", "data-id" : "node189570773", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},]},
      {
	"data":  { 
			"title" : "1.9 Interrupts",
			"icon" : "/resources/xolrn/img/aktiv_inaktiv_startseite.png",
			"attr" : { "href" : "#188395513", "data-id" : "node188395513", "class" : "  " }
		} ,
	"state": "open",
	"children": [
   ]},]},]
			}
		},
		"plugins" : ["themes", "json_data",  "ui"]
	}).bind("select_node.jstree", function (e, data) {
		window.location = data.rslt.obj[0].childNodes[1].href;
	});
     });
	        
		/*$('#my_pages').cycle({
			fx: 'scrollHorz',
			fit: 1,
			startingSlide: 0,
			timeout: 0
		});
		link_to_page($('#ibook_current_page').val());
		start_animation();*/

		$('.dropdown_').hover(function() {
			$('.dropdown_ > ul').show();
		}, function() {
			$('.dropdown_ > ul').hide();
		});
	    });
	</script>
    </div>
</div><div class="content-chunk-footer"></div>

</div><div class="content-chunk-footer"></div>

    </div>
</div>

<div id="ibook-bottom" class="ibook_v2">
<table class="ibook-bar"><tbody><tr>
  <td class="btn_prev" onclick="change_page(0);"></td><td>&nbsp;</td>
  <td class="btn_next" onclick="change_page(1);">
</td></tr></tbody></table>
</div>

<div id="book-btn-prev" class="btn_prev" onclick="change_page(0);"></div>
<div id="book-btn-next" class="btn_next" onclick="change_page(1);"></div>

  <script type="text/javascript">
    function insert_question (type) {
        $('#question_dialog').dialog('close');
        var params = '?m=insert_template_object&object_name=en:'+type+'&return_url=%2fdotlrn%2fclasses%2finformatik%2f610437.4AHME_FIVU.17_18%2fxolrn%2fEC743ABCF7AB5.symlink%3fresource_id%3d0-237409759%26m%3dview&category_id=';
        loading_popup_redirect('show', 'Füge die Frage ein!', location.protocol+'//'+location.host+question_base_url+params);
    }
    function show_questions_dialog (base_url) {
        $('#question_dialog').dialog({height:365,width:850});
        if(typeof base_url !== "undefined") {
            question_base_url = base_url.split('?')[0];
        } else if(typeof parent_url !== "undefined") {
            //parent_url is set in www/view-*
            if ($('#ibook_current_page').length) {
                question_base_url = parent_url+'/'+$('#bookpage'+$('#ibook_current_page').val()).attr('name');
            } else {
                question_base_url = parent_url;
            }
        }
    }
    if(typeof parent_url !== "undefined") {
        if ($('#ibook_current_page').length) {
            question_base_url = parent_url+'/'+$('#bookpage'+$('#ibook_current_page').val()).attr('name');
        } else {
            question_base_url = parent_url;
        }
    } else {
        //test context
        question_base_url = index_link;
    }
</script>
<div class="question_dialog" id="question_dialog" title="Neue Frage einfügen">
    <table>
        <colgroup><col width="210px">
        <col width="210px">
        <col width="210px">
        <col width="210px">
        </colgroup><tbody><tr>
            
                <td class="active_td">
                    <a href="javascript:insert_question(&#39;multiple_choice_question&#39;);">
                        <div class="xoqti_multiple_choice_question" style="background:url(&#39;/resources/xolrn/icons/questions/small/multiple_choice100x100.png&#39;) no-repeat;"></div>
                    </a>
                    <a href="javascript:insert_question(&#39;multiple_choice_question&#39;);">
                        Mehrfachauswahl
                    </a>
                </td>
                
                <td class="active_td">
                    <a href="javascript:insert_question(&#39;order_question&#39;);">
                        <div class="xoqti_order_question" style="background:url(&#39;/resources/xolrn/icons/questions/small/order100x100.png&#39;) no-repeat;"></div>
                    </a>
                    <a href="javascript:insert_question(&#39;order_question&#39;);">
                        Reihung
                    </a>
                </td>
                
                <td class="active_td">
                    <a href="javascript:insert_question(&#39;text_entry&#39;);">
                        <div class="xoqti_text_entry" style="background:url(&#39;/resources/xolrn/icons/questions/small/text_entry100x100.png&#39;) no-repeat;"></div>
                    </a>
                    <a href="javascript:insert_question(&#39;text_entry&#39;);">
                        Texteingabe
                    </a>
                </td>
                
                <td class="active_td">
                    <a href="javascript:insert_question(&#39;open_text&#39;);">
                        <div class="xoqti_open_text" style="background:url(&#39;/resources/xolrn/icons/questions/small/open_text100x100.png&#39;) no-repeat;"></div>
                    </a>
                    <a href="javascript:insert_question(&#39;open_text&#39;);">
                        Offene Frage
                    </a>
                </td>
                
                    </tr>
                    <tr>
                
                <td class="active_td">
                    <a href="javascript:insert_question(&#39;match&#39;);">
                        <div class="xoqti_match" style="background:url(&#39;/resources/xolrn/icons/questions/small/match100x100.png&#39;) no-repeat;"></div>
                    </a>
                    <a href="javascript:insert_question(&#39;match&#39;);">
                        Zuordnung
                    </a>
                </td>
                
                <td class="active_td">
                    <a href="javascript:insert_question(&#39;selection&#39;);">
                        <div class="xoqti_selection" style="background:url(&#39;/resources/xolrn/icons/questions/small/selection100x100.png&#39;) no-repeat;"></div>
                    </a>
                    <a href="javascript:insert_question(&#39;selection&#39;);">
                        Auswahl
                    </a>
                </td>
                
                <td class="active_td">
                    <a href="javascript:insert_question(&#39;gap&#39;);">
                        <div class="xoqti_gap" style="background:url(&#39;/resources/xolrn/icons/questions/small/gap100x100.png&#39;) no-repeat;"></div>
                    </a>
                    <a href="javascript:insert_question(&#39;gap&#39;);">
                        Lückenzuordnung
                    </a>
                </td>
                
		</tr>
  	</tbody></table>
  </div>

</div>

    </div></div></div>

</div><!--/Main-->

</div><!-- /Document -->
</div><!-- /Background -->

  




<div id="ctxm"></div><div id="jstree-marker" style="display: none;">»</div><div id="jstree-marker-line" style="display: none;"></div><div id="vakata-contextmenu"></div><div id="jquery-overlay" style="background-color: rgb(0, 0, 0); opacity: 0.8; width: 1846px; height: 4314px;"></div><div id="jquery-lightbox" style="top: 1877.18px; left: 0px;"><div id="lightbox-container-image-box" style="width: 687px; height: 701px;"><div id="lightbox-container-image"><img id="lightbox-image" style="display: inline;" src="./4AHME FIVU - Mikroprozessor_files/speicherverwaltung_svg" width="667"><div style="display: block;" id="lightbox-nav"><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#" id="lightbox-nav-btnPrev" style="display: none; height: 701px; background: url(&quot;/resources/jquery-lightbox/0.5/images/lightbox-blank.gif&quot;) no-repeat transparent;"></a><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#" id="lightbox-nav-btnNext" style="display: none; height: 701px; background: url(&quot;/resources/jquery-lightbox/0.5/images/lightbox-blank.gif&quot;) no-repeat transparent;"></a></div><div id="lightbox-loading" style="display: none;"><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#" id="lightbox-loading-link"><img src="./4AHME FIVU - Mikroprozessor_files/lightbox-ico-loading.gif"></a></div></div></div><div id="lightbox-container-image-data-box" style="display: block; width: 667px;"><div id="lightbox-container-image-data"><div id="lightbox-image-details"><span id="lightbox-image-details-caption" style="display: inline;">Arbeitsspeicher beim Atmega16</span><span id="lightbox-image-details-currentNumber" style="display: none;"></span></div><div id="lightbox-secNav"><a href="https://lms.at/dotlrn/classes/informatik/610437.4AHME_FIVU.17_18/xolrn/EC743ABCF7AB5.symlink?resource_id=0-237409759&amp;m=view#" id="lightbox-secNav-btnClose"><img src="./4AHME FIVU - Mikroprozessor_files/lightbox-btn-close.gif"></a></div></div></div></div></body></html>