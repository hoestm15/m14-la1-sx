# *Protokoll:* Julian Ehmann  

## **7. Einheit: Temperaturmessung**  
 Name: Julian Ehmann  
 Klasse: 4AHME  
 Datum: 17.04.2018  
 Anwesend: Berger Emil, Böcksteiner Jakob, Bullner Jeremy, Ehmann Julian, Enzi Gert, Kobor Markus, Knappitsch Robert  
 Abwesend: -
 
 
 
  ### Serielle Schnittstelle in Java
  
  Um unter Java zwischen Programm und Hardware zu kommunizieren, muss die JVM (Java Virtuelle Maschine) zwischengeschalten werden.
  Hierbei greift Java auf eine virtuelle Maschine zu, diese auf das Betriebssystem und das Betriebssystem anschließend auf die Hardware.
  JVM unterstützt allerdings keine seriellen Schnittstellen. Daher benötigt man Java Native Interface (JNI),
  welches eine für Java lesbare .jar Datei erzeugt und eine lesbare Bibliothek erzeugt.
  In der Schule haben wir den Java Simple Serial Connector (JJSC) verwendet.  
  Großer Vorteil: Bibliotheken werden automatisch richtig entpackt und verwendet.
  
  
 ### Klassen in Java
  
  * Interne Klasse:   Alle Attribute von einer äußeren Klasse können übernommen werden.
  * Abstrakte Klasse: Dies ist eine unfertige Klasse, welche verwendet wird um weitere Klassen dieser Art zu erstellen.
                      Hier müssen dann nur einige Funktionen implementiert werden.
  * Interface:        Sammlung von Methoden.
  
  
  ### Vererbungen
  
   In Java gibt es nur eine Einfachvererbung. Eine Elternklasse kann mehrere Kindklassen haben, 
   aber eine Kindklasse kann nur eine Elternklasse haben.
   

  ## Temperaturmessung mit I²C
  
  Im unterhalb gezeigten Code wird von der Klasse **MySingleMeasurementWorker** ein Objekt erstellt.
  
  ### jbutSingleMeasurementActionPerformed
  
  
  ```java
  private void jbutSingleMeasurementActionPerformed(java.awt.event.ActionEvent evt)                       
  {                                                          
    new MySingleMeasurementWorker(serialPort).execute();
  }                                                     
```

  
  ### Worker Klasse SingleMeasurementWorker
  
  Der unten angeführte Code zeigt wie man die eigentliche Aufgabe (das Auslesen) in einen anderen Thread auslagert.
  Dies geschieht mit der Methode doInBackground.
  
```java
package workers;

import java.util.concurrent.TimeUnit;
import javax.swing.SwingWorker;
import jssc.SerialPort;

public class SingleMeasurementWorker extends SwingWorker<Double, String> 
{
    
    private final SerialPort serialPort;

    public SingleMeasurementWorker(SerialPort serialPort) 
    {
        this.serialPort = serialPort;
    }
       
    
    @Override
    protected Double doInBackground() throws Exception 
    {
        
        publish("Einzelmessung gestartet");
        
        //Read LM75: 02 04 00 30 00 01 31 f6 (Modbus-Konfiguration aus README)
        byte [] frame = {0x02, 0x04, 0x00, 0x30, 0x00, 0x01, 0x31, (0xf6-256)};
        //Weil "writeBytes" nur von -128 bis +127 geht.
        
        if (serialPort.writeBytes(frame) == false) 
        {
            throw new Exception("cannot send frame");
        }
                
        TimeUnit.SECONDS.sleep(2);
        byte [] response = serialPort.readBytes();
        System.out.println(response.length);
        byte hb = response[3];
        byte lb = response[4];
        int t = (hb < 0 ? hb+256 : hb) * 256 + (lb < 0 ? lb+256 : lb);
        
        return t/256.0;
    }
    
}
```

### Innere Klasse MySingleMeasurementWorker

Durch die Funktion *get()* können wir die ausgelesenen Werte nun in das vorgesehene Textfeld schreiben.
Durch process wird der Inhalt aus der Funktion *publish()* in das Textfeld geschrieben.

```java
private class MySingleMeasurementWorker extends SingleMeasurementWorker 
{

        public MySingleMeasurementWorker(SerialPort serialPort)
        {
            super(serialPort);
        }

        @Override
        protected void done() 
        {
            try 
            {
                double temp = get();
                jlaTemperatur.setText(String.format("%.1f °C", temp));
                jtfStatus.setText(null);
            } catch (Exception e) 
            {
                showThrowable(new Exception("Einzemessung gescheitert", e));
            } finally 
            {
                activeWorker = null;
                updateSwingControls();
            }
        }

        @Override
        protected void process(List<String> chunks) 
        {
            jtfStatus.setText(chunks.get(chunks.size()-1)); //String aus Publish
        }
        
    }
```
