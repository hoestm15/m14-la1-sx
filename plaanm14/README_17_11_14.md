# Protokoll
## Thema: Diskussion über Maschinenbefehle mit Atmel Studio 

Name: Platzer Andreas <br>
Datum: 14.11.2017 <br>
Gruppe: 2 <br>
Anwesend: Platzer Andreas, Muri Lorenz, Nebel Florian, Mandl Gerhard, Michael Mörth, Moritz Martinak, Mario Nabernik, Marcel Köhler <br>
Abwesend: Es waren alle anwesend. <br>
Abgabe Datum: 05.02.2018 <br>


### Wiederholung der letzten Einheit 

Im ersten Schritt wurden die Protokolle der letzten Einheit besprochen und beurteilt. 
Anschließend wiederholten wir den Stoff der in der letzten Einheit besprochen wurde.

### Analysieren einfacher C Programme mithilfe von Atmel Studio

Mithilfe des Atmel Studios wurden verschiedene Programme geschrieben die wir anschließend in der Maschinensprache analysierten.Durch das Studio konnten wir unsere Programme ohne große Probleme entwickeln. 

### Zusatz einer variable „volatile“

Volatile bedeutet das der Compiler das Programm mit der Variable nicht verkürzt. Es sorgt außerdem dafür das schritte die im Programm eventuell nicht benötigt werden nicht gelöscht werden was für unsere anschließenden Aufgaben im Vorteil hat. Bei manchen Programmen ist es wichtig volatile vorzusetzen um eine Echtzeit zu erhalten. 

### Programme:

#### Erstes Programm „variable definieren“

Die Aufgabe im ersten Programm eine Variable zu definieren und sie dann anschließend den wert 14 zu geben. Weiteres ging es darum die Maschinenbefehle in eine für uns verständliche Schrift zu übersetzen. 

##### Quellcode
```c
int main (void)
{
	volatile unsigned char x;
	x = 12;
	
	return x;
}
```
#### Assemblerbefehle
Schritt | Assemblerbefehle | Beschreibung
--------------- | --------- | ---------
1 | PUSH R28 | Register R28 besitzt einen Wert der im Stack gespeichert wird.
2 | PUSH R29 | Register R29 besitzt einen Wert der im Stack gespeichert wird.
3 | PUSH R1 |  Register R1 besitzt einen Wert der im Stack gespeichert wird. 
4 | IN R28,0x3D | Da der Register R28 nun leer ist kann der Wert 0x3D eingeladen werden. Dieser Wert kommt vom I/O-Register.
5 | IN R29,0x3E | Da der Register R29 nun leer ist kann der Wert 0x3E eingeladen werden. Dieser Wert kommt vom I/O-Register.
6 | LDI R24,0x0C | Die Konstante wird in Hex Codiert und in den Register R28 geschreiben.
7 | STD Y+1,R24 | Der Wert von R24 wird im Stack Speicher als lokalen Variable abgelegt.  
8 | LDD R24,Y+1 | Das Register R24 bekommt den Variablenwert.
9 | LDI R25,0x00 | Das Register R25 bekommt einen Rückgabewert.
10 | POP R0 | Variable wird gelöscht.
11 | POP R29 | R29 wird aus dem Stack gelöscht.
12 | POP R28 | R28 wird aus dem Stack gelöscht.



#### Zweites Programm „Addieren von zwei Variablen“

Im folgendem Programm werden zwei definierten Variablen a und b Addiert. Inder Assembler Sprache bedeutet das einen enormen aufwand zwei variablen zu verknüpfen. Bei Befehlen die wir nicht wussten nahmen wir das Datenblatt der Atmega328p zur Hand und suchten nach der Beschreibung.

##### Quellcode
```c
int main (void)
{
	volatile unsigned char a = 13;
	volatile unsigned char b = 5;
	
	return a+b;
}
```
#### Assemblerbefehle
Schritt | Assemblerbefehle | Beschreibung
--------------- | --------- | ---------
1 | PUSH R28 | Register R28 besitzt einen Wert der im Stack gespeichert wird.
2 | PUSH R29 | Register R28 besitzt einen Wert der im Stack gespeichert wird.
3 | RCALL PC+0x0001 | Dieser Befehl beschreibt einen sprung im Programm.
4 | IN R28,0x3D | Da der Register R28 nun leer ist kann der Wert 0x3D eingeladen werden. Dieser Wert kommt vom I/O-Register.
5 | IN R29,0x3E | Da der Register R28 nun leer ist kann der Wert 0x3D eingeladen werden. Dieser Wert kommt vom I/O-Register.
6 | LDI R24,0x0C | Die Konstante wird in Hex Codiert und in den Register R24 geschreiben.
7 | STD Y+1,R24 | Der Wert von R24 wird im Stack Speicher als lokalen Variable abgelegt.
8 | LDI R24,0x08 | Die Konstante wird in Hex Codiert und in den Register R24 geschreiben.
9 | STD Y+2,R24 | Register R24 wird am Stack abgelegt.
10 | LDD R24,Y+1 | Das Register R24 bekommt den Variablenwert.
11 | LDD R18,Y+2 | Das Register R18 bekommt den Variablenwert.
12 | LDI R19, 0x00 | Der Wert 0x00 wird ins Register R19 geladen.
13 | ADD R18,R24 | Die beiden Register werden Addiert (ohne Carry-Flags)
14 | ADC R19,R1 | Addition mit Carry-Flags
15 | POP R0 | Variable wird gelöscht.
16 | POP R0 | Variable wird gelöscht.
17 | POP R29 | R28 wird aus dem Stack gelöscht.
18 | POP R28 | R28 wird aus dem Stack gelöscht.



#### Letztes Programm „Speed-Test“

Im letzten Programm ging es Hauptsächlich darum die Geschwindigkeit herauszufinden die der Microcontroller benötigt um die zwei Variablen zu Multiplizieren und zu Dividieren.

```c
int main (void)
{
	volatile unsigned double a = 234.2;
	volatile unsigned double b = 734.5;
	
	return a*b;
// oder return a/b;
	
}
```

Bei dieser Übung ist uns aufgefallen, dass der Mikrocontroller bei der Division und Multiplikationen wesentlich länger braucht als bei Additionen und Subtraktionen. 


#### Resümee
Das Herausfinden mancher Maschinenbefehle aus dem Datenblatt ist manches mal etwas schwierig. Mit etwas Geduld lassen sich aber aller befehle finden und übersetzen. Wichtig bei unseren Übungen war es auch den Zusatz Volatile zu verwenden um das ganze ausmaß unseres Programmes zu sehen. Dies kann zu Beeinträchtigung der Echtzeit führen. 






